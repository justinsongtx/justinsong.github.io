{"meta":{"version":1,"warehouse":"3.0.2"},"models":{"Asset":[{"_id":"themes/clover/source/css/fonts.scss","path":"css/fonts.scss","modified":0,"renderable":1},{"_id":"themes/clover/source/css/functions.scss","path":"css/functions.scss","modified":0,"renderable":1},{"_id":"themes/clover/source/css/global.scss","path":"css/global.scss","modified":0,"renderable":1},{"_id":"themes/clover/source/css/index.scss","path":"css/index.scss","modified":0,"renderable":1},{"_id":"themes/clover/source/css/layout.scss","path":"css/layout.scss","modified":0,"renderable":1},{"_id":"themes/clover/source/css/mixins.scss","path":"css/mixins.scss","modified":0,"renderable":1},{"_id":"themes/clover/source/css/reset.css","path":"css/reset.css","modified":0,"renderable":1},{"_id":"themes/clover/source/fonts/BebasNeue.otf","path":"fonts/BebasNeue.otf","modified":0,"renderable":1},{"_id":"themes/clover/source/fonts/MaturaMTScriptCapitals.ttf","path":"fonts/MaturaMTScriptCapitals.ttf","modified":0,"renderable":1}],"Cache":[{"_id":"themes/clover/.DS_Store","hash":"5b7d45fdbe0e50c1d934f6e3b451c7b36c174407","modified":1590864085000},{"_id":"themes/clover/_config.yml","hash":"d48abd02a36b7183224b7ffb8c8354a880bdcc76","modified":1590860612000},{"_id":"themes/clover/index.html","hash":"f572d396fae9206628714fb2ce00f72e94f2258f","modified":1590860612000},{"_id":"themes/clover/readme.md","hash":"19bc83fd9fdeb5a350c76b3b875b6445fbca7a76","modified":1590860612000},{"_id":"source/.DS_Store","hash":"5b24a8cc1af4684a51cd454c224ce888997e1d81","modified":1623658525018},{"_id":"themes/clover/languages/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1590860612000},{"_id":"themes/clover/scripts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1590860612000},{"_id":"source/_posts/App-Store-Connect-分析产品数据.md","hash":"451e29451a80150c03ad3ab12562937409ee73a5","modified":1592839449000},{"_id":"source/_posts/Apple机器学习探索.md","hash":"0bd6a27ac39f1ee76a6e27d326a632c52cc8624a","modified":1592839449000},{"_id":"source/_posts/App应对ATS限制策略.md","hash":"23088a78b20f3dfea7e4209a261f4acbd92b4771","modified":1600763555000},{"_id":"source/_posts/App目录结构重构.md","hash":"f7986c4ad567495bc941be67941ad1859faa03b8","modified":1600763556000},{"_id":"source/_posts/Dart背景调查.md","hash":"78c613fbb75dcf72a3d1c2b19dac898c07bb9caf","modified":1593944174000},{"_id":"source/_posts/Mac清除开机密码限制.md","hash":"5019a0e90ac6c0b73de74b0b288975856200d170","modified":1592840367000},{"_id":"source/_posts/MarkDown兼容OutLook小记.md","hash":"63846e2596dc0fb3a21f69008296a5caf8002c55","modified":1600619875000},{"_id":"source/_posts/XX视频图片上传小记.md","hash":"5475e0bf56bfd83af90308d88252d5f1c1eff1ac","modified":1600619819000},{"_id":"source/_posts/arduino-经典开发板引脚图.md","hash":"64c7eaf274a78519b8029b2f95492ef4e0df81f2","modified":1592755341000},{"_id":"source/_posts/git-常用命令备忘.md","hash":"e627d494df36290cc6f4d8a82c662551cc85691d","modified":1609298431164},{"_id":"source/_posts/hello-world.md","hash":"c24dc4921067178628ebc2bc3a1a40e9b332d67f","modified":1592719446000},{"_id":"source/_posts/iOS-越狱用户灰度流程-常见问题列表.md","hash":"29cdde9d4f4829ba49a697443debec073e91e2b4","modified":1600620241000},{"_id":"source/_posts/iOS内存分配：堆、栈、全局区、常量区、代码区.md","hash":"4a650e12e1e479ad085ef37c18c645455f6ce5f5","modified":1599407793000},{"_id":"source/_posts/iOS各种设备唯一标识符.md","hash":"077cf98e2bec6c603a8cc3cb6071ff325ec7e7ed","modified":1597341152000},{"_id":"source/_posts/ios知识梳理.md","hash":"4f97c5d32beebd85cb2a5340c81fe35be3c31f37","modified":1600622659000},{"_id":"source/_posts/pod install 警告梳理.md","hash":"e3a68a9307c2c605247b0f5e359fe6b1b0d42c75","modified":1592750899000},{"_id":"source/_posts/sourcetree-跳过登陆注册.md","hash":"7f5753b1acb894d22f2e410bcfe95a9ed63b04fe","modified":1597341152000},{"_id":"source/_posts/xcode历史版本.md","hash":"3624e79f5d731032b3d9e78f4063394037abe6c3","modified":1597341152000},{"_id":"source/_posts/.DS_Store","hash":"89614a1a796e4dbd13c805295c9045a33b092070","modified":1604848447429},{"_id":"source/_posts/人肉方法随记.md","hash":"d45ea40a3d437239da0000261248798943133f76","modified":1593366232000},{"_id":"source/_posts/代码中的-一等公民.md","hash":"c05dd9c240eddbfcd7f6a5c19f9157198d0703ac","modified":1592749772000},{"_id":"source/_posts/初次了解PCB绘制-EasyEDA.md","hash":"22577702ee1fc69cc4a9ffe21d3533d1779b5e53","modified":1593369681000},{"_id":"source/_posts/好用的软件下载网站.md","hash":"7b602be436507708b821a91f6728b06b7537b645","modified":1593940778000},{"_id":"source/_posts/一个ios第三方库管理工具--Carthage.md","hash":"df7f7c4de1191a7d5869b739592d7eac812fd4be","modified":1592393570000},{"_id":"source/_posts/从编译失败了解Xcode中的各种架构-armv7-armv7s-arm64-i386-x86-64.md","hash":"456ba87b83609aec5d7ac34fb1b993891b7c0b79","modified":1600763826000},{"_id":"source/_posts/如何检测项目中对UIWebview的引用 (ITMS-90809).md","hash":"f6f603465adbed8455ff3deffb4b4c4e7e9b4b0d","modified":1592035215000},{"_id":"source/_posts/封装内嵌UICollectionView和UIPageControl的ScrollView.md","hash":"ddc9d6a5f8ab6d39f4da7bf1fcb41cb59da4a7ca","modified":1600763774000},{"_id":"source/_posts/手q环境配置踩坑记.md","hash":"af30209779c565c3e76734357c866bdd4d789954","modified":1593941375000},{"_id":"source/_posts/滤镜资料.md","hash":"40c1b74761dcbdb20e84ef9a718aa06c5807dfa0","modified":1597510328000},{"_id":"source/_posts/蓝盾打包问题梳理.md","hash":"73615ca71dc78d326525fc5193db29ac4c40476f","modified":1592750262000},{"_id":"source/_posts/蓝盾流水 与 PUSH功能.md","hash":"67f363ec380b4329f7b0d4a53842c721dccfe483","modified":1592551774000},{"_id":"source/_posts/蓝盾流水耗时优化.md","hash":"a52f9ed441443df51d2111574613d6f17e88bbd1","modified":1591951525000},{"_id":"source/_posts/记一次bug，微信登录分享跳转多次.md","hash":"8a9737a1b5a522b724eee8217aacdb6a2e5f86b5","modified":1592754544000},{"_id":"source/_posts/记一次发布失败-ITMS-90034-Missing-or-invalid-signature.md","hash":"ab65497b46bfec709711795e447ab4b4e334e3c3","modified":1600619749000},{"_id":"source/_posts/记一次发布失败 ITMS-90034: Missing or invalid signature.md","hash":"a0b2aa57d27c6e096ff8151c7e2db5be41f3f5d7","modified":1592719446000},{"_id":"themes/clover/languages/default.yml","hash":"1bd428595cb5d7804374fc554268fb07d3c180b5","modified":1590860612000},{"_id":"themes/clover/languages/zh-CN.yml","hash":"04be74e45b71ccf7b8288fda315af9e9ccbc33f7","modified":1590860612000},{"_id":"themes/clover/layout/about.ejs","hash":"b5f2aa913991788561ac73a78c0ca0eee0c16c6d","modified":1590860612000},{"_id":"themes/clover/layout/category.ejs","hash":"9669da1b90ab979d7eaec34c45b43285a9fb6ab9","modified":1590860612000},{"_id":"themes/clover/layout/layout.ejs","hash":"8d28870a73489cb03ec5432423f2915e1d5f06eb","modified":1590860612000},{"_id":"themes/clover/layout/archive.ejs","hash":"96a0850bad36d34942124d63b8ef97ee30e518f2","modified":1590860612000},{"_id":"themes/clover/layout/post.ejs","hash":"6492303c001cf39f189c5a436d60298f6ba483aa","modified":1590860612000},{"_id":"themes/clover/layout/index.ejs","hash":"40a43cc24bd607060cf253497f2411813d311e8d","modified":1590860612000},{"_id":"themes/clover/layout/tag.ejs","hash":"893ba1e1bafcdc3ee2131f431dce15db2c5f5324","modified":1590860612000},{"_id":"themes/clover/scripts/category.js","hash":"14d066502595dfa9b738c49ab974f42888b6580f","modified":1590860612000},{"_id":"themes/clover/scripts/home.js","hash":"39544710966f64cf604faf2d1dfa750d4ac79a78","modified":1590860612000},{"_id":"themes/clover/scripts/path_url.js","hash":"3fad526f54993612c6a9e6a1bea9dad2894700df","modified":1590860612000},{"_id":"themes/clover/source/.DS_Store","hash":"ac958ecbf999d911f8d354407018da09e78d0146","modified":1590864085000},{"_id":"themes/clover/layout/_partial/article.ejs","hash":"ec72bf2fa003b881e25d3ad002a7a283c3d3339d","modified":1590860612000},{"_id":"themes/clover/layout/_partial/article-card.ejs","hash":"d709935e3cc420caec70a37069741b0fe5939e2f","modified":1590860612000},{"_id":"themes/clover/layout/_partial/excerpt.ejs","hash":"b0ad1a2336fcace485e9cd523fb8386c0e0933b5","modified":1590860612000},{"_id":"themes/clover/layout/_partial/footer.ejs","hash":"1a15a05f545a5844f7260c5da9643a3858062ffe","modified":1590860612000},{"_id":"themes/clover/layout/_partial/head.ejs","hash":"e1a3502ebf5f23a9ee1e32e889929f464b1d1e2e","modified":1590860612000},{"_id":"themes/clover/layout/_partial/nav.ejs","hash":"84e950ce603f09729a0dc840d34b5dc7f6442154","modified":1590860612000},{"_id":"themes/clover/layout/_partial/pagination.ejs","hash":"da9474ba8f58d01da1a12786402d119bfff92efc","modified":1590860612000},{"_id":"themes/clover/layout/_partial/project-card.ejs","hash":"0eaf81701d2bdd9d41000a6047d862ebf2e5067f","modified":1590860612000},{"_id":"themes/clover/source/css/fonts.scss","hash":"d4c351980c75898e7edd1219bb19d060b97d2501","modified":1590860612000},{"_id":"themes/clover/source/css/functions.scss","hash":"7672c6b7bca0bf89cba4b26bcac03ecd380b7502","modified":1590860612000},{"_id":"themes/clover/source/css/global.scss","hash":"544bbf0c3b699a414c4d6ec8556a122727e2f33a","modified":1590860612000},{"_id":"themes/clover/source/css/index.scss","hash":"ff4bd1dd687a746513faf43dc5829a32edb8fc2f","modified":1590860612000},{"_id":"themes/clover/source/css/layout.scss","hash":"33478e6ea726df389aa12fb8edba9b0bf78dd22f","modified":1590860612000},{"_id":"themes/clover/source/css/mixins.scss","hash":"a07b64d6df8b66c508ef14eaacf4edee759371b1","modified":1590860612000},{"_id":"themes/clover/source/css/reset.css","hash":"a1c2e8d00115d0b8ba97ae8e5e9da2f533e752f7","modified":1590860612000},{"_id":"themes/clover/source/fonts/MaturaMTScriptCapitals.ttf","hash":"390898e00ebcd9025a5d8e8d1f6becbe3532695b","modified":1590860612000},{"_id":"themes/clover/source/fonts/BebasNeue.otf","hash":"8f1dc695a6c4bb7f91a32db32928e0da567e82fc","modified":1590860612000},{"_id":"themes/clover/source/css/_partial/about.scss","hash":"53952d9d531280ca98f34b3a74ec5dcf55b105d6","modified":1590860612000},{"_id":"themes/clover/source/css/_partial/archive.scss","hash":"9e3ca63734ec6cfbad983ad93ae4a38e56d59138","modified":1590860612000},{"_id":"themes/clover/source/css/_partial/article.scss","hash":"ddd6c9f08d8598228b2435a0cc49435149fb36af","modified":1590860612000},{"_id":"themes/clover/source/css/_partial/footer.scss","hash":"5a3cf1f7c17cddb14f71c4083dfd30b4c02373b2","modified":1590860612000},{"_id":"themes/clover/source/css/_partial/nav.scss","hash":"344a5d5dcc3225dc4a3187c0338bccfa6abc680e","modified":1590860612000},{"_id":"themes/clover/source/css/_partial/pagination.scss","hash":"d77a1a841b624bc8d60142e08681b4bc81dce353","modified":1590860612000},{"_id":"themes/clover/source/css/_partial/project-card.scss","hash":"82f752d91f6174b1aad3f439811a01bd47dd56bc","modified":1590860612000},{"_id":"themes/clover/source/css/_partial/tagcloud.scss","hash":"4acedec40f7e605cceb84edcded117241f10825f","modified":1590860612000},{"_id":"public/2020/09/22/从编译失败了解Xcode中的各种架构-armv7-armv7s-arm64-i386-x86-64/index.html","hash":"19f786b3bda496ba44352a6c3b5c2aee71752a2c","modified":1604847138297},{"_id":"public/2020/09/21/iOS-越狱用户灰度流程-常见问题列表/index.html","hash":"7822312cfa0a49fb3ce7a0b4207daeab7a9449ad","modified":1604223797687},{"_id":"public/2020/09/21/App应对ATS限制策略/index.html","hash":"e29018b1ef6b277d85085ccba12089053c411b44","modified":1604223797687},{"_id":"public/2020/09/21/App目录结构重构/index.html","hash":"02f79247903889915b603a9ed69cdfc0c3125046","modified":1604223797687},{"_id":"public/2020/09/21/封装内嵌UICollectionView和UIPageControl的ScrollView/index.html","hash":"13ae9f7d45d9737cd00fd26ecb3f6ce97f838091","modified":1604223797687},{"_id":"public/2020/09/21/MarkDown兼容OutLook小记/index.html","hash":"778af9af8b5582c1afd4d6ee05c3f3948f96c784","modified":1604847138297},{"_id":"public/2020/09/21/XX视频图片上传小记/index.html","hash":"d3e854c1100722439857b683a5b4bd479713e5cd","modified":1604223797687},{"_id":"public/2020/09/21/记一次发布失败-ITMS-90034-Missing-or-invalid-signature/index.html","hash":"f6a7dc888bc399bfed4a1fb418261db67bd9b749","modified":1604847138297},{"_id":"public/2020/09/07/ios知识梳理/index.html","hash":"785420f7c9b8420b82524f793a41e122d56aaab5","modified":1604223797687},{"_id":"public/2020/09/06/iOS内存分配：堆、栈、全局区、常量区、代码区/index.html","hash":"e601b9a0ef3420b4ac43b77195fd99c14debfbfe","modified":1604223797687},{"_id":"public/2020/08/14/滤镜资料/index.html","hash":"3d74981e25456c495f8402157d00ad6adceec057","modified":1604223797687},{"_id":"public/2020/07/22/sourcetree-跳过登陆注册/index.html","hash":"bcc1eb1ab80985ac3dc9de3f9bfd2dbd05ff3781","modified":1604223797687},{"_id":"public/2020/07/14/iOS各种设备唯一标识符/index.html","hash":"fe4784c9d7a2164f4ef020f6238fb4165dd28dc9","modified":1604223797687},{"_id":"public/2020/07/03/好用的软件下载网站/index.html","hash":"bc4a1520d6aeebd309a3bdadc3bc7fd537b95e53","modified":1604223797687},{"_id":"public/2020/07/05/手q环境配置踩坑记/index.html","hash":"832dcb09d91e1999f3dac4628fcb099ac6a8bc6e","modified":1604223797687},{"_id":"public/2020/07/02/xcode历史版本/index.html","hash":"a8f5cc01326f847403a582b3c46456bdf4d0859f","modified":1604223797687},{"_id":"public/2020/06/29/Dart背景调查/index.html","hash":"5245779f58f9275d241a8d56b7315f481e996598","modified":1604223797687},{"_id":"public/2020/06/28/人肉方法随记/index.html","hash":"4711753396c12985686f7395ffafcdca1f9cd0d2","modified":1604223797687},{"_id":"public/2020/06/28/初次了解PCB绘制-EasyEDA/index.html","hash":"3e8922e09475b66dd018e7b9cd2ecc1788e250da","modified":1604223797687},{"_id":"public/2020/06/22/Mac清除开机密码限制/index.html","hash":"d49ddfcd1937cdebc052cabe97cf347c4a416a48","modified":1604223797687},{"_id":"public/2020/06/22/App-Store-Connect-分析产品数据/index.html","hash":"8e6e23195bda7331a85e63d1c22decbd9d5099fd","modified":1604223797687},{"_id":"public/2020/06/22/Apple机器学习探索/index.html","hash":"b849d0584ca7ca86e752e7bfa25823c478a4ac6d","modified":1604223797687},{"_id":"public/2020/06/22/git-常用命令备忘/index.html","hash":"4ed10aac6a0666037e3c0e8b6661bcb9fff0ba8e","modified":1609298452883},{"_id":"public/2020/06/21/arduino-经典开发板引脚图/index.html","hash":"2b78670720ec2e584d6542e1727d9b123884fde5","modified":1604847138297},{"_id":"public/2020/06/21/hello-world/index.html","hash":"7163a812fa66f82db3c9560495f64a7abd9a3037","modified":1604223797687},{"_id":"public/2020/06/21/记一次发布失败 ITMS-90034: Missing or invalid signature/index.html","hash":"c03b1c6131c0215eecb4ce25879791b36842e3e8","modified":1604847138297},{"_id":"public/2020/06/19/蓝盾流水 与 PUSH功能/index.html","hash":"9723d486698b337a680b8d2217d515160aa6243f","modified":1604223797687},{"_id":"public/2020/06/17/一个ios第三方库管理工具--Carthage/index.html","hash":"644b030868274ee63a8ec81d6dddcf1a60874736","modified":1604223797687},{"_id":"public/2020/06/17/记一次bug，微信登录分享跳转多次/index.html","hash":"875c266197ae6680ab54861730d5843cfbe9d401","modified":1604223797687},{"_id":"public/2020/06/16/代码中的-一等公民/index.html","hash":"7a8088a0d6a7a74f899fb66d9dc7827715e7c2f9","modified":1604223797687},{"_id":"public/2020/06/12/蓝盾流水耗时优化/index.html","hash":"575a37c414b945a619c24b4a712578e8809a689e","modified":1604223797687},{"_id":"public/2020/06/12/如何检测项目中对UIWebview的引用 (ITMS-90809)/index.html","hash":"6169160e89dff598388f141d766ad6e2365f9356","modified":1604223797687},{"_id":"public/2020/06/09/pod install 警告梳理/index.html","hash":"74b183c6b4bad8ef5bbce006384d3a8efa541dcc","modified":1604223797687},{"_id":"public/2020/06/09/蓝盾打包问题梳理/index.html","hash":"3c957ad5d4cc0dbc4cd307c28863b300b9cada8a","modified":1604223797687},{"_id":"public/index.html","hash":"73600f83c339dd6a3ff5c03c11d84a4aaf183ec5","modified":1623658754186},{"_id":"public/page/2/index.html","hash":"ff667b898ea22760f52d63f3831a9d8f56127b15","modified":1623658754186},{"_id":"public/page/3/index.html","hash":"2b6d605b3ac22c92e5023402e8caa1425521c436","modified":1623658754186},{"_id":"public/page/4/index.html","hash":"4973cfd75000ef9682d245fd93f15e7f2acc3b31","modified":1623658754186},{"_id":"public/tags/arduino/index.html","hash":"4c5f0d5b65b2db5848c644ab2d99c99f7621d027","modified":1604223797687},{"_id":"public/archives/index.html","hash":"776fd23f25872795a11ff4990a9c6ee0a4fbf7a3","modified":1623658754186},{"_id":"public/archives/page/2/index.html","hash":"220d2bd2bdaa272b84511baf2731873c8bfa2204","modified":1623658754186},{"_id":"public/archives/page/3/index.html","hash":"c72021fdfe83caceaf152af5db2ed8d8a812d9fd","modified":1623658754186},{"_id":"public/archives/page/4/index.html","hash":"352d9c12289c39894966cdaaf2e1a93b0890f135","modified":1623658754186},{"_id":"public/archives/2020/index.html","hash":"e3fd11e08c28cca75cb09c013f091b2a3aef00f1","modified":1609383380088},{"_id":"public/archives/2020/page/2/index.html","hash":"1ef75a67528c137ffe4239a2d1777f491f2a192d","modified":1609383380088},{"_id":"public/archives/2020/page/3/index.html","hash":"ca624c1daed57c3c0c51155b981bfdf120ff37a0","modified":1609383380088},{"_id":"public/archives/2020/page/4/index.html","hash":"ab47185f611563d09dd3c51a98d8d2d6772c9c2f","modified":1609383380088},{"_id":"public/archives/2020/06/index.html","hash":"c8f1db5bc150614871dcd6c1c9048e60f71dedd7","modified":1604847138297},{"_id":"public/archives/2020/06/page/2/index.html","hash":"390f98fdb624710f97a474d81635c9a2e7d528b3","modified":1604847138297},{"_id":"public/archives/2020/07/index.html","hash":"a05d6b0c2661a42b2e5a07be87178a6cbd86a084","modified":1604223797687},{"_id":"public/archives/2020/08/index.html","hash":"0050332275f00044435972b58b3519d8c5a8bfd9","modified":1604223797687},{"_id":"public/archives/2020/09/index.html","hash":"cef92adb838f04f604edae7787c7c6de249c8684","modified":1604847138297},{"_id":"public/categories/index.html","hash":"569a4bef3fc0450c23399d20a2f2f2838c7c1fa3","modified":1620716565607},{"_id":"public/categories/page/2/index.html","hash":"5c219a30af342ba91270c8c6fe826d402d6215a2","modified":1620716565607},{"_id":"public/categories/page/3/index.html","hash":"3744e5d7eebb466e4deb118f6b49af63a6b866e8","modified":1620716565607},{"_id":"public/categories/page/4/index.html","hash":"6ae8e1fb23c0c0329748f03f8bfc6ce09a9f205f","modified":1620716565607},{"_id":"public/css/global.scss","hash":"544bbf0c3b699a414c4d6ec8556a122727e2f33a","modified":1604224080451},{"_id":"public/css/index.scss","hash":"ff4bd1dd687a746513faf43dc5829a32edb8fc2f","modified":1604224080451},{"_id":"public/css/functions.scss","hash":"7672c6b7bca0bf89cba4b26bcac03ecd380b7502","modified":1604224080451},{"_id":"public/css/fonts.scss","hash":"d4c351980c75898e7edd1219bb19d060b97d2501","modified":1604224080451},{"_id":"public/css/mixins.scss","hash":"a07b64d6df8b66c508ef14eaacf4edee759371b1","modified":1604224080451},{"_id":"public/css/layout.scss","hash":"33478e6ea726df389aa12fb8edba9b0bf78dd22f","modified":1604224080451},{"_id":"public/fonts/MaturaMTScriptCapitals.ttf","hash":"390898e00ebcd9025a5d8e8d1f6becbe3532695b","modified":1604223797687},{"_id":"public/fonts/BebasNeue.otf","hash":"8f1dc695a6c4bb7f91a32db32928e0da567e82fc","modified":1604223797687},{"_id":"public/css/reset.css","hash":"a1c2e8d00115d0b8ba97ae8e5e9da2f533e752f7","modified":1604223797687},{"_id":"source/_posts/接入企业微信机器人笔记.md","hash":"1203456b3257b1591e3941921ea5eb0788e6cbb7","modified":1600765178000},{"_id":"source/_posts/邀请码后台逻辑梳理.md","hash":"e510ff834a0ae340138996dc90c919a99f50c7c9","modified":1600765218000},{"_id":"public/2020/09/22/邀请码后台逻辑梳理/index.html","hash":"fc50c0222e7efce85211731ad752de27c2938ba0","modified":1604224080451},{"_id":"public/2020/09/22/接入企业微信机器人笔记/index.html","hash":"79178b7dab980544f5f3b252c6da2e62963a4531","modified":1604224080451},{"_id":"public/archives/2020/09/page/2/index.html","hash":"035533298efcc49b76ebc2159190ef8c081b6560","modified":1604224080451},{"_id":"source/_posts/我特么试试.md","hash":"112bc7317a67e4706bfc8bcdc99d80de14d9d0dd","modified":1604225845213},{"_id":"public/2020/11/01/我特么试试/index.html","hash":"74d6b799078283894396d7376ede765b5a79dd3d","modified":1604225940896},{"_id":"public/archives/2020/11/index.html","hash":"6230584437c090f1ebfdca5ef907b060a51d249c","modified":1604904369038},{"_id":"source/_posts/MediaPipe-iOS真机运行指引.md","hash":"d295224f19275f618cce9e8ef35a7c67d0ec0540","modified":1604848798798},{"_id":"public/2020/11/08/MediaPipe-iOS真机运行指引/index.html","hash":"ccff7593654e85d01380309d81101c289ea3d3bd","modified":1604904369038},{"_id":"source/_posts/MediaPipe学习顺序.md","hash":"1ef67470385d35e590b1bb9a171b725f7caaf778","modified":1604904341039},{"_id":"public/2020/11/09/MediaPipe学习顺序/index.html","hash":"ecf9ab15c0439ebc71bd7bf3dbfd02f1df48603d","modified":1609383380088},{"_id":"source/_posts/NSString类文件夹路径的处理方法.md","hash":"7fd619ffbd62c0b928b56c51f76f1596dcb1f215","modified":1609383349345},{"_id":"public/2020/12/31/NSString类文件夹路径的处理方法/index.html","hash":"cecc53ed9644bd6a97b32a22e55dd2912487ac75","modified":1614507391499},{"_id":"public/archives/2020/12/index.html","hash":"27dd75eaff33cf6b4c7855162e36ae35f9238d24","modified":1609383380088},{"_id":"source/_posts/iphone机型架构-对OpenGLES版本的支持情况.md","hash":"4a6eec32c026ca4283808e762d5e7afbd206115a","modified":1614507376174},{"_id":"public/2021/02/28/iphone机型架构-对OpenGLES版本的支持情况/index.html","hash":"12aae5978c0de9f90d53fd8bd727026eeea3a924","modified":1615789514680},{"_id":"public/archives/2021/index.html","hash":"f4891965aee34ff765b96e4ee6987f5a7e0ac7d8","modified":1623658754186},{"_id":"public/archives/2021/02/index.html","hash":"07a3375f7085ad711730025f79dc8032d25aef8e","modified":1614507391499},{"_id":"source/_posts/正则表达式生成网站.md","hash":"47f55cebca2361a9af1b58c256706df4e7b53729","modified":1615789502155},{"_id":"public/2021/03/15/正则表达式生成网站/index.html","hash":"feb42e4c6d8a1a22ff46ef3f0b8d1cbd8161efc7","modified":1615878505308},{"_id":"public/archives/2021/03/index.html","hash":"42f5e8c76e7bb19e0f32cbcefd1c07abc50e197b","modified":1616052252921},{"_id":"source/_posts/CVPixelBufferRef-常用函数.md","hash":"86a56f28c36cc6cb1083cadbf6c38dc398fa4c7a","modified":1615878493885},{"_id":"public/2021/03/16/CVPixelBufferRef-常用函数/index.html","hash":"cbe652af367daa0c30f53500e5203fa544a96eed","modified":1615903865099},{"_id":"source/_posts/设置ios摄像头分辨率.md","hash":"908653ba44ec3fd29f84fe23387e5a0c50b6a1ac","modified":1615903847688},{"_id":"public/2021/03/16/设置ios摄像头分辨率/index.html","hash":"9d6220226d497a06e35506acb4644515fa40f2f8","modified":1616052252921},{"_id":"source/_posts/Xcode自动管理证书文件模式下更新provisioning-profile文件.md","hash":"4840553563a6e5be459cc3e46f6b8096b234d30d","modified":1616052237302},{"_id":"public/2021/03/18/Xcode自动管理证书文件模式下更新provisioning-profile文件/index.html","hash":"2c2cf65987fdce209f1380ee4c17a0f98cd083c3","modified":1620716565607},{"_id":"source/_posts/iOS库中bitcode、架构、静态动态的判断.md","hash":"eefa757adcbff852e2563e1fe98049a33b464629","modified":1620716444776},{"_id":"public/2021/05/11/iOS库中bitcode、架构、静态动态的判断/index.html","hash":"eedf405c72b38d2d63d7f6d271a137f2b399e3c7","modified":1620803515702},{"_id":"public/archives/page/5/index.html","hash":"7ef4429a5209c7577388fa2d0e22f8f6e6a25413","modified":1623658754186},{"_id":"public/archives/2021/05/index.html","hash":"6ab8a0bcb38c5470711051446b7671dccd211db4","modified":1620896883235},{"_id":"public/categories/page/5/index.html","hash":"a3ff29a1a27ce6fb277cf535427444b633e832b6","modified":1623658754186},{"_id":"public/page/5/index.html","hash":"5a0c73b1161fe6e1b4d4438995d5dc896e7356fe","modified":1623658754186},{"_id":"source/_posts/xcodebuild-踩坑和疑惑.md","hash":"c22d1ecb04c17e6e30db38a35239a06ea878fec4","modified":1620976191162},{"_id":"public/2021/05/12/xcodebuild-踩坑和疑惑/index.html","hash":"d73af690573f97b0d78a9d77b6c4c88ad152015e","modified":1620976209310},{"_id":"source/_posts/luajit-iOS打包笔记.md","hash":"514d011a4491c21ae4bc4e5c9959ac38d7cab4d0","modified":1620892602613},{"_id":"public/2021/05/13/luajit-iOS打包笔记/index.html","hash":"8a979cad4a0bd07835b46b232f68b07e944b4401","modified":1620896883235},{"_id":"source/_posts/Chipmunk2D-iOS打包笔记.md","hash":"40d5511ad9428e2f487f675f34c091917afaa4cc","modified":1620893513876},{"_id":"source/_posts/webp-iOS打包笔记.md","hash":"221417600cb14b9ea3dd6a8fc991e42ea031b8d7","modified":1620896236500},{"_id":"public/2021/05/13/webp-iOS打包笔记/index.html","hash":"6f9790d04b42ff7a085c618733fab2e78769371f","modified":1623658754186},{"_id":"public/2021/05/13/Chipmunk2D-iOS打包笔记/index.html","hash":"b8d1abf2068e99680009eccf7b2a93a68a11b4af","modified":1620896883235},{"_id":"source/_posts/解决SourceTree反复要求输入密码.md","hash":"8e4c28e8124ea7e3e3f159f16262e123231bea34","modified":1623658742373},{"_id":"public/2021/06/14/解决SourceTree反复要求输入密码/index.html","hash":"0437cd52d2ceb4a6e43984343b11ef36732e5c0c","modified":1623658754186},{"_id":"public/archives/2021/page/2/index.html","hash":"d217cf47d722b54228edbb671c037705ecc1b426","modified":1623658754186},{"_id":"public/archives/2021/06/index.html","hash":"e093dbd3b10e01dd2ebc1b11f260c0a518cc4ec0","modified":1623658754186}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"App Store Connect 分析产品数据","date":"2020-06-22T06:31:47.000Z","_content":"\n\n资料：\nhttps://developer.apple.com/cn/app-store-connect/analytics/","source":"_posts/App-Store-Connect-分析产品数据.md","raw":"---\ntitle: App Store Connect 分析产品数据\ndate: 2020-06-22 14:31:47\ntags:\n---\n\n\n资料：\nhttps://developer.apple.com/cn/app-store-connect/analytics/","slug":"App-Store-Connect-分析产品数据","published":1,"updated":"2020-06-22T15:24:09.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgyxlish00000iu68vb130qt","content":"<p>资料：<br><a href=\"https://developer.apple.com/cn/app-store-connect/analytics/\" target=\"_blank\" rel=\"noopener\">https://developer.apple.com/cn/app-store-connect/analytics/</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>资料：<br><a href=\"https://developer.apple.com/cn/app-store-connect/analytics/\" target=\"_blank\" rel=\"noopener\">https://developer.apple.com/cn/app-store-connect/analytics/</a></p>\n"},{"title":"Apple机器学习探索","date":"2020-06-22T06:31:12.000Z","_content":"\n\n资料：\nhttps://developer.apple.com/cn/machine-learning/","source":"_posts/Apple机器学习探索.md","raw":"---\ntitle: Apple机器学习探索\ndate: 2020-06-22 14:31:12\ntags:\n---\n\n\n资料：\nhttps://developer.apple.com/cn/machine-learning/","slug":"Apple机器学习探索","published":1,"updated":"2020-06-22T15:24:09.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgyxlisl00010iu6ehl7fz2c","content":"<p>资料：<br><a href=\"https://developer.apple.com/cn/machine-learning/\" target=\"_blank\" rel=\"noopener\">https://developer.apple.com/cn/machine-learning/</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>资料：<br><a href=\"https://developer.apple.com/cn/machine-learning/\" target=\"_blank\" rel=\"noopener\">https://developer.apple.com/cn/machine-learning/</a></p>\n"},{"title":"App应对ATS限制策略","date":"2020-09-20T16:40:02.000Z","_content":"\n\n\n\n`结果先行：本次应对ATS，兴趣部落App选择接入TBS库，由TBS全局拦截HTTP请求，改为套接字的方式收发请求后返回给上层。`\n\n## 问题背景\n\n\n  ATS(App Transport Security),是苹果在ＷＷＤＣ 15提出的，Apple 在推进网络通讯安全的一个重要方式，按照苹果的要求非https的网络访问是被禁止的；当然现阶段我们可以通过在info.plist里面中添加 NSAppTransportSecurity 字典并且将 NSAllowsArbitraryLoads 设置为YES 来禁用 ATS。\n\n  不过在WWDC 16中，Apple明确表示将收紧http的访问，从2017年1月1日起，所有提交的app默认不允许使用NSAllowsArbitraryLoads 来绕过ATS的限制，这样对于浏览器、手Q、空间等需要访问大量第三方http站点的应用来说，提前解决ATS的问题就迫在眉睫。\n\n这一大推总结起来就是：app内不能再使用HTTP请求，否则有被下架的风险\n## 有哪些解决办法？\n* `替换app内所有http链接`，包涵所有app使用的链接和协议中下发的链接，并且要推动存储后台支持https协议－－－－－工作量较大，对存储后台有强依赖。\n\n* `实现注册NSURLProtocol子类`，用代码实现拦截http请求，代码中自行请求数据，用套接字代替http请求－－－－－工作量巨大，安全性能无法预测。\n\n* `使用TBS全局拦截http请求`，由TBS使用套接字请求数据后返回，上层完全无感知，手q等多款app已经接入，稳定至今－－－－－工作量小，无外部依赖，安装包增量23k左右，性能安全均优。\n\n答案很明显：使用方案3，引入TBS\n\n##对TBS的了解与考量\n\n* `能否解决HTTP协议的限制`\n\n      iOS– TBS通过接管webview的网络层请求，将请求通过SPDY协议发送到浏览器的后台代理服务器；后台代理服务器再通过骨干网络去对方服务器抓取数据；\n\n    TBS的架构图如下：\n![](http://km.oa.com/files/photos/pictures/201704/1492570441_6_w1560_h1066.png)\n\n\n   浏览器使用的SPDY协议是基于底层socket自己实现的网络通信组件，没有使用任何Apple提供的网络组件，并且也不是http协议，所以能够完美解决ATS防止http的问题，并且SPDY协议本身是二进制协议，安全性强于HTTP；\n\n* `安全性`\n    * 解决运营商http网页劫持；TBS和浏览器后台代理之间是SPDY协议通道，运营商劫持代价很高，所以不会劫持；后台的代理服务器和网站的server之间是通过骨干网络访问也避免了运营商劫持；\n    * 解决httpDNS的劫持；TBS和浏览器后台代理通过IP连接，HTTP请求到了后台的代理服务器才进行DNS解析，不给运营商DNS劫持机会；\n    * spdy协议本身是支持加密的；相对http来说，安全性也是可以得到保障的；\n\n* `速度`\n    * 通过TBS和浏览器后台的长链接减少延时；\n    * HTTP Header也压缩减少数据传输；\n    * 并发网络请求提高效率；\n    * 指定请求优先级加快网页展示；\n    * 后台还做了就快接入、图片压缩、资源缓存、广告过滤；\n    * spdy代理加速能力，在3G网络下网页访问速度有效提升 20% 到 30%；\n\n* `安装包增量`\n      安装包增量23k\n\n* `性能`\n      未发现性能问题\n    \n* `有哪些已经接入`\n      现在已有手Ｑ、京东、微云、空间、now直播等APP接入了TBS\n\n小结：经各方面考虑，目前接入TBS在解决ATS问题上是最优选择。\n\n## 接入\n\n* SDK加入工程（SDK地址<http://git.code.oa.com/QQBrowser_iOS/iOS_TBS_SDK>）\n* 添加所需要的依赖\n    * libz.tbd\n    * libstdc++.tbd\n    * WebKit.framework\n* 实现QBProtocolWorker子类，实现`qbProxyProtocolCanInitWithRequest:isQBWebViewRequest:`函数，返回`YES`代表需要用SPDY协议代替当前的请求，反之返回`NO`。\n\n    ```objectivec\n    @implementation TBHttpProtocolWorker\n    \n    + (BOOL) qbProxyProtocolCanInitWithRequest:(NSURLRequest *)request isQBWebViewRequest:(BOOL)isQBWebViewRequest\n    {\n        if (isQBWebViewRequest) {\n            return YES;\n        }\n        \n        NSString* strUrl = [request.URL absoluteString];\n        if ([[TBATSUtil sharedInstance] isATSActive] && [strUrl hasPrefix:@\"http://\"]) {\n            return YES;\n        }\n        \n        return NO;\n    }\n    \n    @end\n    ```\n* 在app启动后注册我们的子类，开始监听http请求\n\n    ```objectivec\n    - (void)startTBSService\n    {\n        if (_isInit == NO && [self isATSActive])\n        {\n            [QBWebViewHelper startProxyWithWorker:[TBHttpProtocolWorker class]];\n            _isInit = YES;\n        }\n    }\n    ```\n接入到此完成\n\n##使用抓包工具验证\n\n* 接入前\n\n   ![](http://km.oa.com/files/photos/pictures/201704/1492570498_68_w682_h1248.png)\n\n* 接入后\n   ![](http://km.oa.com/files/photos/pictures/201704/1492570514_71_w680_h1236.png)\n\n小结：绕过http请求，效果明显\n\n(完)\n","source":"_posts/App应对ATS限制策略.md","raw":"---\ntitle: App应对ATS限制策略\ndate: 2020-09-21 00:40:02\ntags:\n---\n\n\n\n\n`结果先行：本次应对ATS，兴趣部落App选择接入TBS库，由TBS全局拦截HTTP请求，改为套接字的方式收发请求后返回给上层。`\n\n## 问题背景\n\n\n  ATS(App Transport Security),是苹果在ＷＷＤＣ 15提出的，Apple 在推进网络通讯安全的一个重要方式，按照苹果的要求非https的网络访问是被禁止的；当然现阶段我们可以通过在info.plist里面中添加 NSAppTransportSecurity 字典并且将 NSAllowsArbitraryLoads 设置为YES 来禁用 ATS。\n\n  不过在WWDC 16中，Apple明确表示将收紧http的访问，从2017年1月1日起，所有提交的app默认不允许使用NSAllowsArbitraryLoads 来绕过ATS的限制，这样对于浏览器、手Q、空间等需要访问大量第三方http站点的应用来说，提前解决ATS的问题就迫在眉睫。\n\n这一大推总结起来就是：app内不能再使用HTTP请求，否则有被下架的风险\n## 有哪些解决办法？\n* `替换app内所有http链接`，包涵所有app使用的链接和协议中下发的链接，并且要推动存储后台支持https协议－－－－－工作量较大，对存储后台有强依赖。\n\n* `实现注册NSURLProtocol子类`，用代码实现拦截http请求，代码中自行请求数据，用套接字代替http请求－－－－－工作量巨大，安全性能无法预测。\n\n* `使用TBS全局拦截http请求`，由TBS使用套接字请求数据后返回，上层完全无感知，手q等多款app已经接入，稳定至今－－－－－工作量小，无外部依赖，安装包增量23k左右，性能安全均优。\n\n答案很明显：使用方案3，引入TBS\n\n##对TBS的了解与考量\n\n* `能否解决HTTP协议的限制`\n\n      iOS– TBS通过接管webview的网络层请求，将请求通过SPDY协议发送到浏览器的后台代理服务器；后台代理服务器再通过骨干网络去对方服务器抓取数据；\n\n    TBS的架构图如下：\n![](http://km.oa.com/files/photos/pictures/201704/1492570441_6_w1560_h1066.png)\n\n\n   浏览器使用的SPDY协议是基于底层socket自己实现的网络通信组件，没有使用任何Apple提供的网络组件，并且也不是http协议，所以能够完美解决ATS防止http的问题，并且SPDY协议本身是二进制协议，安全性强于HTTP；\n\n* `安全性`\n    * 解决运营商http网页劫持；TBS和浏览器后台代理之间是SPDY协议通道，运营商劫持代价很高，所以不会劫持；后台的代理服务器和网站的server之间是通过骨干网络访问也避免了运营商劫持；\n    * 解决httpDNS的劫持；TBS和浏览器后台代理通过IP连接，HTTP请求到了后台的代理服务器才进行DNS解析，不给运营商DNS劫持机会；\n    * spdy协议本身是支持加密的；相对http来说，安全性也是可以得到保障的；\n\n* `速度`\n    * 通过TBS和浏览器后台的长链接减少延时；\n    * HTTP Header也压缩减少数据传输；\n    * 并发网络请求提高效率；\n    * 指定请求优先级加快网页展示；\n    * 后台还做了就快接入、图片压缩、资源缓存、广告过滤；\n    * spdy代理加速能力，在3G网络下网页访问速度有效提升 20% 到 30%；\n\n* `安装包增量`\n      安装包增量23k\n\n* `性能`\n      未发现性能问题\n    \n* `有哪些已经接入`\n      现在已有手Ｑ、京东、微云、空间、now直播等APP接入了TBS\n\n小结：经各方面考虑，目前接入TBS在解决ATS问题上是最优选择。\n\n## 接入\n\n* SDK加入工程（SDK地址<http://git.code.oa.com/QQBrowser_iOS/iOS_TBS_SDK>）\n* 添加所需要的依赖\n    * libz.tbd\n    * libstdc++.tbd\n    * WebKit.framework\n* 实现QBProtocolWorker子类，实现`qbProxyProtocolCanInitWithRequest:isQBWebViewRequest:`函数，返回`YES`代表需要用SPDY协议代替当前的请求，反之返回`NO`。\n\n    ```objectivec\n    @implementation TBHttpProtocolWorker\n    \n    + (BOOL) qbProxyProtocolCanInitWithRequest:(NSURLRequest *)request isQBWebViewRequest:(BOOL)isQBWebViewRequest\n    {\n        if (isQBWebViewRequest) {\n            return YES;\n        }\n        \n        NSString* strUrl = [request.URL absoluteString];\n        if ([[TBATSUtil sharedInstance] isATSActive] && [strUrl hasPrefix:@\"http://\"]) {\n            return YES;\n        }\n        \n        return NO;\n    }\n    \n    @end\n    ```\n* 在app启动后注册我们的子类，开始监听http请求\n\n    ```objectivec\n    - (void)startTBSService\n    {\n        if (_isInit == NO && [self isATSActive])\n        {\n            [QBWebViewHelper startProxyWithWorker:[TBHttpProtocolWorker class]];\n            _isInit = YES;\n        }\n    }\n    ```\n接入到此完成\n\n##使用抓包工具验证\n\n* 接入前\n\n   ![](http://km.oa.com/files/photos/pictures/201704/1492570498_68_w682_h1248.png)\n\n* 接入后\n   ![](http://km.oa.com/files/photos/pictures/201704/1492570514_71_w680_h1236.png)\n\n小结：绕过http请求，效果明显\n\n(完)\n","slug":"App应对ATS限制策略","published":1,"updated":"2020-09-22T08:32:35.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgyxlisn00020iu63o4mcaap","content":"<p><code>结果先行：本次应对ATS，兴趣部落App选择接入TBS库，由TBS全局拦截HTTP请求，改为套接字的方式收发请求后返回给上层。</code></p>\n<h2 id=\"问题背景\"><a href=\"#问题背景\" class=\"headerlink\" title=\"问题背景\"></a>问题背景</h2><p>  ATS(App Transport Security),是苹果在ＷＷＤＣ 15提出的，Apple 在推进网络通讯安全的一个重要方式，按照苹果的要求非https的网络访问是被禁止的；当然现阶段我们可以通过在info.plist里面中添加 NSAppTransportSecurity 字典并且将 NSAllowsArbitraryLoads 设置为YES 来禁用 ATS。</p>\n<p>  不过在WWDC 16中，Apple明确表示将收紧http的访问，从2017年1月1日起，所有提交的app默认不允许使用NSAllowsArbitraryLoads 来绕过ATS的限制，这样对于浏览器、手Q、空间等需要访问大量第三方http站点的应用来说，提前解决ATS的问题就迫在眉睫。</p>\n<p>这一大推总结起来就是：app内不能再使用HTTP请求，否则有被下架的风险</p>\n<h2 id=\"有哪些解决办法？\"><a href=\"#有哪些解决办法？\" class=\"headerlink\" title=\"有哪些解决办法？\"></a>有哪些解决办法？</h2><ul>\n<li><p><code>替换app内所有http链接</code>，包涵所有app使用的链接和协议中下发的链接，并且要推动存储后台支持https协议－－－－－工作量较大，对存储后台有强依赖。</p>\n</li>\n<li><p><code>实现注册NSURLProtocol子类</code>，用代码实现拦截http请求，代码中自行请求数据，用套接字代替http请求－－－－－工作量巨大，安全性能无法预测。</p>\n</li>\n<li><p><code>使用TBS全局拦截http请求</code>，由TBS使用套接字请求数据后返回，上层完全无感知，手q等多款app已经接入，稳定至今－－－－－工作量小，无外部依赖，安装包增量23k左右，性能安全均优。</p>\n</li>\n</ul>\n<p>答案很明显：使用方案3，引入TBS</p>\n<p>##对TBS的了解与考量</p>\n<ul>\n<li><p><code>能否解决HTTP协议的限制</code></p>\n<p>    iOS– TBS通过接管webview的网络层请求，将请求通过SPDY协议发送到浏览器的后台代理服务器；后台代理服务器再通过骨干网络去对方服务器抓取数据；</p>\n<p>  TBS的架构图如下：<br><img src=\"http://km.oa.com/files/photos/pictures/201704/1492570441_6_w1560_h1066.png\" alt=\"\"></p>\n</li>\n</ul>\n<p>   浏览器使用的SPDY协议是基于底层socket自己实现的网络通信组件，没有使用任何Apple提供的网络组件，并且也不是http协议，所以能够完美解决ATS防止http的问题，并且SPDY协议本身是二进制协议，安全性强于HTTP；</p>\n<ul>\n<li><p><code>安全性</code></p>\n<ul>\n<li>解决运营商http网页劫持；TBS和浏览器后台代理之间是SPDY协议通道，运营商劫持代价很高，所以不会劫持；后台的代理服务器和网站的server之间是通过骨干网络访问也避免了运营商劫持；</li>\n<li>解决httpDNS的劫持；TBS和浏览器后台代理通过IP连接，HTTP请求到了后台的代理服务器才进行DNS解析，不给运营商DNS劫持机会；</li>\n<li>spdy协议本身是支持加密的；相对http来说，安全性也是可以得到保障的；</li>\n</ul>\n</li>\n<li><p><code>速度</code></p>\n<ul>\n<li>通过TBS和浏览器后台的长链接减少延时；</li>\n<li>HTTP Header也压缩减少数据传输；</li>\n<li>并发网络请求提高效率；</li>\n<li>指定请求优先级加快网页展示；</li>\n<li>后台还做了就快接入、图片压缩、资源缓存、广告过滤；</li>\n<li>spdy代理加速能力，在3G网络下网页访问速度有效提升 20% 到 30%；</li>\n</ul>\n</li>\n<li><p><code>安装包增量</code><br>    安装包增量23k</p>\n</li>\n<li><p><code>性能</code><br>    未发现性能问题</p>\n</li>\n<li><p><code>有哪些已经接入</code><br>    现在已有手Ｑ、京东、微云、空间、now直播等APP接入了TBS</p>\n</li>\n</ul>\n<p>小结：经各方面考虑，目前接入TBS在解决ATS问题上是最优选择。</p>\n<h2 id=\"接入\"><a href=\"#接入\" class=\"headerlink\" title=\"接入\"></a>接入</h2><ul>\n<li><p>SDK加入工程（SDK地址<a href=\"http://git.code.oa.com/QQBrowser_iOS/iOS_TBS_SDK\" target=\"_blank\" rel=\"noopener\">http://git.code.oa.com/QQBrowser_iOS/iOS_TBS_SDK</a>）</p>\n</li>\n<li><p>添加所需要的依赖</p>\n<ul>\n<li>libz.tbd</li>\n<li>libstdc++.tbd</li>\n<li>WebKit.framework</li>\n</ul>\n</li>\n<li><p>实现QBProtocolWorker子类，实现<code>qbProxyProtocolCanInitWithRequest:isQBWebViewRequest:</code>函数，返回<code>YES</code>代表需要用SPDY协议代替当前的请求，反之返回<code>NO</code>。</p>\n<pre><code class=\"objectivec\">  @implementation TBHttpProtocolWorker\n\n  + (BOOL) qbProxyProtocolCanInitWithRequest:(NSURLRequest *)request isQBWebViewRequest:(BOOL)isQBWebViewRequest\n  {\n      if (isQBWebViewRequest) {\n          return YES;\n      }\n\n      NSString* strUrl = [request.URL absoluteString];\n      if ([[TBATSUtil sharedInstance] isATSActive] &amp;&amp; [strUrl hasPrefix:@&quot;http://&quot;]) {\n          return YES;\n      }\n\n      return NO;\n  }\n\n  @end</code></pre>\n</li>\n<li><p>在app启动后注册我们的子类，开始监听http请求</p>\n<pre><code class=\"objectivec\">  - (void)startTBSService\n  {\n      if (_isInit == NO &amp;&amp; [self isATSActive])\n      {\n          [QBWebViewHelper startProxyWithWorker:[TBHttpProtocolWorker class]];\n          _isInit = YES;\n      }\n  }</code></pre>\n<p>接入到此完成</p>\n</li>\n</ul>\n<p>##使用抓包工具验证</p>\n<ul>\n<li><p>接入前</p>\n<p> <img src=\"http://km.oa.com/files/photos/pictures/201704/1492570498_68_w682_h1248.png\" alt=\"\"></p>\n</li>\n<li><p>接入后<br> <img src=\"http://km.oa.com/files/photos/pictures/201704/1492570514_71_w680_h1236.png\" alt=\"\"></p>\n</li>\n</ul>\n<p>小结：绕过http请求，效果明显</p>\n<p>(完)</p>\n","site":{"data":{}},"excerpt":"","more":"<p><code>结果先行：本次应对ATS，兴趣部落App选择接入TBS库，由TBS全局拦截HTTP请求，改为套接字的方式收发请求后返回给上层。</code></p>\n<h2 id=\"问题背景\"><a href=\"#问题背景\" class=\"headerlink\" title=\"问题背景\"></a>问题背景</h2><p>  ATS(App Transport Security),是苹果在ＷＷＤＣ 15提出的，Apple 在推进网络通讯安全的一个重要方式，按照苹果的要求非https的网络访问是被禁止的；当然现阶段我们可以通过在info.plist里面中添加 NSAppTransportSecurity 字典并且将 NSAllowsArbitraryLoads 设置为YES 来禁用 ATS。</p>\n<p>  不过在WWDC 16中，Apple明确表示将收紧http的访问，从2017年1月1日起，所有提交的app默认不允许使用NSAllowsArbitraryLoads 来绕过ATS的限制，这样对于浏览器、手Q、空间等需要访问大量第三方http站点的应用来说，提前解决ATS的问题就迫在眉睫。</p>\n<p>这一大推总结起来就是：app内不能再使用HTTP请求，否则有被下架的风险</p>\n<h2 id=\"有哪些解决办法？\"><a href=\"#有哪些解决办法？\" class=\"headerlink\" title=\"有哪些解决办法？\"></a>有哪些解决办法？</h2><ul>\n<li><p><code>替换app内所有http链接</code>，包涵所有app使用的链接和协议中下发的链接，并且要推动存储后台支持https协议－－－－－工作量较大，对存储后台有强依赖。</p>\n</li>\n<li><p><code>实现注册NSURLProtocol子类</code>，用代码实现拦截http请求，代码中自行请求数据，用套接字代替http请求－－－－－工作量巨大，安全性能无法预测。</p>\n</li>\n<li><p><code>使用TBS全局拦截http请求</code>，由TBS使用套接字请求数据后返回，上层完全无感知，手q等多款app已经接入，稳定至今－－－－－工作量小，无外部依赖，安装包增量23k左右，性能安全均优。</p>\n</li>\n</ul>\n<p>答案很明显：使用方案3，引入TBS</p>\n<p>##对TBS的了解与考量</p>\n<ul>\n<li><p><code>能否解决HTTP协议的限制</code></p>\n<p>    iOS– TBS通过接管webview的网络层请求，将请求通过SPDY协议发送到浏览器的后台代理服务器；后台代理服务器再通过骨干网络去对方服务器抓取数据；</p>\n<p>  TBS的架构图如下：<br><img src=\"http://km.oa.com/files/photos/pictures/201704/1492570441_6_w1560_h1066.png\" alt=\"\"></p>\n</li>\n</ul>\n<p>   浏览器使用的SPDY协议是基于底层socket自己实现的网络通信组件，没有使用任何Apple提供的网络组件，并且也不是http协议，所以能够完美解决ATS防止http的问题，并且SPDY协议本身是二进制协议，安全性强于HTTP；</p>\n<ul>\n<li><p><code>安全性</code></p>\n<ul>\n<li>解决运营商http网页劫持；TBS和浏览器后台代理之间是SPDY协议通道，运营商劫持代价很高，所以不会劫持；后台的代理服务器和网站的server之间是通过骨干网络访问也避免了运营商劫持；</li>\n<li>解决httpDNS的劫持；TBS和浏览器后台代理通过IP连接，HTTP请求到了后台的代理服务器才进行DNS解析，不给运营商DNS劫持机会；</li>\n<li>spdy协议本身是支持加密的；相对http来说，安全性也是可以得到保障的；</li>\n</ul>\n</li>\n<li><p><code>速度</code></p>\n<ul>\n<li>通过TBS和浏览器后台的长链接减少延时；</li>\n<li>HTTP Header也压缩减少数据传输；</li>\n<li>并发网络请求提高效率；</li>\n<li>指定请求优先级加快网页展示；</li>\n<li>后台还做了就快接入、图片压缩、资源缓存、广告过滤；</li>\n<li>spdy代理加速能力，在3G网络下网页访问速度有效提升 20% 到 30%；</li>\n</ul>\n</li>\n<li><p><code>安装包增量</code><br>    安装包增量23k</p>\n</li>\n<li><p><code>性能</code><br>    未发现性能问题</p>\n</li>\n<li><p><code>有哪些已经接入</code><br>    现在已有手Ｑ、京东、微云、空间、now直播等APP接入了TBS</p>\n</li>\n</ul>\n<p>小结：经各方面考虑，目前接入TBS在解决ATS问题上是最优选择。</p>\n<h2 id=\"接入\"><a href=\"#接入\" class=\"headerlink\" title=\"接入\"></a>接入</h2><ul>\n<li><p>SDK加入工程（SDK地址<a href=\"http://git.code.oa.com/QQBrowser_iOS/iOS_TBS_SDK\" target=\"_blank\" rel=\"noopener\">http://git.code.oa.com/QQBrowser_iOS/iOS_TBS_SDK</a>）</p>\n</li>\n<li><p>添加所需要的依赖</p>\n<ul>\n<li>libz.tbd</li>\n<li>libstdc++.tbd</li>\n<li>WebKit.framework</li>\n</ul>\n</li>\n<li><p>实现QBProtocolWorker子类，实现<code>qbProxyProtocolCanInitWithRequest:isQBWebViewRequest:</code>函数，返回<code>YES</code>代表需要用SPDY协议代替当前的请求，反之返回<code>NO</code>。</p>\n<pre><code class=\"objectivec\">  @implementation TBHttpProtocolWorker\n\n  + (BOOL) qbProxyProtocolCanInitWithRequest:(NSURLRequest *)request isQBWebViewRequest:(BOOL)isQBWebViewRequest\n  {\n      if (isQBWebViewRequest) {\n          return YES;\n      }\n\n      NSString* strUrl = [request.URL absoluteString];\n      if ([[TBATSUtil sharedInstance] isATSActive] &amp;&amp; [strUrl hasPrefix:@&quot;http://&quot;]) {\n          return YES;\n      }\n\n      return NO;\n  }\n\n  @end</code></pre>\n</li>\n<li><p>在app启动后注册我们的子类，开始监听http请求</p>\n<pre><code class=\"objectivec\">  - (void)startTBSService\n  {\n      if (_isInit == NO &amp;&amp; [self isATSActive])\n      {\n          [QBWebViewHelper startProxyWithWorker:[TBHttpProtocolWorker class]];\n          _isInit = YES;\n      }\n  }</code></pre>\n<p>接入到此完成</p>\n</li>\n</ul>\n<p>##使用抓包工具验证</p>\n<ul>\n<li><p>接入前</p>\n<p> <img src=\"http://km.oa.com/files/photos/pictures/201704/1492570498_68_w682_h1248.png\" alt=\"\"></p>\n</li>\n<li><p>接入后<br> <img src=\"http://km.oa.com/files/photos/pictures/201704/1492570514_71_w680_h1236.png\" alt=\"\"></p>\n</li>\n</ul>\n<p>小结：绕过http请求，效果明显</p>\n<p>(完)</p>\n"},{"title":"Mac清除开机密码限制","date":"2020-06-22T15:30:30.000Z","_content":"\n## 背景\n\n公司限制了开机密码的复杂度，要求：\n* 包含大小写字母\n* 包含数字\n* 包含特殊字符\n* 4位或以上\n\n每隔几个月就要重新设置密码，传统的目标类密码命名已经不想再用了，复杂的开机密码让我的开机体验变得疲惫，刚开机就疲惫的想关机 ：（\n\n那么，干！掉！它！\n\n## 具体步骤\n\n* 打开终端输入：\n\n    ```\n    pwpolicy -clearaccountpolicies \n    ```\n    \n* 此时会提示输入旧密码，验证身份，看到如图结果，这时限制已经清除\n![](https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2020/06/22/15928402469460.jpg)\n\n* 进入偏好设置重设密码，随便设，没限制\n\n\n（完）","source":"_posts/Mac清除开机密码限制.md","raw":"---\ntitle: Mac清除开机密码限制\ndate: 2020-06-22 23:30:30\ntags:\n---\n\n## 背景\n\n公司限制了开机密码的复杂度，要求：\n* 包含大小写字母\n* 包含数字\n* 包含特殊字符\n* 4位或以上\n\n每隔几个月就要重新设置密码，传统的目标类密码命名已经不想再用了，复杂的开机密码让我的开机体验变得疲惫，刚开机就疲惫的想关机 ：（\n\n那么，干！掉！它！\n\n## 具体步骤\n\n* 打开终端输入：\n\n    ```\n    pwpolicy -clearaccountpolicies \n    ```\n    \n* 此时会提示输入旧密码，验证身份，看到如图结果，这时限制已经清除\n![](https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2020/06/22/15928402469460.jpg)\n\n* 进入偏好设置重设密码，随便设，没限制\n\n\n（完）","slug":"Mac清除开机密码限制","published":1,"updated":"2020-06-22T15:39:27.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgyxliso00030iu6c4dhfrvc","content":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>公司限制了开机密码的复杂度，要求：</p>\n<ul>\n<li>包含大小写字母</li>\n<li>包含数字</li>\n<li>包含特殊字符</li>\n<li>4位或以上</li>\n</ul>\n<p>每隔几个月就要重新设置密码，传统的目标类密码命名已经不想再用了，复杂的开机密码让我的开机体验变得疲惫，刚开机就疲惫的想关机 ：（</p>\n<p>那么，干！掉！它！</p>\n<h2 id=\"具体步骤\"><a href=\"#具体步骤\" class=\"headerlink\" title=\"具体步骤\"></a>具体步骤</h2><ul>\n<li><p>打开终端输入：</p>\n<pre><code>  pwpolicy -clearaccountpolicies </code></pre></li>\n<li><p>此时会提示输入旧密码，验证身份，看到如图结果，这时限制已经清除<br><img src=\"https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2020/06/22/15928402469460.jpg\" alt=\"\"></p>\n</li>\n<li><p>进入偏好设置重设密码，随便设，没限制</p>\n</li>\n</ul>\n<p>（完）</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>公司限制了开机密码的复杂度，要求：</p>\n<ul>\n<li>包含大小写字母</li>\n<li>包含数字</li>\n<li>包含特殊字符</li>\n<li>4位或以上</li>\n</ul>\n<p>每隔几个月就要重新设置密码，传统的目标类密码命名已经不想再用了，复杂的开机密码让我的开机体验变得疲惫，刚开机就疲惫的想关机 ：（</p>\n<p>那么，干！掉！它！</p>\n<h2 id=\"具体步骤\"><a href=\"#具体步骤\" class=\"headerlink\" title=\"具体步骤\"></a>具体步骤</h2><ul>\n<li><p>打开终端输入：</p>\n<pre><code>  pwpolicy -clearaccountpolicies </code></pre></li>\n<li><p>此时会提示输入旧密码，验证身份，看到如图结果，这时限制已经清除<br><img src=\"https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2020/06/22/15928402469460.jpg\" alt=\"\"></p>\n</li>\n<li><p>进入偏好设置重设密码，随便设，没限制</p>\n</li>\n</ul>\n<p>（完）</p>\n"},{"title":"Dart 背景调查","date":"2020-06-28T17:53:54.000Z","_content":"\n# Dart出世\n\n2011年10月10日，星期一，Goolgle发布了一篇名为《Dart: A language for structured web programming》（Dart：结构化的Web编程语言）的文章，公布Dart语言的出生。\n\n# 设计初衷\n\n摘一段原文：\n> Dart’s design goals are:\n> * Create a structured yet flexible language for web programming.\n> \n> * Make Dart feel familiar and natural to programmers and thus easy to learn.\n> \n> * Ensure that Dart delivers high performance on all modern web browsers and environments ranging from small handheld devices to server-side execution.\n\nDart的设计目标是：\n* 创建用于Web编程的灵活结构化语言。\n* 在使用Dart的时候，让开发者感到熟悉和顺手，从而易于学习。\n* 确保Dart在所有移动设备、所有Web浏览器 以及服务器上提供高性能的服务。\n\n看的出来, Dart的设计就是冲着多平台统一语言来的，在ios、安卓、web页面、后台的开发上都有做不错的支持，尤其是客户端的开发，原来两份代码的工作，Dart可以用一份代码搞定，开发成本大大节省。\n\n# 低谷\n\nDart如今虽然风光无限，但在其实直到2018年Dart还是\"最啃爹语言榜首\"，而且就业机会极少，为什么？因为没有可心竞争力。\n\n![](https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2020/06/29/15933679225129.jpg)\n\n![](https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2020/06/29/15933681049121.jpg)\n\n\n# 新的纪元\n\n2018年12月4日，谷歌发布Flutter 1.0版本，其标题为《Flutter 1.0: Google’s Portable UI Toolkit》（Flutter 1.0:谷歌的可移植UI工具箱），Flutter从此问世。\n\nFlutter的出现掀起来一波移动开发的热潮。使用它可以直接开发Android和iOS应用。其最大的特点就是一套代码多平台运行、高性能和Hot Reload（热重载）。谷歌即将发布Fuchsia系统就以Flutter为主要开发框架。Flutter采用Dart作为其底层语言。Dart也由于Flutter美好未来而得到众多开发者的青睐，从低谷一跃成为了2019年GIT上项目增长最多的语言。\n\n并且Flutter和Dart都是开源项目，这为深入理解和调试敞开了大门。\n\n![](https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2020/06/29/15933688221710.jpg)\n\n# 教程\n\n* Dart教程：\n\n    * Dart语法教程：https://www.dartcn.com/guides/language/language-tour\n    * 视频教程：https://www.youtube.com/watch?v=Ej_Pcr4uC2Q&t=1084s\n    * 官方文档：https://dart.dev/guides\n    * 静态检查工具：https://dart.dev/guides/language/analysis-options\n    * 《Effective Dart》 https://dart.cn/guides/language/effective-dart\n    * 《Linter for Dart》https://dart-lang.github.io/linter/lints/index.html\n    * 《Dart Style Guide》http://dartdoc.takyam.com/articles/style-guide/\n\n* Flutter教程\n\n    https://www.youtube.com/watch?v=x0uinJvhNxI\n\n# 最后\n\nDart的出世无疑是在全栈的高墙上搭了一把梯子，以后安卓 ios web 后台，4端的工作，只需要一个人就能完成了、，这可能会带来两个结果：1. 公司产能暴涨，有精力发展更多的产品。2. 公司的产能过剩，开发人力供大于求，裁员减招。希望我们都不会面临第二种情况。\n\n","source":"_posts/Dart背景调查.md","raw":"---\ntitle: Dart 背景调查\ndate: 2020-06-29 01:53:54\ntags:\n---\n\n# Dart出世\n\n2011年10月10日，星期一，Goolgle发布了一篇名为《Dart: A language for structured web programming》（Dart：结构化的Web编程语言）的文章，公布Dart语言的出生。\n\n# 设计初衷\n\n摘一段原文：\n> Dart’s design goals are:\n> * Create a structured yet flexible language for web programming.\n> \n> * Make Dart feel familiar and natural to programmers and thus easy to learn.\n> \n> * Ensure that Dart delivers high performance on all modern web browsers and environments ranging from small handheld devices to server-side execution.\n\nDart的设计目标是：\n* 创建用于Web编程的灵活结构化语言。\n* 在使用Dart的时候，让开发者感到熟悉和顺手，从而易于学习。\n* 确保Dart在所有移动设备、所有Web浏览器 以及服务器上提供高性能的服务。\n\n看的出来, Dart的设计就是冲着多平台统一语言来的，在ios、安卓、web页面、后台的开发上都有做不错的支持，尤其是客户端的开发，原来两份代码的工作，Dart可以用一份代码搞定，开发成本大大节省。\n\n# 低谷\n\nDart如今虽然风光无限，但在其实直到2018年Dart还是\"最啃爹语言榜首\"，而且就业机会极少，为什么？因为没有可心竞争力。\n\n![](https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2020/06/29/15933679225129.jpg)\n\n![](https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2020/06/29/15933681049121.jpg)\n\n\n# 新的纪元\n\n2018年12月4日，谷歌发布Flutter 1.0版本，其标题为《Flutter 1.0: Google’s Portable UI Toolkit》（Flutter 1.0:谷歌的可移植UI工具箱），Flutter从此问世。\n\nFlutter的出现掀起来一波移动开发的热潮。使用它可以直接开发Android和iOS应用。其最大的特点就是一套代码多平台运行、高性能和Hot Reload（热重载）。谷歌即将发布Fuchsia系统就以Flutter为主要开发框架。Flutter采用Dart作为其底层语言。Dart也由于Flutter美好未来而得到众多开发者的青睐，从低谷一跃成为了2019年GIT上项目增长最多的语言。\n\n并且Flutter和Dart都是开源项目，这为深入理解和调试敞开了大门。\n\n![](https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2020/06/29/15933688221710.jpg)\n\n# 教程\n\n* Dart教程：\n\n    * Dart语法教程：https://www.dartcn.com/guides/language/language-tour\n    * 视频教程：https://www.youtube.com/watch?v=Ej_Pcr4uC2Q&t=1084s\n    * 官方文档：https://dart.dev/guides\n    * 静态检查工具：https://dart.dev/guides/language/analysis-options\n    * 《Effective Dart》 https://dart.cn/guides/language/effective-dart\n    * 《Linter for Dart》https://dart-lang.github.io/linter/lints/index.html\n    * 《Dart Style Guide》http://dartdoc.takyam.com/articles/style-guide/\n\n* Flutter教程\n\n    https://www.youtube.com/watch?v=x0uinJvhNxI\n\n# 最后\n\nDart的出世无疑是在全栈的高墙上搭了一把梯子，以后安卓 ios web 后台，4端的工作，只需要一个人就能完成了、，这可能会带来两个结果：1. 公司产能暴涨，有精力发展更多的产品。2. 公司的产能过剩，开发人力供大于求，裁员减招。希望我们都不会面临第二种情况。\n\n","slug":"Dart背景调查","published":1,"updated":"2020-07-05T10:16:14.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgyxliso00040iu61uv47dst","content":"<h1 id=\"Dart出世\"><a href=\"#Dart出世\" class=\"headerlink\" title=\"Dart出世\"></a>Dart出世</h1><p>2011年10月10日，星期一，Goolgle发布了一篇名为《Dart: A language for structured web programming》（Dart：结构化的Web编程语言）的文章，公布Dart语言的出生。</p>\n<h1 id=\"设计初衷\"><a href=\"#设计初衷\" class=\"headerlink\" title=\"设计初衷\"></a>设计初衷</h1><p>摘一段原文：</p>\n<blockquote>\n<p>Dart’s design goals are:</p>\n<ul>\n<li><p>Create a structured yet flexible language for web programming.</p>\n</li>\n<li><p>Make Dart feel familiar and natural to programmers and thus easy to learn.</p>\n</li>\n<li><p>Ensure that Dart delivers high performance on all modern web browsers and environments ranging from small handheld devices to server-side execution.</p>\n</li>\n</ul>\n</blockquote>\n<p>Dart的设计目标是：</p>\n<ul>\n<li>创建用于Web编程的灵活结构化语言。</li>\n<li>在使用Dart的时候，让开发者感到熟悉和顺手，从而易于学习。</li>\n<li>确保Dart在所有移动设备、所有Web浏览器 以及服务器上提供高性能的服务。</li>\n</ul>\n<p>看的出来, Dart的设计就是冲着多平台统一语言来的，在ios、安卓、web页面、后台的开发上都有做不错的支持，尤其是客户端的开发，原来两份代码的工作，Dart可以用一份代码搞定，开发成本大大节省。</p>\n<h1 id=\"低谷\"><a href=\"#低谷\" class=\"headerlink\" title=\"低谷\"></a>低谷</h1><p>Dart如今虽然风光无限，但在其实直到2018年Dart还是”最啃爹语言榜首”，而且就业机会极少，为什么？因为没有可心竞争力。</p>\n<p><img src=\"https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2020/06/29/15933679225129.jpg\" alt=\"\"></p>\n<p><img src=\"https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2020/06/29/15933681049121.jpg\" alt=\"\"></p>\n<h1 id=\"新的纪元\"><a href=\"#新的纪元\" class=\"headerlink\" title=\"新的纪元\"></a>新的纪元</h1><p>2018年12月4日，谷歌发布Flutter 1.0版本，其标题为《Flutter 1.0: Google’s Portable UI Toolkit》（Flutter 1.0:谷歌的可移植UI工具箱），Flutter从此问世。</p>\n<p>Flutter的出现掀起来一波移动开发的热潮。使用它可以直接开发Android和iOS应用。其最大的特点就是一套代码多平台运行、高性能和Hot Reload（热重载）。谷歌即将发布Fuchsia系统就以Flutter为主要开发框架。Flutter采用Dart作为其底层语言。Dart也由于Flutter美好未来而得到众多开发者的青睐，从低谷一跃成为了2019年GIT上项目增长最多的语言。</p>\n<p>并且Flutter和Dart都是开源项目，这为深入理解和调试敞开了大门。</p>\n<p><img src=\"https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2020/06/29/15933688221710.jpg\" alt=\"\"></p>\n<h1 id=\"教程\"><a href=\"#教程\" class=\"headerlink\" title=\"教程\"></a>教程</h1><ul>\n<li><p>Dart教程：</p>\n<ul>\n<li>Dart语法教程：<a href=\"https://www.dartcn.com/guides/language/language-tour\" target=\"_blank\" rel=\"noopener\">https://www.dartcn.com/guides/language/language-tour</a></li>\n<li>视频教程：<a href=\"https://www.youtube.com/watch?v=Ej_Pcr4uC2Q&amp;t=1084s\" target=\"_blank\" rel=\"noopener\">https://www.youtube.com/watch?v=Ej_Pcr4uC2Q&amp;t=1084s</a></li>\n<li>官方文档：<a href=\"https://dart.dev/guides\" target=\"_blank\" rel=\"noopener\">https://dart.dev/guides</a></li>\n<li>静态检查工具：<a href=\"https://dart.dev/guides/language/analysis-options\" target=\"_blank\" rel=\"noopener\">https://dart.dev/guides/language/analysis-options</a></li>\n<li>《Effective Dart》 <a href=\"https://dart.cn/guides/language/effective-dart\" target=\"_blank\" rel=\"noopener\">https://dart.cn/guides/language/effective-dart</a></li>\n<li>《Linter for Dart》<a href=\"https://dart-lang.github.io/linter/lints/index.html\" target=\"_blank\" rel=\"noopener\">https://dart-lang.github.io/linter/lints/index.html</a></li>\n<li>《Dart Style Guide》<a href=\"http://dartdoc.takyam.com/articles/style-guide/\" target=\"_blank\" rel=\"noopener\">http://dartdoc.takyam.com/articles/style-guide/</a></li>\n</ul>\n</li>\n<li><p>Flutter教程</p>\n<p>  <a href=\"https://www.youtube.com/watch?v=x0uinJvhNxI\" target=\"_blank\" rel=\"noopener\">https://www.youtube.com/watch?v=x0uinJvhNxI</a></p>\n</li>\n</ul>\n<h1 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h1><p>Dart的出世无疑是在全栈的高墙上搭了一把梯子，以后安卓 ios web 后台，4端的工作，只需要一个人就能完成了、，这可能会带来两个结果：1. 公司产能暴涨，有精力发展更多的产品。2. 公司的产能过剩，开发人力供大于求，裁员减招。希望我们都不会面临第二种情况。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Dart出世\"><a href=\"#Dart出世\" class=\"headerlink\" title=\"Dart出世\"></a>Dart出世</h1><p>2011年10月10日，星期一，Goolgle发布了一篇名为《Dart: A language for structured web programming》（Dart：结构化的Web编程语言）的文章，公布Dart语言的出生。</p>\n<h1 id=\"设计初衷\"><a href=\"#设计初衷\" class=\"headerlink\" title=\"设计初衷\"></a>设计初衷</h1><p>摘一段原文：</p>\n<blockquote>\n<p>Dart’s design goals are:</p>\n<ul>\n<li><p>Create a structured yet flexible language for web programming.</p>\n</li>\n<li><p>Make Dart feel familiar and natural to programmers and thus easy to learn.</p>\n</li>\n<li><p>Ensure that Dart delivers high performance on all modern web browsers and environments ranging from small handheld devices to server-side execution.</p>\n</li>\n</ul>\n</blockquote>\n<p>Dart的设计目标是：</p>\n<ul>\n<li>创建用于Web编程的灵活结构化语言。</li>\n<li>在使用Dart的时候，让开发者感到熟悉和顺手，从而易于学习。</li>\n<li>确保Dart在所有移动设备、所有Web浏览器 以及服务器上提供高性能的服务。</li>\n</ul>\n<p>看的出来, Dart的设计就是冲着多平台统一语言来的，在ios、安卓、web页面、后台的开发上都有做不错的支持，尤其是客户端的开发，原来两份代码的工作，Dart可以用一份代码搞定，开发成本大大节省。</p>\n<h1 id=\"低谷\"><a href=\"#低谷\" class=\"headerlink\" title=\"低谷\"></a>低谷</h1><p>Dart如今虽然风光无限，但在其实直到2018年Dart还是”最啃爹语言榜首”，而且就业机会极少，为什么？因为没有可心竞争力。</p>\n<p><img src=\"https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2020/06/29/15933679225129.jpg\" alt=\"\"></p>\n<p><img src=\"https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2020/06/29/15933681049121.jpg\" alt=\"\"></p>\n<h1 id=\"新的纪元\"><a href=\"#新的纪元\" class=\"headerlink\" title=\"新的纪元\"></a>新的纪元</h1><p>2018年12月4日，谷歌发布Flutter 1.0版本，其标题为《Flutter 1.0: Google’s Portable UI Toolkit》（Flutter 1.0:谷歌的可移植UI工具箱），Flutter从此问世。</p>\n<p>Flutter的出现掀起来一波移动开发的热潮。使用它可以直接开发Android和iOS应用。其最大的特点就是一套代码多平台运行、高性能和Hot Reload（热重载）。谷歌即将发布Fuchsia系统就以Flutter为主要开发框架。Flutter采用Dart作为其底层语言。Dart也由于Flutter美好未来而得到众多开发者的青睐，从低谷一跃成为了2019年GIT上项目增长最多的语言。</p>\n<p>并且Flutter和Dart都是开源项目，这为深入理解和调试敞开了大门。</p>\n<p><img src=\"https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2020/06/29/15933688221710.jpg\" alt=\"\"></p>\n<h1 id=\"教程\"><a href=\"#教程\" class=\"headerlink\" title=\"教程\"></a>教程</h1><ul>\n<li><p>Dart教程：</p>\n<ul>\n<li>Dart语法教程：<a href=\"https://www.dartcn.com/guides/language/language-tour\" target=\"_blank\" rel=\"noopener\">https://www.dartcn.com/guides/language/language-tour</a></li>\n<li>视频教程：<a href=\"https://www.youtube.com/watch?v=Ej_Pcr4uC2Q&amp;t=1084s\" target=\"_blank\" rel=\"noopener\">https://www.youtube.com/watch?v=Ej_Pcr4uC2Q&amp;t=1084s</a></li>\n<li>官方文档：<a href=\"https://dart.dev/guides\" target=\"_blank\" rel=\"noopener\">https://dart.dev/guides</a></li>\n<li>静态检查工具：<a href=\"https://dart.dev/guides/language/analysis-options\" target=\"_blank\" rel=\"noopener\">https://dart.dev/guides/language/analysis-options</a></li>\n<li>《Effective Dart》 <a href=\"https://dart.cn/guides/language/effective-dart\" target=\"_blank\" rel=\"noopener\">https://dart.cn/guides/language/effective-dart</a></li>\n<li>《Linter for Dart》<a href=\"https://dart-lang.github.io/linter/lints/index.html\" target=\"_blank\" rel=\"noopener\">https://dart-lang.github.io/linter/lints/index.html</a></li>\n<li>《Dart Style Guide》<a href=\"http://dartdoc.takyam.com/articles/style-guide/\" target=\"_blank\" rel=\"noopener\">http://dartdoc.takyam.com/articles/style-guide/</a></li>\n</ul>\n</li>\n<li><p>Flutter教程</p>\n<p>  <a href=\"https://www.youtube.com/watch?v=x0uinJvhNxI\" target=\"_blank\" rel=\"noopener\">https://www.youtube.com/watch?v=x0uinJvhNxI</a></p>\n</li>\n</ul>\n<h1 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h1><p>Dart的出世无疑是在全栈的高墙上搭了一把梯子，以后安卓 ios web 后台，4端的工作，只需要一个人就能完成了、，这可能会带来两个结果：1. 公司产能暴涨，有精力发展更多的产品。2. 公司的产能过剩，开发人力供大于求，裁员减招。希望我们都不会面临第二种情况。</p>\n"},{"title":"MarkDown兼容OutLook小记","date":"2020-09-20T16:37:31.000Z","_content":"\n用MarkDown编辑完文字调整完格式, 心情一片大好,打开邮件, 复制黏贴, 发送, 我X, 这图片怎么变得这么大, 在windows的OutLook上查看,格式非常杀马特.\n\n解决办法:\n\n    Step1. MarkDown导出成HTML,从HTML复制内容到邮件.\n\n    Step2. 编辑时把图片挨个重新截图到合适大小,替换邮件中的原图.\n\n\n\n亲测在Mac原声邮箱,Mac OutLook, Windows OutLook上格式完美.\n\n如果有更简单的办法, 请告诉我!\n\n\n\n2020.8.18日更新------------------------------------------------------------------------------------------\n\n感谢penpengguan，发现了新的markdown在线编辑工具https://www.mdnice.com/，直接复制xin'nei\n","source":"_posts/MarkDown兼容OutLook小记.md","raw":"---\ntitle: MarkDown兼容OutLook小记\ndate: 2020-09-21 00:37:31\ntags:\n---\n\n用MarkDown编辑完文字调整完格式, 心情一片大好,打开邮件, 复制黏贴, 发送, 我X, 这图片怎么变得这么大, 在windows的OutLook上查看,格式非常杀马特.\n\n解决办法:\n\n    Step1. MarkDown导出成HTML,从HTML复制内容到邮件.\n\n    Step2. 编辑时把图片挨个重新截图到合适大小,替换邮件中的原图.\n\n\n\n亲测在Mac原声邮箱,Mac OutLook, Windows OutLook上格式完美.\n\n如果有更简单的办法, 请告诉我!\n\n\n\n2020.8.18日更新------------------------------------------------------------------------------------------\n\n感谢penpengguan，发现了新的markdown在线编辑工具https://www.mdnice.com/，直接复制xin'nei\n","slug":"MarkDown兼容OutLook小记","published":1,"updated":"2020-09-20T16:37:55.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgyxlisp00050iu6agzsfdlz","content":"<p>用MarkDown编辑完文字调整完格式, 心情一片大好,打开邮件, 复制黏贴, 发送, 我X, 这图片怎么变得这么大, 在windows的OutLook上查看,格式非常杀马特.</p>\n<p>解决办法:</p>\n<pre><code>Step1. MarkDown导出成HTML,从HTML复制内容到邮件.\n\nStep2. 编辑时把图片挨个重新截图到合适大小,替换邮件中的原图.</code></pre><p>亲测在Mac原声邮箱,Mac OutLook, Windows OutLook上格式完美.</p>\n<p>如果有更简单的办法, 请告诉我!</p>\n<p>2020.8.18日更新——————————————————————————————</p>\n<p>感谢penpengguan，发现了新的markdown在线编辑工具<a href=\"https://www.mdnice.com/，直接复制xin&#39;nei\" target=\"_blank\" rel=\"noopener\">https://www.mdnice.com/，直接复制xin&#39;nei</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>用MarkDown编辑完文字调整完格式, 心情一片大好,打开邮件, 复制黏贴, 发送, 我X, 这图片怎么变得这么大, 在windows的OutLook上查看,格式非常杀马特.</p>\n<p>解决办法:</p>\n<pre><code>Step1. MarkDown导出成HTML,从HTML复制内容到邮件.\n\nStep2. 编辑时把图片挨个重新截图到合适大小,替换邮件中的原图.</code></pre><p>亲测在Mac原声邮箱,Mac OutLook, Windows OutLook上格式完美.</p>\n<p>如果有更简单的办法, 请告诉我!</p>\n<p>2020.8.18日更新——————————————————————————————</p>\n<p>感谢penpengguan，发现了新的markdown在线编辑工具<a href=\"https://www.mdnice.com/，直接复制xin&#39;nei\" target=\"_blank\" rel=\"noopener\">https://www.mdnice.com/，直接复制xin&#39;nei</a></p>\n"},{"title":"App目录结构重构","date":"2020-09-20T16:39:10.000Z","_content":"\n> 日前与rucasli一起整理了兴趣部落的文件夹结构，重新区分出了App通用的组建，下面做个小结。\n\n### 一。问题背景\n\n目前兴趣部落目录结构凌乱，文件夹缺少归类，代码乱放情况较多，大大增加了代码维护成本。\n\n* 公共组件问题\n\n    * 目录凌乱\n    \n        随着代码的增长，文件目录开始凌乱，`公共组件`没有放到指定文件夹下，不便于后续`移植`。\n\n    * 功能实现重复\n\n        通过`review`代码发现，通用功能有不少`重复的实现`，其中较严重的甚至有7处重复实现，反思原因，`应该不知道这个功能已经实现or找不到该功能的实现文件`。本次重构后公共功能统一目录，并整理通用功能目录，可解决这个问题。\n  \n  * 缺少子分类\n\n     反观以前的公共组件文件夹，大部分组件都直接`平铺`在一个文件夹下，缺少`竖直分类`，一眼看过去有些凌乱，不利于开发找代码。\n\t![](http://km.oa.com/files/photos/pictures/201705/1495799323_10_w496_h1204.png)\n\n* 业务目录问题\n\n    * 各业务缺少子分类\n    \n      各个业务文件夹下的代码，`缺少二级目录`，平铺情况较多，维护成本较高。\n\t![](http://km.oa.com/files/photos/pictures/201705/1495799362_18_w586_h1436.png)\n\n\n\n\n\n### 二。解决方案\n\n问题的原因：\n\n    1. 老分类规则粒度较粗\n    2. 开发中代码乱放\n    \n    \n针对解决：\n\n    1. 重新制定规则，细分文件夹种类\n    2. 提高开发的归类意识&&编写codedog定时检查文件夹目录结构\n\n    \n    \n\n重新制定的分类规则尽可能简单明了，降低学习成本和开发成本，让开发同事一秒找所属的文件夹。\n\n\n* 大原则\n    \n    跨App通用的文件放`TribeMartrix`文件夹，不通用的放`Tribe`文件夹。\n\t![](http://km.oa.com/files/photos/pictures/201705/1495799431_75_w1568_h712.png)\n\n\n\n\n\n\n* 工程二级文件夹原则（TribeMartrix和Tribe文件夹共用这套规则）\n    \n    * `AppDelegate`，放AppDelegate的子类及其Categories\n    * `Categories`，放各种公用分类（eg：NSString + XXX， NSData + XXX）\n    * `Public`，放公共功能or定义\n    * `ThirdParty`，放第三方库or源码\n    * `Biz`, 放业务代码\n    \n\t![](http://km.oa.com/files/photos/pictures/201705/1495799473_76_w1554_h1288.png)\n\n\n* Public文件夹细分\n    * `Cache`, 缓存代码\n    * `Controller`，公用UIController子类\n    * `DataBase`，数据库代码\n    * `Logic`，公用逻辑代码\n    * `Macros`，公用宏定义\n    * `Model`，公用数据模型\n    * `NetWork`，网络层代码\n    * `Service`，服务代码\n    * `Utils`，公用小功能代码\n    * `View`，可复用的View或UI控件\n    \n\t![](http://km.oa.com/files/photos/pictures/201705/1495799506_13_w588_h1362.png)\n\n\n* `Biz`, 放业务代码\n    * `Model`，业务Model \n    * `View`，业务View\n    * `Controller`，业务Controller\n    * `Manager`，业务Manager，非必选，如果有请归类成文件夹\n    * `Logic`，逻辑代码，独立出来可以为Controller肩负，如果有请归类成文件夹\n    * `其他`，如果还有其他分类，各业务自行归类\n    \n\t![](http://km.oa.com/files/photos/pictures/201705/1495799538_47_w572_h734.png)\n\n        \n\n### 三。App级通用组建功能梳理计划\n\n计划梳理TribeMartrix（跨App通用）的功能，在公共方法中添加注释，然后用<font color=red>AppleDoc</font>生成文档，由于通用功能较多，后续这里会持续更新文档。\n(wiki:http://tapd.oa.com/MonaLisa/markdown_wikis/view/#1010101141006004831)\n\n### 四。工作排期\n\n人力：justinsong，rucasli\n文件夹改动容易引起树冲突，安排在版本发布间隔的时候来整理可以规避冲突，下个版本发布间隔再抽时间来继续后面3项工作。\n\n- [x] 新目录结构搭建--0.5day（done）\n- [x] 已有代码文件整理到新目录中，抽离App通用功能--6day（done）\n- [x] 重复功能剔除--0.5day（done）\n- [ ] 已有通用功能文档持续梳理--工作量较大，待持续梳理\n- [ ] App框架能力抽离--6day\n- [ ] 文件夹codedog程序编写&&推行--2day\n\n### 五。总结\n\n这次和rucas一起梳理文件夹和代码，在梳理中发现很多文件的物理目录和工程目录不对应，还有很多工程中没有用到的废弃文件还存放在物理目录下，梳理中已经全部删除，后续开发中希望大家注意物理目录和工程目录的对应，遵循文件夹分类规则，大家一起努力维持兴趣部落代码结构的纯净 ：）\n\n（完）\n\n","source":"_posts/App目录结构重构.md","raw":"---\ntitle: App目录结构重构\ndate: 2020-09-21 00:39:10\ntags:\n---\n\n> 日前与rucasli一起整理了兴趣部落的文件夹结构，重新区分出了App通用的组建，下面做个小结。\n\n### 一。问题背景\n\n目前兴趣部落目录结构凌乱，文件夹缺少归类，代码乱放情况较多，大大增加了代码维护成本。\n\n* 公共组件问题\n\n    * 目录凌乱\n    \n        随着代码的增长，文件目录开始凌乱，`公共组件`没有放到指定文件夹下，不便于后续`移植`。\n\n    * 功能实现重复\n\n        通过`review`代码发现，通用功能有不少`重复的实现`，其中较严重的甚至有7处重复实现，反思原因，`应该不知道这个功能已经实现or找不到该功能的实现文件`。本次重构后公共功能统一目录，并整理通用功能目录，可解决这个问题。\n  \n  * 缺少子分类\n\n     反观以前的公共组件文件夹，大部分组件都直接`平铺`在一个文件夹下，缺少`竖直分类`，一眼看过去有些凌乱，不利于开发找代码。\n\t![](http://km.oa.com/files/photos/pictures/201705/1495799323_10_w496_h1204.png)\n\n* 业务目录问题\n\n    * 各业务缺少子分类\n    \n      各个业务文件夹下的代码，`缺少二级目录`，平铺情况较多，维护成本较高。\n\t![](http://km.oa.com/files/photos/pictures/201705/1495799362_18_w586_h1436.png)\n\n\n\n\n\n### 二。解决方案\n\n问题的原因：\n\n    1. 老分类规则粒度较粗\n    2. 开发中代码乱放\n    \n    \n针对解决：\n\n    1. 重新制定规则，细分文件夹种类\n    2. 提高开发的归类意识&&编写codedog定时检查文件夹目录结构\n\n    \n    \n\n重新制定的分类规则尽可能简单明了，降低学习成本和开发成本，让开发同事一秒找所属的文件夹。\n\n\n* 大原则\n    \n    跨App通用的文件放`TribeMartrix`文件夹，不通用的放`Tribe`文件夹。\n\t![](http://km.oa.com/files/photos/pictures/201705/1495799431_75_w1568_h712.png)\n\n\n\n\n\n\n* 工程二级文件夹原则（TribeMartrix和Tribe文件夹共用这套规则）\n    \n    * `AppDelegate`，放AppDelegate的子类及其Categories\n    * `Categories`，放各种公用分类（eg：NSString + XXX， NSData + XXX）\n    * `Public`，放公共功能or定义\n    * `ThirdParty`，放第三方库or源码\n    * `Biz`, 放业务代码\n    \n\t![](http://km.oa.com/files/photos/pictures/201705/1495799473_76_w1554_h1288.png)\n\n\n* Public文件夹细分\n    * `Cache`, 缓存代码\n    * `Controller`，公用UIController子类\n    * `DataBase`，数据库代码\n    * `Logic`，公用逻辑代码\n    * `Macros`，公用宏定义\n    * `Model`，公用数据模型\n    * `NetWork`，网络层代码\n    * `Service`，服务代码\n    * `Utils`，公用小功能代码\n    * `View`，可复用的View或UI控件\n    \n\t![](http://km.oa.com/files/photos/pictures/201705/1495799506_13_w588_h1362.png)\n\n\n* `Biz`, 放业务代码\n    * `Model`，业务Model \n    * `View`，业务View\n    * `Controller`，业务Controller\n    * `Manager`，业务Manager，非必选，如果有请归类成文件夹\n    * `Logic`，逻辑代码，独立出来可以为Controller肩负，如果有请归类成文件夹\n    * `其他`，如果还有其他分类，各业务自行归类\n    \n\t![](http://km.oa.com/files/photos/pictures/201705/1495799538_47_w572_h734.png)\n\n        \n\n### 三。App级通用组建功能梳理计划\n\n计划梳理TribeMartrix（跨App通用）的功能，在公共方法中添加注释，然后用<font color=red>AppleDoc</font>生成文档，由于通用功能较多，后续这里会持续更新文档。\n(wiki:http://tapd.oa.com/MonaLisa/markdown_wikis/view/#1010101141006004831)\n\n### 四。工作排期\n\n人力：justinsong，rucasli\n文件夹改动容易引起树冲突，安排在版本发布间隔的时候来整理可以规避冲突，下个版本发布间隔再抽时间来继续后面3项工作。\n\n- [x] 新目录结构搭建--0.5day（done）\n- [x] 已有代码文件整理到新目录中，抽离App通用功能--6day（done）\n- [x] 重复功能剔除--0.5day（done）\n- [ ] 已有通用功能文档持续梳理--工作量较大，待持续梳理\n- [ ] App框架能力抽离--6day\n- [ ] 文件夹codedog程序编写&&推行--2day\n\n### 五。总结\n\n这次和rucas一起梳理文件夹和代码，在梳理中发现很多文件的物理目录和工程目录不对应，还有很多工程中没有用到的废弃文件还存放在物理目录下，梳理中已经全部删除，后续开发中希望大家注意物理目录和工程目录的对应，遵循文件夹分类规则，大家一起努力维持兴趣部落代码结构的纯净 ：）\n\n（完）\n\n","slug":"App目录结构重构","published":1,"updated":"2020-09-22T08:32:36.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgyxlisq00070iu6eytc07or","content":"<blockquote>\n<p>日前与rucasli一起整理了兴趣部落的文件夹结构，重新区分出了App通用的组建，下面做个小结。</p>\n</blockquote>\n<h3 id=\"一。问题背景\"><a href=\"#一。问题背景\" class=\"headerlink\" title=\"一。问题背景\"></a>一。问题背景</h3><p>目前兴趣部落目录结构凌乱，文件夹缺少归类，代码乱放情况较多，大大增加了代码维护成本。</p>\n<ul>\n<li><p>公共组件问题</p>\n<ul>\n<li><p>目录凌乱</p>\n<p>  随着代码的增长，文件目录开始凌乱，<code>公共组件</code>没有放到指定文件夹下，不便于后续<code>移植</code>。</p>\n</li>\n<li><p>功能实现重复</p>\n<p>  通过<code>review</code>代码发现，通用功能有不少<code>重复的实现</code>，其中较严重的甚至有7处重复实现，反思原因，<code>应该不知道这个功能已经实现or找不到该功能的实现文件</code>。本次重构后公共功能统一目录，并整理通用功能目录，可解决这个问题。</p>\n</li>\n</ul>\n<ul>\n<li><p>缺少子分类</p>\n<p> 反观以前的公共组件文件夹，大部分组件都直接<code>平铺</code>在一个文件夹下，缺少<code>竖直分类</code>，一眼看过去有些凌乱，不利于开发找代码。<br><img src=\"http://km.oa.com/files/photos/pictures/201705/1495799323_10_w496_h1204.png\" alt=\"\"></p>\n</li>\n</ul>\n</li>\n<li><p>业务目录问题</p>\n<ul>\n<li><p>各业务缺少子分类</p>\n<p>各个业务文件夹下的代码，<code>缺少二级目录</code>，平铺情况较多，维护成本较高。<br><img src=\"http://km.oa.com/files/photos/pictures/201705/1495799362_18_w586_h1436.png\" alt=\"\"></p>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"二。解决方案\"><a href=\"#二。解决方案\" class=\"headerlink\" title=\"二。解决方案\"></a>二。解决方案</h3><p>问题的原因：</p>\n<pre><code>1. 老分类规则粒度较粗\n2. 开发中代码乱放</code></pre><p>针对解决：</p>\n<pre><code>1. 重新制定规则，细分文件夹种类\n2. 提高开发的归类意识&amp;&amp;编写codedog定时检查文件夹目录结构</code></pre><p>重新制定的分类规则尽可能简单明了，降低学习成本和开发成本，让开发同事一秒找所属的文件夹。</p>\n<ul>\n<li><p>大原则</p>\n<p>  跨App通用的文件放<code>TribeMartrix</code>文件夹，不通用的放<code>Tribe</code>文件夹。<br>  <img src=\"http://km.oa.com/files/photos/pictures/201705/1495799431_75_w1568_h712.png\" alt=\"\"></p>\n</li>\n</ul>\n<ul>\n<li><p>工程二级文件夹原则（TribeMartrix和Tribe文件夹共用这套规则）</p>\n<ul>\n<li><p><code>AppDelegate</code>，放AppDelegate的子类及其Categories</p>\n</li>\n<li><p><code>Categories</code>，放各种公用分类（eg：NSString + XXX， NSData + XXX）</p>\n</li>\n<li><p><code>Public</code>，放公共功能or定义</p>\n</li>\n<li><p><code>ThirdParty</code>，放第三方库or源码</p>\n</li>\n<li><p><code>Biz</code>, 放业务代码</p>\n<p><img src=\"http://km.oa.com/files/photos/pictures/201705/1495799473_76_w1554_h1288.png\" alt=\"\"></p>\n</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p>Public文件夹细分</p>\n<ul>\n<li><p><code>Cache</code>, 缓存代码</p>\n</li>\n<li><p><code>Controller</code>，公用UIController子类</p>\n</li>\n<li><p><code>DataBase</code>，数据库代码</p>\n</li>\n<li><p><code>Logic</code>，公用逻辑代码</p>\n</li>\n<li><p><code>Macros</code>，公用宏定义</p>\n</li>\n<li><p><code>Model</code>，公用数据模型</p>\n</li>\n<li><p><code>NetWork</code>，网络层代码</p>\n</li>\n<li><p><code>Service</code>，服务代码</p>\n</li>\n<li><p><code>Utils</code>，公用小功能代码</p>\n</li>\n<li><p><code>View</code>，可复用的View或UI控件</p>\n<p><img src=\"http://km.oa.com/files/photos/pictures/201705/1495799506_13_w588_h1362.png\" alt=\"\"></p>\n</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p><code>Biz</code>, 放业务代码</p>\n<ul>\n<li><p><code>Model</code>，业务Model </p>\n</li>\n<li><p><code>View</code>，业务View</p>\n</li>\n<li><p><code>Controller</code>，业务Controller</p>\n</li>\n<li><p><code>Manager</code>，业务Manager，非必选，如果有请归类成文件夹</p>\n</li>\n<li><p><code>Logic</code>，逻辑代码，独立出来可以为Controller肩负，如果有请归类成文件夹</p>\n</li>\n<li><p><code>其他</code>，如果还有其他分类，各业务自行归类</p>\n<p><img src=\"http://km.oa.com/files/photos/pictures/201705/1495799538_47_w572_h734.png\" alt=\"\"></p>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"三。App级通用组建功能梳理计划\"><a href=\"#三。App级通用组建功能梳理计划\" class=\"headerlink\" title=\"三。App级通用组建功能梳理计划\"></a>三。App级通用组建功能梳理计划</h3><p>计划梳理TribeMartrix（跨App通用）的功能，在公共方法中添加注释，然后用<font color=red>AppleDoc</font>生成文档，由于通用功能较多，后续这里会持续更新文档。<br>(wiki:<a href=\"http://tapd.oa.com/MonaLisa/markdown_wikis/view/#1010101141006004831\" target=\"_blank\" rel=\"noopener\">http://tapd.oa.com/MonaLisa/markdown_wikis/view/#1010101141006004831</a>)</p>\n<h3 id=\"四。工作排期\"><a href=\"#四。工作排期\" class=\"headerlink\" title=\"四。工作排期\"></a>四。工作排期</h3><p>人力：justinsong，rucasli<br>文件夹改动容易引起树冲突，安排在版本发布间隔的时候来整理可以规避冲突，下个版本发布间隔再抽时间来继续后面3项工作。</p>\n<ul>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 新目录结构搭建–0.5day（done）</li>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 已有代码文件整理到新目录中，抽离App通用功能–6day（done）</li>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 重复功能剔除–0.5day（done）</li>\n<li><input disabled=\"\" type=\"checkbox\"> 已有通用功能文档持续梳理–工作量较大，待持续梳理</li>\n<li><input disabled=\"\" type=\"checkbox\"> App框架能力抽离–6day</li>\n<li><input disabled=\"\" type=\"checkbox\"> 文件夹codedog程序编写&amp;&amp;推行–2day</li>\n</ul>\n<h3 id=\"五。总结\"><a href=\"#五。总结\" class=\"headerlink\" title=\"五。总结\"></a>五。总结</h3><p>这次和rucas一起梳理文件夹和代码，在梳理中发现很多文件的物理目录和工程目录不对应，还有很多工程中没有用到的废弃文件还存放在物理目录下，梳理中已经全部删除，后续开发中希望大家注意物理目录和工程目录的对应，遵循文件夹分类规则，大家一起努力维持兴趣部落代码结构的纯净 ：）</p>\n<p>（完）</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>日前与rucasli一起整理了兴趣部落的文件夹结构，重新区分出了App通用的组建，下面做个小结。</p>\n</blockquote>\n<h3 id=\"一。问题背景\"><a href=\"#一。问题背景\" class=\"headerlink\" title=\"一。问题背景\"></a>一。问题背景</h3><p>目前兴趣部落目录结构凌乱，文件夹缺少归类，代码乱放情况较多，大大增加了代码维护成本。</p>\n<ul>\n<li><p>公共组件问题</p>\n<ul>\n<li><p>目录凌乱</p>\n<p>  随着代码的增长，文件目录开始凌乱，<code>公共组件</code>没有放到指定文件夹下，不便于后续<code>移植</code>。</p>\n</li>\n<li><p>功能实现重复</p>\n<p>  通过<code>review</code>代码发现，通用功能有不少<code>重复的实现</code>，其中较严重的甚至有7处重复实现，反思原因，<code>应该不知道这个功能已经实现or找不到该功能的实现文件</code>。本次重构后公共功能统一目录，并整理通用功能目录，可解决这个问题。</p>\n</li>\n</ul>\n<ul>\n<li><p>缺少子分类</p>\n<p> 反观以前的公共组件文件夹，大部分组件都直接<code>平铺</code>在一个文件夹下，缺少<code>竖直分类</code>，一眼看过去有些凌乱，不利于开发找代码。<br><img src=\"http://km.oa.com/files/photos/pictures/201705/1495799323_10_w496_h1204.png\" alt=\"\"></p>\n</li>\n</ul>\n</li>\n<li><p>业务目录问题</p>\n<ul>\n<li><p>各业务缺少子分类</p>\n<p>各个业务文件夹下的代码，<code>缺少二级目录</code>，平铺情况较多，维护成本较高。<br><img src=\"http://km.oa.com/files/photos/pictures/201705/1495799362_18_w586_h1436.png\" alt=\"\"></p>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"二。解决方案\"><a href=\"#二。解决方案\" class=\"headerlink\" title=\"二。解决方案\"></a>二。解决方案</h3><p>问题的原因：</p>\n<pre><code>1. 老分类规则粒度较粗\n2. 开发中代码乱放</code></pre><p>针对解决：</p>\n<pre><code>1. 重新制定规则，细分文件夹种类\n2. 提高开发的归类意识&amp;&amp;编写codedog定时检查文件夹目录结构</code></pre><p>重新制定的分类规则尽可能简单明了，降低学习成本和开发成本，让开发同事一秒找所属的文件夹。</p>\n<ul>\n<li><p>大原则</p>\n<p>  跨App通用的文件放<code>TribeMartrix</code>文件夹，不通用的放<code>Tribe</code>文件夹。<br>  <img src=\"http://km.oa.com/files/photos/pictures/201705/1495799431_75_w1568_h712.png\" alt=\"\"></p>\n</li>\n</ul>\n<ul>\n<li><p>工程二级文件夹原则（TribeMartrix和Tribe文件夹共用这套规则）</p>\n<ul>\n<li><p><code>AppDelegate</code>，放AppDelegate的子类及其Categories</p>\n</li>\n<li><p><code>Categories</code>，放各种公用分类（eg：NSString + XXX， NSData + XXX）</p>\n</li>\n<li><p><code>Public</code>，放公共功能or定义</p>\n</li>\n<li><p><code>ThirdParty</code>，放第三方库or源码</p>\n</li>\n<li><p><code>Biz</code>, 放业务代码</p>\n<p><img src=\"http://km.oa.com/files/photos/pictures/201705/1495799473_76_w1554_h1288.png\" alt=\"\"></p>\n</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p>Public文件夹细分</p>\n<ul>\n<li><p><code>Cache</code>, 缓存代码</p>\n</li>\n<li><p><code>Controller</code>，公用UIController子类</p>\n</li>\n<li><p><code>DataBase</code>，数据库代码</p>\n</li>\n<li><p><code>Logic</code>，公用逻辑代码</p>\n</li>\n<li><p><code>Macros</code>，公用宏定义</p>\n</li>\n<li><p><code>Model</code>，公用数据模型</p>\n</li>\n<li><p><code>NetWork</code>，网络层代码</p>\n</li>\n<li><p><code>Service</code>，服务代码</p>\n</li>\n<li><p><code>Utils</code>，公用小功能代码</p>\n</li>\n<li><p><code>View</code>，可复用的View或UI控件</p>\n<p><img src=\"http://km.oa.com/files/photos/pictures/201705/1495799506_13_w588_h1362.png\" alt=\"\"></p>\n</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p><code>Biz</code>, 放业务代码</p>\n<ul>\n<li><p><code>Model</code>，业务Model </p>\n</li>\n<li><p><code>View</code>，业务View</p>\n</li>\n<li><p><code>Controller</code>，业务Controller</p>\n</li>\n<li><p><code>Manager</code>，业务Manager，非必选，如果有请归类成文件夹</p>\n</li>\n<li><p><code>Logic</code>，逻辑代码，独立出来可以为Controller肩负，如果有请归类成文件夹</p>\n</li>\n<li><p><code>其他</code>，如果还有其他分类，各业务自行归类</p>\n<p><img src=\"http://km.oa.com/files/photos/pictures/201705/1495799538_47_w572_h734.png\" alt=\"\"></p>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"三。App级通用组建功能梳理计划\"><a href=\"#三。App级通用组建功能梳理计划\" class=\"headerlink\" title=\"三。App级通用组建功能梳理计划\"></a>三。App级通用组建功能梳理计划</h3><p>计划梳理TribeMartrix（跨App通用）的功能，在公共方法中添加注释，然后用<font color=red>AppleDoc</font>生成文档，由于通用功能较多，后续这里会持续更新文档。<br>(wiki:<a href=\"http://tapd.oa.com/MonaLisa/markdown_wikis/view/#1010101141006004831\" target=\"_blank\" rel=\"noopener\">http://tapd.oa.com/MonaLisa/markdown_wikis/view/#1010101141006004831</a>)</p>\n<h3 id=\"四。工作排期\"><a href=\"#四。工作排期\" class=\"headerlink\" title=\"四。工作排期\"></a>四。工作排期</h3><p>人力：justinsong，rucasli<br>文件夹改动容易引起树冲突，安排在版本发布间隔的时候来整理可以规避冲突，下个版本发布间隔再抽时间来继续后面3项工作。</p>\n<ul>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 新目录结构搭建–0.5day（done）</li>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 已有代码文件整理到新目录中，抽离App通用功能–6day（done）</li>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 重复功能剔除–0.5day（done）</li>\n<li><input disabled=\"\" type=\"checkbox\"> 已有通用功能文档持续梳理–工作量较大，待持续梳理</li>\n<li><input disabled=\"\" type=\"checkbox\"> App框架能力抽离–6day</li>\n<li><input disabled=\"\" type=\"checkbox\"> 文件夹codedog程序编写&amp;&amp;推行–2day</li>\n</ul>\n<h3 id=\"五。总结\"><a href=\"#五。总结\" class=\"headerlink\" title=\"五。总结\"></a>五。总结</h3><p>这次和rucas一起梳理文件夹和代码，在梳理中发现很多文件的物理目录和工程目录不对应，还有很多工程中没有用到的废弃文件还存放在物理目录下，梳理中已经全部删除，后续开发中希望大家注意物理目录和工程目录的对应，遵循文件夹分类规则，大家一起努力维持兴趣部落代码结构的纯净 ：）</p>\n<p>（完）</p>\n"},{"title":"git 常用命令备忘","date":"2020-06-22T06:30:07.000Z","_content":"\n\n### 本地所有修改的。没有的提交的，都返回到原来的状态\n\n```\ngit checkout .\n```\n\n### 把所有没有提交的修改暂存到stash里面。可用git stash pop回复\n\n```\ngit stash\n```\n\n### 撤销修改 && 删掉新增文件\n\n```\ngit checkout . && git clean -xdf\n```\n\n### 执行完commit后，想撤回commit\n\n```\ngit reset --soft HEAD^\n```\n\n### 从当前分支拉出新分支\n\n在protect分支修改完代码不能直接提交，需要通过mr合入，直接从protect分支拉出新分支，把代码提交到新分支上。\n\n```\ngit checkout -b newBranchName\n```\n\n拉完第一次push的时候要关联upstream\n\n```\ngit push --set-upstream origin bugfix/test1\n```\n\n\n### 查看远程有哪些分支\n\n```\ngit branch -a\n```\n\n\n### 撤销merge\n\n```\ngit reset --hard 最后一次push的commitID\n```\n\n### 查看项目远程地址\n\n```\ngit remote -v\n```\n\n### 修改远程地址\n\n```\ngit remote set-url origin git@gl.zego.im:MachineVision/KiwiEngine.git\n```\n\n### 查看远程项目所有分支\n\n```\ngit branch -a\n```\n\n### 查看当前仓库基本信息\n\n```\ngit remote show origin\n```","source":"_posts/git-常用命令备忘.md","raw":"---\ntitle: git 常用命令备忘\ndate: 2020-06-22 14:30:07\ntags:\n---\n\n\n### 本地所有修改的。没有的提交的，都返回到原来的状态\n\n```\ngit checkout .\n```\n\n### 把所有没有提交的修改暂存到stash里面。可用git stash pop回复\n\n```\ngit stash\n```\n\n### 撤销修改 && 删掉新增文件\n\n```\ngit checkout . && git clean -xdf\n```\n\n### 执行完commit后，想撤回commit\n\n```\ngit reset --soft HEAD^\n```\n\n### 从当前分支拉出新分支\n\n在protect分支修改完代码不能直接提交，需要通过mr合入，直接从protect分支拉出新分支，把代码提交到新分支上。\n\n```\ngit checkout -b newBranchName\n```\n\n拉完第一次push的时候要关联upstream\n\n```\ngit push --set-upstream origin bugfix/test1\n```\n\n\n### 查看远程有哪些分支\n\n```\ngit branch -a\n```\n\n\n### 撤销merge\n\n```\ngit reset --hard 最后一次push的commitID\n```\n\n### 查看项目远程地址\n\n```\ngit remote -v\n```\n\n### 修改远程地址\n\n```\ngit remote set-url origin git@gl.zego.im:MachineVision/KiwiEngine.git\n```\n\n### 查看远程项目所有分支\n\n```\ngit branch -a\n```\n\n### 查看当前仓库基本信息\n\n```\ngit remote show origin\n```","slug":"git-常用命令备忘","published":1,"updated":"2020-12-30T03:20:31.164Z","_id":"ckgyxlisr00080iu67o1r4okt","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"本地所有修改的。没有的提交的，都返回到原来的状态\"><a href=\"#本地所有修改的。没有的提交的，都返回到原来的状态\" class=\"headerlink\" title=\"本地所有修改的。没有的提交的，都返回到原来的状态\"></a>本地所有修改的。没有的提交的，都返回到原来的状态</h3><pre><code>git checkout .</code></pre><h3 id=\"把所有没有提交的修改暂存到stash里面。可用git-stash-pop回复\"><a href=\"#把所有没有提交的修改暂存到stash里面。可用git-stash-pop回复\" class=\"headerlink\" title=\"把所有没有提交的修改暂存到stash里面。可用git stash pop回复\"></a>把所有没有提交的修改暂存到stash里面。可用git stash pop回复</h3><pre><code>git stash</code></pre><h3 id=\"撤销修改-amp-amp-删掉新增文件\"><a href=\"#撤销修改-amp-amp-删掉新增文件\" class=\"headerlink\" title=\"撤销修改 &amp;&amp; 删掉新增文件\"></a>撤销修改 &amp;&amp; 删掉新增文件</h3><pre><code>git checkout . &amp;&amp; git clean -xdf</code></pre><h3 id=\"执行完commit后，想撤回commit\"><a href=\"#执行完commit后，想撤回commit\" class=\"headerlink\" title=\"执行完commit后，想撤回commit\"></a>执行完commit后，想撤回commit</h3><pre><code>git reset --soft HEAD^</code></pre><h3 id=\"从当前分支拉出新分支\"><a href=\"#从当前分支拉出新分支\" class=\"headerlink\" title=\"从当前分支拉出新分支\"></a>从当前分支拉出新分支</h3><p>在protect分支修改完代码不能直接提交，需要通过mr合入，直接从protect分支拉出新分支，把代码提交到新分支上。</p>\n<pre><code>git checkout -b newBranchName</code></pre><p>拉完第一次push的时候要关联upstream</p>\n<pre><code>git push --set-upstream origin bugfix/test1</code></pre><h3 id=\"查看远程有哪些分支\"><a href=\"#查看远程有哪些分支\" class=\"headerlink\" title=\"查看远程有哪些分支\"></a>查看远程有哪些分支</h3><pre><code>git branch -a</code></pre><h3 id=\"撤销merge\"><a href=\"#撤销merge\" class=\"headerlink\" title=\"撤销merge\"></a>撤销merge</h3><pre><code>git reset --hard 最后一次push的commitID</code></pre><h3 id=\"查看项目远程地址\"><a href=\"#查看项目远程地址\" class=\"headerlink\" title=\"查看项目远程地址\"></a>查看项目远程地址</h3><pre><code>git remote -v</code></pre><h3 id=\"修改远程地址\"><a href=\"#修改远程地址\" class=\"headerlink\" title=\"修改远程地址\"></a>修改远程地址</h3><pre><code>git remote set-url origin git@gl.zego.im:MachineVision/KiwiEngine.git</code></pre><h3 id=\"查看远程项目所有分支\"><a href=\"#查看远程项目所有分支\" class=\"headerlink\" title=\"查看远程项目所有分支\"></a>查看远程项目所有分支</h3><pre><code>git branch -a</code></pre><h3 id=\"查看当前仓库基本信息\"><a href=\"#查看当前仓库基本信息\" class=\"headerlink\" title=\"查看当前仓库基本信息\"></a>查看当前仓库基本信息</h3><pre><code>git remote show origin</code></pre>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"本地所有修改的。没有的提交的，都返回到原来的状态\"><a href=\"#本地所有修改的。没有的提交的，都返回到原来的状态\" class=\"headerlink\" title=\"本地所有修改的。没有的提交的，都返回到原来的状态\"></a>本地所有修改的。没有的提交的，都返回到原来的状态</h3><pre><code>git checkout .</code></pre><h3 id=\"把所有没有提交的修改暂存到stash里面。可用git-stash-pop回复\"><a href=\"#把所有没有提交的修改暂存到stash里面。可用git-stash-pop回复\" class=\"headerlink\" title=\"把所有没有提交的修改暂存到stash里面。可用git stash pop回复\"></a>把所有没有提交的修改暂存到stash里面。可用git stash pop回复</h3><pre><code>git stash</code></pre><h3 id=\"撤销修改-amp-amp-删掉新增文件\"><a href=\"#撤销修改-amp-amp-删掉新增文件\" class=\"headerlink\" title=\"撤销修改 &amp;&amp; 删掉新增文件\"></a>撤销修改 &amp;&amp; 删掉新增文件</h3><pre><code>git checkout . &amp;&amp; git clean -xdf</code></pre><h3 id=\"执行完commit后，想撤回commit\"><a href=\"#执行完commit后，想撤回commit\" class=\"headerlink\" title=\"执行完commit后，想撤回commit\"></a>执行完commit后，想撤回commit</h3><pre><code>git reset --soft HEAD^</code></pre><h3 id=\"从当前分支拉出新分支\"><a href=\"#从当前分支拉出新分支\" class=\"headerlink\" title=\"从当前分支拉出新分支\"></a>从当前分支拉出新分支</h3><p>在protect分支修改完代码不能直接提交，需要通过mr合入，直接从protect分支拉出新分支，把代码提交到新分支上。</p>\n<pre><code>git checkout -b newBranchName</code></pre><p>拉完第一次push的时候要关联upstream</p>\n<pre><code>git push --set-upstream origin bugfix/test1</code></pre><h3 id=\"查看远程有哪些分支\"><a href=\"#查看远程有哪些分支\" class=\"headerlink\" title=\"查看远程有哪些分支\"></a>查看远程有哪些分支</h3><pre><code>git branch -a</code></pre><h3 id=\"撤销merge\"><a href=\"#撤销merge\" class=\"headerlink\" title=\"撤销merge\"></a>撤销merge</h3><pre><code>git reset --hard 最后一次push的commitID</code></pre><h3 id=\"查看项目远程地址\"><a href=\"#查看项目远程地址\" class=\"headerlink\" title=\"查看项目远程地址\"></a>查看项目远程地址</h3><pre><code>git remote -v</code></pre><h3 id=\"修改远程地址\"><a href=\"#修改远程地址\" class=\"headerlink\" title=\"修改远程地址\"></a>修改远程地址</h3><pre><code>git remote set-url origin git@gl.zego.im:MachineVision/KiwiEngine.git</code></pre><h3 id=\"查看远程项目所有分支\"><a href=\"#查看远程项目所有分支\" class=\"headerlink\" title=\"查看远程项目所有分支\"></a>查看远程项目所有分支</h3><pre><code>git branch -a</code></pre><h3 id=\"查看当前仓库基本信息\"><a href=\"#查看当前仓库基本信息\" class=\"headerlink\" title=\"查看当前仓库基本信息\"></a>查看当前仓库基本信息</h3><pre><code>git remote show origin</code></pre>"},{"title":"iOS内存分配：堆、栈、全局区、常量区、代码区","date":"2020-09-06T15:05:02.000Z","_content":"\n本文内容来自：\n* https://www.jianshu.com/p/62f1096c2452\n* https://www.jianshu.com/p/df630e78df32\n    \n\n\n## 内存分配\n\n![](https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2020/09/06/15994047841974.jpg)\n\n## 用途分析\n\n1. 代码区\n    存放函数的二进制代码，也就是，它是可执行程序在内存中的镜像。是只读区域，不可修改。\n    \n2. 常量区\n    static变量，const变量，都存在这里  \n\n3. 全局静态区\n    * 数据区，存放已经初始化的全局变量\n    * BSS区，存放未初始化的全局变量\n\n4. 堆区\n    堆由程序员操作，存放代码中动态分配的内存段，大小不固定，可以动态扩张和缩减，扩张时是向上（高地址）扩展。\n    \n5. 栈区\n    栈区存放函数执行时声明的临时变量，函数参数。\n    \n\n\n","source":"_posts/iOS内存分配：堆、栈、全局区、常量区、代码区.md","raw":"---\ntitle: iOS内存分配：堆、栈、全局区、常量区、代码区\ndate: 2020-09-06 23:05:02\ntags:\n---\n\n本文内容来自：\n* https://www.jianshu.com/p/62f1096c2452\n* https://www.jianshu.com/p/df630e78df32\n    \n\n\n## 内存分配\n\n![](https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2020/09/06/15994047841974.jpg)\n\n## 用途分析\n\n1. 代码区\n    存放函数的二进制代码，也就是，它是可执行程序在内存中的镜像。是只读区域，不可修改。\n    \n2. 常量区\n    static变量，const变量，都存在这里  \n\n3. 全局静态区\n    * 数据区，存放已经初始化的全局变量\n    * BSS区，存放未初始化的全局变量\n\n4. 堆区\n    堆由程序员操作，存放代码中动态分配的内存段，大小不固定，可以动态扩张和缩减，扩张时是向上（高地址）扩展。\n    \n5. 栈区\n    栈区存放函数执行时声明的临时变量，函数参数。\n    \n\n\n","slug":"iOS内存分配：堆、栈、全局区、常量区、代码区","published":1,"updated":"2020-09-06T15:56:33.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgyxlisu000a0iu681qrcps5","content":"<p>本文内容来自：</p>\n<ul>\n<li><a href=\"https://www.jianshu.com/p/62f1096c2452\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/62f1096c2452</a></li>\n<li><a href=\"https://www.jianshu.com/p/df630e78df32\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/df630e78df32</a></li>\n</ul>\n<h2 id=\"内存分配\"><a href=\"#内存分配\" class=\"headerlink\" title=\"内存分配\"></a>内存分配</h2><p><img src=\"https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2020/09/06/15994047841974.jpg\" alt=\"\"></p>\n<h2 id=\"用途分析\"><a href=\"#用途分析\" class=\"headerlink\" title=\"用途分析\"></a>用途分析</h2><ol>\n<li><p>代码区<br> 存放函数的二进制代码，也就是，它是可执行程序在内存中的镜像。是只读区域，不可修改。</p>\n</li>\n<li><p>常量区<br> static变量，const变量，都存在这里  </p>\n</li>\n<li><p>全局静态区</p>\n<ul>\n<li>数据区，存放已经初始化的全局变量</li>\n<li>BSS区，存放未初始化的全局变量</li>\n</ul>\n</li>\n<li><p>堆区<br> 堆由程序员操作，存放代码中动态分配的内存段，大小不固定，可以动态扩张和缩减，扩张时是向上（高地址）扩展。</p>\n</li>\n<li><p>栈区<br> 栈区存放函数执行时声明的临时变量，函数参数。</p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p>本文内容来自：</p>\n<ul>\n<li><a href=\"https://www.jianshu.com/p/62f1096c2452\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/62f1096c2452</a></li>\n<li><a href=\"https://www.jianshu.com/p/df630e78df32\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/df630e78df32</a></li>\n</ul>\n<h2 id=\"内存分配\"><a href=\"#内存分配\" class=\"headerlink\" title=\"内存分配\"></a>内存分配</h2><p><img src=\"https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2020/09/06/15994047841974.jpg\" alt=\"\"></p>\n<h2 id=\"用途分析\"><a href=\"#用途分析\" class=\"headerlink\" title=\"用途分析\"></a>用途分析</h2><ol>\n<li><p>代码区<br> 存放函数的二进制代码，也就是，它是可执行程序在内存中的镜像。是只读区域，不可修改。</p>\n</li>\n<li><p>常量区<br> static变量，const变量，都存在这里  </p>\n</li>\n<li><p>全局静态区</p>\n<ul>\n<li>数据区，存放已经初始化的全局变量</li>\n<li>BSS区，存放未初始化的全局变量</li>\n</ul>\n</li>\n<li><p>堆区<br> 堆由程序员操作，存放代码中动态分配的内存段，大小不固定，可以动态扩张和缩减，扩张时是向上（高地址）扩展。</p>\n</li>\n<li><p>栈区<br> 栈区存放函数执行时声明的临时变量，函数参数。</p>\n</li>\n</ol>\n"},{"title":"iOS 越狱用户灰度流程&&常见问题列表","date":"2020-09-20T16:40:56.000Z","_content":"\n\n一. 越狱用户灰度流程\n\n     0.写在前面：\n\n          使用plist安装，一般是企业级开发者账号不需要登录到APP STORE的IOS设备应用发布时所用到的技巧。\n\n准备:\nipa和plist文件\n一个HTML网页文件(告知iphone如何找到itms-services，已附上)\n一个HTTP服务器(存放APP的服务器，就是提供ipa流量的服务器)\n一个支持https的服务器，用于推送plist，本文上传到pub.idqqimg.com\n\n备选:\n一张二维码\n \nPS:\n从IOS7.1开始，http推送plist已经不好使，只能使用https推送\n \n     1.rdm编包\n\n          上架appstore之前，发布证书打包的ipa包只有越狱手机可以安装，灰度越狱用户时使用发布证书很合适。多得不说，工程中使用发布证书上库编包，准备好ipa和plist。（如果没有发布证书，可以找ladyli申请）。\n\n     2.上传文件到服务器\n     \n             step1: 上传ipa到服务器，拿到ipa的url。\n            服务器：http://turtle.oa.com/，注意存储类型选择CDN\n\n\n\n             step2: 修改plist中的ipa地址，将上一步的url填到这里即可，并确认plist中的bundle id和发布证书的bundle id一致。\n          \n              step3:上传plist到https服务器，注意这里苹果要求必须是https，拿到plist的url。\n              step4:拼接url,使用itms-services服务，\n               URL：itms-services://?action=download-manifest&url=你的plist文件url，必须是https的哦\n               例如：itms-services://?action=download-manifest&url=https://pub.idqqimg.com/pc/misc/files/20151027/8260f5e0328d48a7928e1ac55e682ee1.plist\n\n          到这里为止已经可以体验安装流程了，将url复制到浏览器中，弹出下图提示框，点击安装可以正常下载安装，恭喜你！距离成功不远了！如果没有弹出提示或提示错误，请阅读第五条换证书注意事项和常见问题。\n          \n\n     3.开发html\n         \n<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">\n<html xmlns=\"http://www.w3.org/1999/xhtml\">\n<head>\n<meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" />\n<title>应用名字</title>\n</head>\n<body>\n<h1 style=\"font-size:80pt\">如果点击无法下载安装，请复制超链接到浏览器中打开<h1/>\n<h1 style=\"font-size:100pt\">\n<a title=\"iPhone\" href=\"itms-services://?action=download-manifest&url=https://pub.idqqimg.com/pc/misc/files/20151027/8260f5e0328d48a7928e1ac55e682ee1.plist\">\nIphone Download</a><h1/>\n</body>\n</html>\n\n         使用拼好的URL 替换以上URL即可，保存，发布网页，完成。\n          上一个例子：http://connect.qq.com/files/app.html，点击html中的链接即提示安装\n\n     4.换证书注意事项\n\n          a.工程中的sdk如果有依赖证书的bundle id的，sdk需要找提供者更新bundle id\n          b.如果app中有push功能，客户端更换证书前要确认证书是否带有push功能，如果没有可以找rdm证书的同事添加，另外客户端更换了证书，wns也需要同样更换push证书（wns接口人： vanqfjiang(江且凡)），push证书制作见：http://km.oa.com/group/21900/articles/show/186606\n          c.如果有接入日志上报和crash上报，上报平台的bundle id要使用证书的bundle id。\n          d.rdm编包时如果勾选了“使用企业签名”，如下图，则编出来的结果会有几个，注意第一个名称中不带sign的ipa包，才是使用工程中的证书编出来的，第二个带sign的ipa是使用企业证书重签名打包的ipa，楼主在这卡了很久才发现这个问题。\n          \n\n\n\n二. 常见问题\n\n在 iOS 9 中启动应用时，出现提示“未受信任的企业级开发者”\n这样问题是因为在 iOS 9 以后的版本中，苹果对企业签名的应用做了更严格了限制。具体解决办法请见： 在 iOS 9 中运行企业版应用\n\n在 iOS 9 中点击“安装”按钮后，没有弹出“是否安装”的提示？\n\n这个问题是因为 iOS 9 的一个 Bug 导致的。出现这个问题的前提，一般是由于用户已经从苹果官方 App Store 上安装了相同的应用。解决办法是：先在设备中删除之前已经安装的应用，然后再重新安装即可。\n为什么在 iOS 9 中，点击“安装”按钮后，没有任何反应，桌面也没有出现应用图标，但是状态栏上的网络图标在转？\n这是由于 iOS 9 中的一个 Bug 造成的。虽然看上去没有反应，其实应用已经在后台开始下载并安装了，状态栏上的网络图标在转就是一个证明。这个时候，只要多等待一会儿就好了，应用安装完成之后会在桌面上显示出来的。\n\n\n应用安装过程中提示\"无法下载应用程序\"\n \n原因一：在导出 iOS App 的安装包文件（.ipa文件）时，选择了 Ad-hoc 方式，但是没有添加设备 UDID。\n\n在导出 iOS 的安装包文件时，如果选择了 Ad-hoc 方式（一般用于苹果个人开发者账户），那么，如果要某台设备可以安装，则必须要将这台设备的 UDID 添加到导出安装包时所用的证书文件中（. mobileprovision文件），才可以在这台设备上安装。\n原因三：在导出 iOS App 的安装包文件（.ipa文件）时，选择了 In-house 方式，但是证书已过期。\n\n在导出 iOS 的安装包文件时，如果选择了 In-house 方式（一般用于苹果企业开发者账户），此时，如果出现无法安装的情况，开发者可以检查一下自己的企业开发者证书是否已过期。因为苹果对于企业开发者证书管理较为严格，所以开发者如果使用不当，可能会导致企业证书被封，被封后的企业证书导出的安装包，也是无法正确安装的。\n\n原因四：开发者在生成App安装包时，没有在 Xcode 中设置正确的 Architecture。\n\n\niOS 应用的 Architecture（架构），决定了这款 iOS 应用可以在哪些设备机型上安装。例如，如果某个应用在 Xcode 中只添加了arm64 这一种 Architecture，那么最终打包后的安装包文件对于 iPad mini、iPhone5 等以下设备，都是无法安装的（因为这些设备都不是 arm64 架构）。换句话说，如果需要在某个设备上可以安装，App 就必须支持那个设备的 Architecture。\n所以，正确的解决方法是，在生成 App 安装包时，尽可能让 App 支持更多的 Architecture。\n\n具体操作方法是：在 Xcode - Build Settings - Architecture 中，增加 armv7、armv7s、arm64，以便所有设备都可以安装。然后，将 \"Build active architecture only\" 设置为 NO。对于各个 iOS 设备支持的 Architecture 类型。请点击这里查看。\n\n原因五：App 支持的 iOS 系统版本，和当前设备系统版本不符。\n\nApp 支持的 iOS 系统版本过低或者过高，都可能导致 App 无法安装成功。例如，如果某个 App 设置了只支持 iOS 7.0 以上的系统时，那么，如果在 iOS 6.1 系统上安装时，肯定是无法安装成功。\n\n因此，解决的方法也很简单，我们应该尽量让 App 尽可能支持更宽泛的系统版本。\n\n具体操作方式是：在 Xcode - General - Deployment Info - Deployment Target 中，给 App 设置一个尽量低的版本，例如 iOS 5.0。\n\n原因六：开发者上传的是一个破解的 ipa 安装包，或者是一个使用破解 Xcode 方式打包生成的 ipa 安装包，或者是通过 iTunes 生成的 ipa 安装包。\n\n\n通过任何非 Xcode（或 Xcode 的命令行工具）生成的安装包，都是没有办法正确在设备上安装的（越狱设备除外）。常见的不正确的打包 ipa 的方式有：通过 iTunes 导出安装包文件、通过 iTools 导出安装包文件等等。\n正确的方法是，使用一个正常的苹果开发者证书，通过未破解的 Xcode 打包生成 ipa 安装包。\n\n原因七：设备上已经安装了这个App，且已经安装的 App 和要安装的 App 是用不同证书打包的。\n\n这种情况下，也会造成 App 安装失败。解决的方式很简单，开发者只需将设备上原来已经安装的 App 删除，再重新安装新的 App 即可。\n\n原因八：Info.plist 文件中的LSRequiresIPhoneOS 没有设置，或者设置了 NO。\n\n对于 iOS 的 App 来说，如果Info.plist 文件中的LSRequiresIPhoneOS 没有设置，或者设置了 NO，那么由 Xcode 导出的安装包（.ipa 包），就不会包含 Payload 文件夹，而是被一个叫做 Applications 的文件夹代替。这样的安装包在安装时，会被 iOS 判定为无效的安装包，所以无法被正确安装。\n\n解决方式也很简单，只需要将Info.plist 文件中的LSRequiresIPhoneOS 设置为 YES，然后重新打包即可。具体操作为：在 Xcode 中打开 Info.plist 文件，然后检查 LSRequiresIPhoneOS 是否已设置，如果没有设置，就添加一个，然后将LSRequiresIPhoneOS 的类型设置为 Boolean，值设置为 YES。\n\n设置好以后，可以看到 Info.plist 文件中显示 Application requires iPhone environment 的值为 YES。\n\n \n原因九：网络出现中断或异常。\n遇到这种情况，用户可检查自己手机的所连接的网络是否稳定、速度是否正常等。可以尝试一下其他网站，或者更换一个 Wi-Fi，或者由 Wi-Fi 换成 3G/4G 等，然后重新安装。\n\n在 iOS 8 上安装时，没有任何反应\n\n这个是由于 iOS 8 的一个 bug 造成的，开发者可以尝试在plist中为bundle id加个后缀，详情可见 Stackoverflow 上的讨论。\n安装 iOS 应用时，出现提示“无法连接到 ssl.pgyer.com”\n这个问题一般是由于用户的网络，或者手机缓存错误造成的，可以尝试如下两个方法来解决：\n\n重启手机，然后尝试重新安装。\n换一个网络环境，例如换一个 Wi-Fi 热点，或由 Wi-Fi 换成 3G/4G 等，然后重新安装。\n\n用这样的方式尝试后，一般都可以解决问题。 ","source":"_posts/iOS-越狱用户灰度流程-常见问题列表.md","raw":"---\ntitle: iOS 越狱用户灰度流程&&常见问题列表\ndate: 2020-09-21 00:40:56\ntags:\n---\n\n\n一. 越狱用户灰度流程\n\n     0.写在前面：\n\n          使用plist安装，一般是企业级开发者账号不需要登录到APP STORE的IOS设备应用发布时所用到的技巧。\n\n准备:\nipa和plist文件\n一个HTML网页文件(告知iphone如何找到itms-services，已附上)\n一个HTTP服务器(存放APP的服务器，就是提供ipa流量的服务器)\n一个支持https的服务器，用于推送plist，本文上传到pub.idqqimg.com\n\n备选:\n一张二维码\n \nPS:\n从IOS7.1开始，http推送plist已经不好使，只能使用https推送\n \n     1.rdm编包\n\n          上架appstore之前，发布证书打包的ipa包只有越狱手机可以安装，灰度越狱用户时使用发布证书很合适。多得不说，工程中使用发布证书上库编包，准备好ipa和plist。（如果没有发布证书，可以找ladyli申请）。\n\n     2.上传文件到服务器\n     \n             step1: 上传ipa到服务器，拿到ipa的url。\n            服务器：http://turtle.oa.com/，注意存储类型选择CDN\n\n\n\n             step2: 修改plist中的ipa地址，将上一步的url填到这里即可，并确认plist中的bundle id和发布证书的bundle id一致。\n          \n              step3:上传plist到https服务器，注意这里苹果要求必须是https，拿到plist的url。\n              step4:拼接url,使用itms-services服务，\n               URL：itms-services://?action=download-manifest&url=你的plist文件url，必须是https的哦\n               例如：itms-services://?action=download-manifest&url=https://pub.idqqimg.com/pc/misc/files/20151027/8260f5e0328d48a7928e1ac55e682ee1.plist\n\n          到这里为止已经可以体验安装流程了，将url复制到浏览器中，弹出下图提示框，点击安装可以正常下载安装，恭喜你！距离成功不远了！如果没有弹出提示或提示错误，请阅读第五条换证书注意事项和常见问题。\n          \n\n     3.开发html\n         \n<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">\n<html xmlns=\"http://www.w3.org/1999/xhtml\">\n<head>\n<meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" />\n<title>应用名字</title>\n</head>\n<body>\n<h1 style=\"font-size:80pt\">如果点击无法下载安装，请复制超链接到浏览器中打开<h1/>\n<h1 style=\"font-size:100pt\">\n<a title=\"iPhone\" href=\"itms-services://?action=download-manifest&url=https://pub.idqqimg.com/pc/misc/files/20151027/8260f5e0328d48a7928e1ac55e682ee1.plist\">\nIphone Download</a><h1/>\n</body>\n</html>\n\n         使用拼好的URL 替换以上URL即可，保存，发布网页，完成。\n          上一个例子：http://connect.qq.com/files/app.html，点击html中的链接即提示安装\n\n     4.换证书注意事项\n\n          a.工程中的sdk如果有依赖证书的bundle id的，sdk需要找提供者更新bundle id\n          b.如果app中有push功能，客户端更换证书前要确认证书是否带有push功能，如果没有可以找rdm证书的同事添加，另外客户端更换了证书，wns也需要同样更换push证书（wns接口人： vanqfjiang(江且凡)），push证书制作见：http://km.oa.com/group/21900/articles/show/186606\n          c.如果有接入日志上报和crash上报，上报平台的bundle id要使用证书的bundle id。\n          d.rdm编包时如果勾选了“使用企业签名”，如下图，则编出来的结果会有几个，注意第一个名称中不带sign的ipa包，才是使用工程中的证书编出来的，第二个带sign的ipa是使用企业证书重签名打包的ipa，楼主在这卡了很久才发现这个问题。\n          \n\n\n\n二. 常见问题\n\n在 iOS 9 中启动应用时，出现提示“未受信任的企业级开发者”\n这样问题是因为在 iOS 9 以后的版本中，苹果对企业签名的应用做了更严格了限制。具体解决办法请见： 在 iOS 9 中运行企业版应用\n\n在 iOS 9 中点击“安装”按钮后，没有弹出“是否安装”的提示？\n\n这个问题是因为 iOS 9 的一个 Bug 导致的。出现这个问题的前提，一般是由于用户已经从苹果官方 App Store 上安装了相同的应用。解决办法是：先在设备中删除之前已经安装的应用，然后再重新安装即可。\n为什么在 iOS 9 中，点击“安装”按钮后，没有任何反应，桌面也没有出现应用图标，但是状态栏上的网络图标在转？\n这是由于 iOS 9 中的一个 Bug 造成的。虽然看上去没有反应，其实应用已经在后台开始下载并安装了，状态栏上的网络图标在转就是一个证明。这个时候，只要多等待一会儿就好了，应用安装完成之后会在桌面上显示出来的。\n\n\n应用安装过程中提示\"无法下载应用程序\"\n \n原因一：在导出 iOS App 的安装包文件（.ipa文件）时，选择了 Ad-hoc 方式，但是没有添加设备 UDID。\n\n在导出 iOS 的安装包文件时，如果选择了 Ad-hoc 方式（一般用于苹果个人开发者账户），那么，如果要某台设备可以安装，则必须要将这台设备的 UDID 添加到导出安装包时所用的证书文件中（. mobileprovision文件），才可以在这台设备上安装。\n原因三：在导出 iOS App 的安装包文件（.ipa文件）时，选择了 In-house 方式，但是证书已过期。\n\n在导出 iOS 的安装包文件时，如果选择了 In-house 方式（一般用于苹果企业开发者账户），此时，如果出现无法安装的情况，开发者可以检查一下自己的企业开发者证书是否已过期。因为苹果对于企业开发者证书管理较为严格，所以开发者如果使用不当，可能会导致企业证书被封，被封后的企业证书导出的安装包，也是无法正确安装的。\n\n原因四：开发者在生成App安装包时，没有在 Xcode 中设置正确的 Architecture。\n\n\niOS 应用的 Architecture（架构），决定了这款 iOS 应用可以在哪些设备机型上安装。例如，如果某个应用在 Xcode 中只添加了arm64 这一种 Architecture，那么最终打包后的安装包文件对于 iPad mini、iPhone5 等以下设备，都是无法安装的（因为这些设备都不是 arm64 架构）。换句话说，如果需要在某个设备上可以安装，App 就必须支持那个设备的 Architecture。\n所以，正确的解决方法是，在生成 App 安装包时，尽可能让 App 支持更多的 Architecture。\n\n具体操作方法是：在 Xcode - Build Settings - Architecture 中，增加 armv7、armv7s、arm64，以便所有设备都可以安装。然后，将 \"Build active architecture only\" 设置为 NO。对于各个 iOS 设备支持的 Architecture 类型。请点击这里查看。\n\n原因五：App 支持的 iOS 系统版本，和当前设备系统版本不符。\n\nApp 支持的 iOS 系统版本过低或者过高，都可能导致 App 无法安装成功。例如，如果某个 App 设置了只支持 iOS 7.0 以上的系统时，那么，如果在 iOS 6.1 系统上安装时，肯定是无法安装成功。\n\n因此，解决的方法也很简单，我们应该尽量让 App 尽可能支持更宽泛的系统版本。\n\n具体操作方式是：在 Xcode - General - Deployment Info - Deployment Target 中，给 App 设置一个尽量低的版本，例如 iOS 5.0。\n\n原因六：开发者上传的是一个破解的 ipa 安装包，或者是一个使用破解 Xcode 方式打包生成的 ipa 安装包，或者是通过 iTunes 生成的 ipa 安装包。\n\n\n通过任何非 Xcode（或 Xcode 的命令行工具）生成的安装包，都是没有办法正确在设备上安装的（越狱设备除外）。常见的不正确的打包 ipa 的方式有：通过 iTunes 导出安装包文件、通过 iTools 导出安装包文件等等。\n正确的方法是，使用一个正常的苹果开发者证书，通过未破解的 Xcode 打包生成 ipa 安装包。\n\n原因七：设备上已经安装了这个App，且已经安装的 App 和要安装的 App 是用不同证书打包的。\n\n这种情况下，也会造成 App 安装失败。解决的方式很简单，开发者只需将设备上原来已经安装的 App 删除，再重新安装新的 App 即可。\n\n原因八：Info.plist 文件中的LSRequiresIPhoneOS 没有设置，或者设置了 NO。\n\n对于 iOS 的 App 来说，如果Info.plist 文件中的LSRequiresIPhoneOS 没有设置，或者设置了 NO，那么由 Xcode 导出的安装包（.ipa 包），就不会包含 Payload 文件夹，而是被一个叫做 Applications 的文件夹代替。这样的安装包在安装时，会被 iOS 判定为无效的安装包，所以无法被正确安装。\n\n解决方式也很简单，只需要将Info.plist 文件中的LSRequiresIPhoneOS 设置为 YES，然后重新打包即可。具体操作为：在 Xcode 中打开 Info.plist 文件，然后检查 LSRequiresIPhoneOS 是否已设置，如果没有设置，就添加一个，然后将LSRequiresIPhoneOS 的类型设置为 Boolean，值设置为 YES。\n\n设置好以后，可以看到 Info.plist 文件中显示 Application requires iPhone environment 的值为 YES。\n\n \n原因九：网络出现中断或异常。\n遇到这种情况，用户可检查自己手机的所连接的网络是否稳定、速度是否正常等。可以尝试一下其他网站，或者更换一个 Wi-Fi，或者由 Wi-Fi 换成 3G/4G 等，然后重新安装。\n\n在 iOS 8 上安装时，没有任何反应\n\n这个是由于 iOS 8 的一个 bug 造成的，开发者可以尝试在plist中为bundle id加个后缀，详情可见 Stackoverflow 上的讨论。\n安装 iOS 应用时，出现提示“无法连接到 ssl.pgyer.com”\n这个问题一般是由于用户的网络，或者手机缓存错误造成的，可以尝试如下两个方法来解决：\n\n重启手机，然后尝试重新安装。\n换一个网络环境，例如换一个 Wi-Fi 热点，或由 Wi-Fi 换成 3G/4G 等，然后重新安装。\n\n用这样的方式尝试后，一般都可以解决问题。 ","slug":"iOS-越狱用户灰度流程-常见问题列表","published":1,"updated":"2020-09-20T16:44:01.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgyxlisv000b0iu6b523g2nv","content":"<p>一. 越狱用户灰度流程</p>\n<pre><code> 0.写在前面：\n\n      使用plist安装，一般是企业级开发者账号不需要登录到APP STORE的IOS设备应用发布时所用到的技巧。</code></pre><p>准备:<br>ipa和plist文件<br>一个HTML网页文件(告知iphone如何找到itms-services，已附上)<br>一个HTTP服务器(存放APP的服务器，就是提供ipa流量的服务器)<br>一个支持https的服务器，用于推送plist，本文上传到pub.idqqimg.com</p>\n<p>备选:<br>一张二维码</p>\n<p>PS:<br>从IOS7.1开始，http推送plist已经不好使，只能使用https推送</p>\n<pre><code> 1.rdm编包\n\n      上架appstore之前，发布证书打包的ipa包只有越狱手机可以安装，灰度越狱用户时使用发布证书很合适。多得不说，工程中使用发布证书上库编包，准备好ipa和plist。（如果没有发布证书，可以找ladyli申请）。\n\n 2.上传文件到服务器\n\n         step1: 上传ipa到服务器，拿到ipa的url。\n        服务器：http://turtle.oa.com/，注意存储类型选择CDN\n\n\n\n         step2: 修改plist中的ipa地址，将上一步的url填到这里即可，并确认plist中的bundle id和发布证书的bundle id一致。\n\n          step3:上传plist到https服务器，注意这里苹果要求必须是https，拿到plist的url。\n          step4:拼接url,使用itms-services服务，\n           URL：itms-services://?action=download-manifest&amp;url=你的plist文件url，必须是https的哦\n           例如：itms-services://?action=download-manifest&amp;url=https://pub.idqqimg.com/pc/misc/files/20151027/8260f5e0328d48a7928e1ac55e682ee1.plist\n\n      到这里为止已经可以体验安装流程了，将url复制到浏览器中，弹出下图提示框，点击安装可以正常下载安装，恭喜你！距离成功不远了！如果没有弹出提示或提示错误，请阅读第五条换证书注意事项和常见问题。\n\n\n 3.开发html</code></pre><!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">\n<html xmlns=\"http://www.w3.org/1999/xhtml\">\n<head>\n<meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" />\n<title>应用名字</title>\n<meta name=\"generator\" content=\"Hexo 4.2.1\"></head>\n<body>\n<h1 style=\"font-size:80pt\">如果点击无法下载安装，请复制超链接到浏览器中打开<h1/>\n<h1 style=\"font-size:100pt\">\n<a title=\"iPhone\" href=\"itms-services://?action=download-manifest&url=https://pub.idqqimg.com/pc/misc/files/20151027/8260f5e0328d48a7928e1ac55e682ee1.plist\">\nIphone Download</a><h1/>\n</body>\n</html>\n\n<pre><code>     使用拼好的URL 替换以上URL即可，保存，发布网页，完成。\n      上一个例子：http://connect.qq.com/files/app.html，点击html中的链接即提示安装\n\n 4.换证书注意事项\n\n      a.工程中的sdk如果有依赖证书的bundle id的，sdk需要找提供者更新bundle id\n      b.如果app中有push功能，客户端更换证书前要确认证书是否带有push功能，如果没有可以找rdm证书的同事添加，另外客户端更换了证书，wns也需要同样更换push证书（wns接口人： vanqfjiang(江且凡)），push证书制作见：http://km.oa.com/group/21900/articles/show/186606\n      c.如果有接入日志上报和crash上报，上报平台的bundle id要使用证书的bundle id。\n      d.rdm编包时如果勾选了“使用企业签名”，如下图，则编出来的结果会有几个，注意第一个名称中不带sign的ipa包，才是使用工程中的证书编出来的，第二个带sign的ipa是使用企业证书重签名打包的ipa，楼主在这卡了很久才发现这个问题。</code></pre><p>二. 常见问题</p>\n<p>在 iOS 9 中启动应用时，出现提示“未受信任的企业级开发者”<br>这样问题是因为在 iOS 9 以后的版本中，苹果对企业签名的应用做了更严格了限制。具体解决办法请见： 在 iOS 9 中运行企业版应用</p>\n<p>在 iOS 9 中点击“安装”按钮后，没有弹出“是否安装”的提示？</p>\n<p>这个问题是因为 iOS 9 的一个 Bug 导致的。出现这个问题的前提，一般是由于用户已经从苹果官方 App Store 上安装了相同的应用。解决办法是：先在设备中删除之前已经安装的应用，然后再重新安装即可。<br>为什么在 iOS 9 中，点击“安装”按钮后，没有任何反应，桌面也没有出现应用图标，但是状态栏上的网络图标在转？<br>这是由于 iOS 9 中的一个 Bug 造成的。虽然看上去没有反应，其实应用已经在后台开始下载并安装了，状态栏上的网络图标在转就是一个证明。这个时候，只要多等待一会儿就好了，应用安装完成之后会在桌面上显示出来的。</p>\n<p>应用安装过程中提示”无法下载应用程序”</p>\n<p>原因一：在导出 iOS App 的安装包文件（.ipa文件）时，选择了 Ad-hoc 方式，但是没有添加设备 UDID。</p>\n<p>在导出 iOS 的安装包文件时，如果选择了 Ad-hoc 方式（一般用于苹果个人开发者账户），那么，如果要某台设备可以安装，则必须要将这台设备的 UDID 添加到导出安装包时所用的证书文件中（. mobileprovision文件），才可以在这台设备上安装。<br>原因三：在导出 iOS App 的安装包文件（.ipa文件）时，选择了 In-house 方式，但是证书已过期。</p>\n<p>在导出 iOS 的安装包文件时，如果选择了 In-house 方式（一般用于苹果企业开发者账户），此时，如果出现无法安装的情况，开发者可以检查一下自己的企业开发者证书是否已过期。因为苹果对于企业开发者证书管理较为严格，所以开发者如果使用不当，可能会导致企业证书被封，被封后的企业证书导出的安装包，也是无法正确安装的。</p>\n<p>原因四：开发者在生成App安装包时，没有在 Xcode 中设置正确的 Architecture。</p>\n<p>iOS 应用的 Architecture（架构），决定了这款 iOS 应用可以在哪些设备机型上安装。例如，如果某个应用在 Xcode 中只添加了arm64 这一种 Architecture，那么最终打包后的安装包文件对于 iPad mini、iPhone5 等以下设备，都是无法安装的（因为这些设备都不是 arm64 架构）。换句话说，如果需要在某个设备上可以安装，App 就必须支持那个设备的 Architecture。<br>所以，正确的解决方法是，在生成 App 安装包时，尽可能让 App 支持更多的 Architecture。</p>\n<p>具体操作方法是：在 Xcode - Build Settings - Architecture 中，增加 armv7、armv7s、arm64，以便所有设备都可以安装。然后，将 “Build active architecture only” 设置为 NO。对于各个 iOS 设备支持的 Architecture 类型。请点击这里查看。</p>\n<p>原因五：App 支持的 iOS 系统版本，和当前设备系统版本不符。</p>\n<p>App 支持的 iOS 系统版本过低或者过高，都可能导致 App 无法安装成功。例如，如果某个 App 设置了只支持 iOS 7.0 以上的系统时，那么，如果在 iOS 6.1 系统上安装时，肯定是无法安装成功。</p>\n<p>因此，解决的方法也很简单，我们应该尽量让 App 尽可能支持更宽泛的系统版本。</p>\n<p>具体操作方式是：在 Xcode - General - Deployment Info - Deployment Target 中，给 App 设置一个尽量低的版本，例如 iOS 5.0。</p>\n<p>原因六：开发者上传的是一个破解的 ipa 安装包，或者是一个使用破解 Xcode 方式打包生成的 ipa 安装包，或者是通过 iTunes 生成的 ipa 安装包。</p>\n<p>通过任何非 Xcode（或 Xcode 的命令行工具）生成的安装包，都是没有办法正确在设备上安装的（越狱设备除外）。常见的不正确的打包 ipa 的方式有：通过 iTunes 导出安装包文件、通过 iTools 导出安装包文件等等。<br>正确的方法是，使用一个正常的苹果开发者证书，通过未破解的 Xcode 打包生成 ipa 安装包。</p>\n<p>原因七：设备上已经安装了这个App，且已经安装的 App 和要安装的 App 是用不同证书打包的。</p>\n<p>这种情况下，也会造成 App 安装失败。解决的方式很简单，开发者只需将设备上原来已经安装的 App 删除，再重新安装新的 App 即可。</p>\n<p>原因八：Info.plist 文件中的LSRequiresIPhoneOS 没有设置，或者设置了 NO。</p>\n<p>对于 iOS 的 App 来说，如果Info.plist 文件中的LSRequiresIPhoneOS 没有设置，或者设置了 NO，那么由 Xcode 导出的安装包（.ipa 包），就不会包含 Payload 文件夹，而是被一个叫做 Applications 的文件夹代替。这样的安装包在安装时，会被 iOS 判定为无效的安装包，所以无法被正确安装。</p>\n<p>解决方式也很简单，只需要将Info.plist 文件中的LSRequiresIPhoneOS 设置为 YES，然后重新打包即可。具体操作为：在 Xcode 中打开 Info.plist 文件，然后检查 LSRequiresIPhoneOS 是否已设置，如果没有设置，就添加一个，然后将LSRequiresIPhoneOS 的类型设置为 Boolean，值设置为 YES。</p>\n<p>设置好以后，可以看到 Info.plist 文件中显示 Application requires iPhone environment 的值为 YES。</p>\n<p>原因九：网络出现中断或异常。<br>遇到这种情况，用户可检查自己手机的所连接的网络是否稳定、速度是否正常等。可以尝试一下其他网站，或者更换一个 Wi-Fi，或者由 Wi-Fi 换成 3G/4G 等，然后重新安装。</p>\n<p>在 iOS 8 上安装时，没有任何反应</p>\n<p>这个是由于 iOS 8 的一个 bug 造成的，开发者可以尝试在plist中为bundle id加个后缀，详情可见 Stackoverflow 上的讨论。<br>安装 iOS 应用时，出现提示“无法连接到 ssl.pgyer.com”<br>这个问题一般是由于用户的网络，或者手机缓存错误造成的，可以尝试如下两个方法来解决：</p>\n<p>重启手机，然后尝试重新安装。<br>换一个网络环境，例如换一个 Wi-Fi 热点，或由 Wi-Fi 换成 3G/4G 等，然后重新安装。</p>\n<p>用这样的方式尝试后，一般都可以解决问题。 </p>\n","site":{"data":{}},"excerpt":"","more":"<p>一. 越狱用户灰度流程</p>\n<pre><code> 0.写在前面：\n\n      使用plist安装，一般是企业级开发者账号不需要登录到APP STORE的IOS设备应用发布时所用到的技巧。</code></pre><p>准备:<br>ipa和plist文件<br>一个HTML网页文件(告知iphone如何找到itms-services，已附上)<br>一个HTTP服务器(存放APP的服务器，就是提供ipa流量的服务器)<br>一个支持https的服务器，用于推送plist，本文上传到pub.idqqimg.com</p>\n<p>备选:<br>一张二维码</p>\n<p>PS:<br>从IOS7.1开始，http推送plist已经不好使，只能使用https推送</p>\n<pre><code> 1.rdm编包\n\n      上架appstore之前，发布证书打包的ipa包只有越狱手机可以安装，灰度越狱用户时使用发布证书很合适。多得不说，工程中使用发布证书上库编包，准备好ipa和plist。（如果没有发布证书，可以找ladyli申请）。\n\n 2.上传文件到服务器\n\n         step1: 上传ipa到服务器，拿到ipa的url。\n        服务器：http://turtle.oa.com/，注意存储类型选择CDN\n\n\n\n         step2: 修改plist中的ipa地址，将上一步的url填到这里即可，并确认plist中的bundle id和发布证书的bundle id一致。\n\n          step3:上传plist到https服务器，注意这里苹果要求必须是https，拿到plist的url。\n          step4:拼接url,使用itms-services服务，\n           URL：itms-services://?action=download-manifest&amp;url=你的plist文件url，必须是https的哦\n           例如：itms-services://?action=download-manifest&amp;url=https://pub.idqqimg.com/pc/misc/files/20151027/8260f5e0328d48a7928e1ac55e682ee1.plist\n\n      到这里为止已经可以体验安装流程了，将url复制到浏览器中，弹出下图提示框，点击安装可以正常下载安装，恭喜你！距离成功不远了！如果没有弹出提示或提示错误，请阅读第五条换证书注意事项和常见问题。\n\n\n 3.开发html</code></pre><!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">\n<html xmlns=\"http://www.w3.org/1999/xhtml\">\n<head>\n<meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" />\n<title>应用名字</title>\n<meta name=\"generator\" content=\"Hexo 4.2.1\"></head>\n<body>\n<h1 style=\"font-size:80pt\">如果点击无法下载安装，请复制超链接到浏览器中打开<h1/>\n<h1 style=\"font-size:100pt\">\n<a title=\"iPhone\" href=\"itms-services://?action=download-manifest&url=https://pub.idqqimg.com/pc/misc/files/20151027/8260f5e0328d48a7928e1ac55e682ee1.plist\">\nIphone Download</a><h1/>\n</body>\n</html>\n\n<pre><code>     使用拼好的URL 替换以上URL即可，保存，发布网页，完成。\n      上一个例子：http://connect.qq.com/files/app.html，点击html中的链接即提示安装\n\n 4.换证书注意事项\n\n      a.工程中的sdk如果有依赖证书的bundle id的，sdk需要找提供者更新bundle id\n      b.如果app中有push功能，客户端更换证书前要确认证书是否带有push功能，如果没有可以找rdm证书的同事添加，另外客户端更换了证书，wns也需要同样更换push证书（wns接口人： vanqfjiang(江且凡)），push证书制作见：http://km.oa.com/group/21900/articles/show/186606\n      c.如果有接入日志上报和crash上报，上报平台的bundle id要使用证书的bundle id。\n      d.rdm编包时如果勾选了“使用企业签名”，如下图，则编出来的结果会有几个，注意第一个名称中不带sign的ipa包，才是使用工程中的证书编出来的，第二个带sign的ipa是使用企业证书重签名打包的ipa，楼主在这卡了很久才发现这个问题。</code></pre><p>二. 常见问题</p>\n<p>在 iOS 9 中启动应用时，出现提示“未受信任的企业级开发者”<br>这样问题是因为在 iOS 9 以后的版本中，苹果对企业签名的应用做了更严格了限制。具体解决办法请见： 在 iOS 9 中运行企业版应用</p>\n<p>在 iOS 9 中点击“安装”按钮后，没有弹出“是否安装”的提示？</p>\n<p>这个问题是因为 iOS 9 的一个 Bug 导致的。出现这个问题的前提，一般是由于用户已经从苹果官方 App Store 上安装了相同的应用。解决办法是：先在设备中删除之前已经安装的应用，然后再重新安装即可。<br>为什么在 iOS 9 中，点击“安装”按钮后，没有任何反应，桌面也没有出现应用图标，但是状态栏上的网络图标在转？<br>这是由于 iOS 9 中的一个 Bug 造成的。虽然看上去没有反应，其实应用已经在后台开始下载并安装了，状态栏上的网络图标在转就是一个证明。这个时候，只要多等待一会儿就好了，应用安装完成之后会在桌面上显示出来的。</p>\n<p>应用安装过程中提示”无法下载应用程序”</p>\n<p>原因一：在导出 iOS App 的安装包文件（.ipa文件）时，选择了 Ad-hoc 方式，但是没有添加设备 UDID。</p>\n<p>在导出 iOS 的安装包文件时，如果选择了 Ad-hoc 方式（一般用于苹果个人开发者账户），那么，如果要某台设备可以安装，则必须要将这台设备的 UDID 添加到导出安装包时所用的证书文件中（. mobileprovision文件），才可以在这台设备上安装。<br>原因三：在导出 iOS App 的安装包文件（.ipa文件）时，选择了 In-house 方式，但是证书已过期。</p>\n<p>在导出 iOS 的安装包文件时，如果选择了 In-house 方式（一般用于苹果企业开发者账户），此时，如果出现无法安装的情况，开发者可以检查一下自己的企业开发者证书是否已过期。因为苹果对于企业开发者证书管理较为严格，所以开发者如果使用不当，可能会导致企业证书被封，被封后的企业证书导出的安装包，也是无法正确安装的。</p>\n<p>原因四：开发者在生成App安装包时，没有在 Xcode 中设置正确的 Architecture。</p>\n<p>iOS 应用的 Architecture（架构），决定了这款 iOS 应用可以在哪些设备机型上安装。例如，如果某个应用在 Xcode 中只添加了arm64 这一种 Architecture，那么最终打包后的安装包文件对于 iPad mini、iPhone5 等以下设备，都是无法安装的（因为这些设备都不是 arm64 架构）。换句话说，如果需要在某个设备上可以安装，App 就必须支持那个设备的 Architecture。<br>所以，正确的解决方法是，在生成 App 安装包时，尽可能让 App 支持更多的 Architecture。</p>\n<p>具体操作方法是：在 Xcode - Build Settings - Architecture 中，增加 armv7、armv7s、arm64，以便所有设备都可以安装。然后，将 “Build active architecture only” 设置为 NO。对于各个 iOS 设备支持的 Architecture 类型。请点击这里查看。</p>\n<p>原因五：App 支持的 iOS 系统版本，和当前设备系统版本不符。</p>\n<p>App 支持的 iOS 系统版本过低或者过高，都可能导致 App 无法安装成功。例如，如果某个 App 设置了只支持 iOS 7.0 以上的系统时，那么，如果在 iOS 6.1 系统上安装时，肯定是无法安装成功。</p>\n<p>因此，解决的方法也很简单，我们应该尽量让 App 尽可能支持更宽泛的系统版本。</p>\n<p>具体操作方式是：在 Xcode - General - Deployment Info - Deployment Target 中，给 App 设置一个尽量低的版本，例如 iOS 5.0。</p>\n<p>原因六：开发者上传的是一个破解的 ipa 安装包，或者是一个使用破解 Xcode 方式打包生成的 ipa 安装包，或者是通过 iTunes 生成的 ipa 安装包。</p>\n<p>通过任何非 Xcode（或 Xcode 的命令行工具）生成的安装包，都是没有办法正确在设备上安装的（越狱设备除外）。常见的不正确的打包 ipa 的方式有：通过 iTunes 导出安装包文件、通过 iTools 导出安装包文件等等。<br>正确的方法是，使用一个正常的苹果开发者证书，通过未破解的 Xcode 打包生成 ipa 安装包。</p>\n<p>原因七：设备上已经安装了这个App，且已经安装的 App 和要安装的 App 是用不同证书打包的。</p>\n<p>这种情况下，也会造成 App 安装失败。解决的方式很简单，开发者只需将设备上原来已经安装的 App 删除，再重新安装新的 App 即可。</p>\n<p>原因八：Info.plist 文件中的LSRequiresIPhoneOS 没有设置，或者设置了 NO。</p>\n<p>对于 iOS 的 App 来说，如果Info.plist 文件中的LSRequiresIPhoneOS 没有设置，或者设置了 NO，那么由 Xcode 导出的安装包（.ipa 包），就不会包含 Payload 文件夹，而是被一个叫做 Applications 的文件夹代替。这样的安装包在安装时，会被 iOS 判定为无效的安装包，所以无法被正确安装。</p>\n<p>解决方式也很简单，只需要将Info.plist 文件中的LSRequiresIPhoneOS 设置为 YES，然后重新打包即可。具体操作为：在 Xcode 中打开 Info.plist 文件，然后检查 LSRequiresIPhoneOS 是否已设置，如果没有设置，就添加一个，然后将LSRequiresIPhoneOS 的类型设置为 Boolean，值设置为 YES。</p>\n<p>设置好以后，可以看到 Info.plist 文件中显示 Application requires iPhone environment 的值为 YES。</p>\n<p>原因九：网络出现中断或异常。<br>遇到这种情况，用户可检查自己手机的所连接的网络是否稳定、速度是否正常等。可以尝试一下其他网站，或者更换一个 Wi-Fi，或者由 Wi-Fi 换成 3G/4G 等，然后重新安装。</p>\n<p>在 iOS 8 上安装时，没有任何反应</p>\n<p>这个是由于 iOS 8 的一个 bug 造成的，开发者可以尝试在plist中为bundle id加个后缀，详情可见 Stackoverflow 上的讨论。<br>安装 iOS 应用时，出现提示“无法连接到 ssl.pgyer.com”<br>这个问题一般是由于用户的网络，或者手机缓存错误造成的，可以尝试如下两个方法来解决：</p>\n<p>重启手机，然后尝试重新安装。<br>换一个网络环境，例如换一个 Wi-Fi 热点，或由 Wi-Fi 换成 3G/4G 等，然后重新安装。</p>\n<p>用这样的方式尝试后，一般都可以解决问题。 </p>\n"},{"_content":"# pod install 警告梳理\n\n## [!] Unable to read the license file `LICENSE` for the spec `HelperModule (0.0.38)`\n\n* 原因：\n    无法读LICENSE文件，\n\n\n## [!] CocoaPods did not set the base configuration of your project because your project already has a custom config set. In order for CocoaPods integration to work at all, please either set the base configurations of the target `Runner` to `Target Support Files/Pods-Runner/Pods-Runner.betarelease.xcconfig` or include the `Target Support Files/Pods-Runner/Pods-Runner.betarelease.xcconfig` in your build configuration (`Flutter/Release.xcconfig`).\n\n## [!] The `Runner [Release]` target overrides the `ALWAYS_EMBED_SWIFT_STANDARD_LIBRARIES` build setting defined in `Pods/Target Support Files/Pods-Runner/Pods-Runner.release.xcconfig'. This can lead to problems with the CocoaPods installation\n    - Use the `$(inherited)` flag, or\n    - Remove the build settings from the target.\n\n## [!] Found multiple specifications for `Mantle (1.5.6)`:- /Users/bkdevops/.cocoapods/repos/master/Specs/5/d/c/Mantle/1.5.6/Mantle.podspec.json- /Users/bkdevops/.cocoapods/repos/trunk/Specs/5/d/c/Mantle/1.5.6/Mantle.podspec.json\n\n* 原因：\n    源冲突，~/.cocoapods/repos 文件夹下有两个源, 一个叫trunk，一个叫master，这俩源中都有相同的pod库，pod install命令不知道要引用哪个，一般不影响使用，但会提示警告，影响观感。\n\n* 解决:\n    trunk or master 删掉一个，哪个都行。\n\n\n## [!] The `Runner [Profile]` target overrides the `ALWAYS_EMBED_SWIFT_STANDARD_LIBRARIES` build setting defined in `Pods/Target Support Files/Pods-Runner/Pods-Runner.profile.xcconfig'. This can lead to problems with the CocoaPods installation","source":"_posts/pod install 警告梳理.md","raw":"# pod install 警告梳理\n\n## [!] Unable to read the license file `LICENSE` for the spec `HelperModule (0.0.38)`\n\n* 原因：\n    无法读LICENSE文件，\n\n\n## [!] CocoaPods did not set the base configuration of your project because your project already has a custom config set. In order for CocoaPods integration to work at all, please either set the base configurations of the target `Runner` to `Target Support Files/Pods-Runner/Pods-Runner.betarelease.xcconfig` or include the `Target Support Files/Pods-Runner/Pods-Runner.betarelease.xcconfig` in your build configuration (`Flutter/Release.xcconfig`).\n\n## [!] The `Runner [Release]` target overrides the `ALWAYS_EMBED_SWIFT_STANDARD_LIBRARIES` build setting defined in `Pods/Target Support Files/Pods-Runner/Pods-Runner.release.xcconfig'. This can lead to problems with the CocoaPods installation\n    - Use the `$(inherited)` flag, or\n    - Remove the build settings from the target.\n\n## [!] Found multiple specifications for `Mantle (1.5.6)`:- /Users/bkdevops/.cocoapods/repos/master/Specs/5/d/c/Mantle/1.5.6/Mantle.podspec.json- /Users/bkdevops/.cocoapods/repos/trunk/Specs/5/d/c/Mantle/1.5.6/Mantle.podspec.json\n\n* 原因：\n    源冲突，~/.cocoapods/repos 文件夹下有两个源, 一个叫trunk，一个叫master，这俩源中都有相同的pod库，pod install命令不知道要引用哪个，一般不影响使用，但会提示警告，影响观感。\n\n* 解决:\n    trunk or master 删掉一个，哪个都行。\n\n\n## [!] The `Runner [Profile]` target overrides the `ALWAYS_EMBED_SWIFT_STANDARD_LIBRARIES` build setting defined in `Pods/Target Support Files/Pods-Runner/Pods-Runner.profile.xcconfig'. This can lead to problems with the CocoaPods installation","slug":"pod install 警告梳理","published":1,"date":"2020-06-09T07:24:56.000Z","updated":"2020-06-21T14:48:19.000Z","title":"pod install 警告梳理","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgyxlisv000c0iu6ga5l4o4e","content":"<h1 id=\"pod-install-警告梳理\"><a href=\"#pod-install-警告梳理\" class=\"headerlink\" title=\"pod install 警告梳理\"></a>pod install 警告梳理</h1><h2 id=\"Unable-to-read-the-license-file-LICENSE-for-the-spec-HelperModule-0-0-38\"><a href=\"#Unable-to-read-the-license-file-LICENSE-for-the-spec-HelperModule-0-0-38\" class=\"headerlink\" title=\"[!] Unable to read the license file LICENSE for the spec HelperModule (0.0.38)\"></a>[!] Unable to read the license file <code>LICENSE</code> for the spec <code>HelperModule (0.0.38)</code></h2><ul>\n<li>原因：<br>  无法读LICENSE文件，</li>\n</ul>\n<h2 id=\"CocoaPods-did-not-set-the-base-configuration-of-your-project-because-your-project-already-has-a-custom-config-set-In-order-for-CocoaPods-integration-to-work-at-all-please-either-set-the-base-configurations-of-the-target-Runner-to-Target-Support-Files-Pods-Runner-Pods-Runner-betarelease-xcconfig-or-include-the-Target-Support-Files-Pods-Runner-Pods-Runner-betarelease-xcconfig-in-your-build-configuration-Flutter-Release-xcconfig\"><a href=\"#CocoaPods-did-not-set-the-base-configuration-of-your-project-because-your-project-already-has-a-custom-config-set-In-order-for-CocoaPods-integration-to-work-at-all-please-either-set-the-base-configurations-of-the-target-Runner-to-Target-Support-Files-Pods-Runner-Pods-Runner-betarelease-xcconfig-or-include-the-Target-Support-Files-Pods-Runner-Pods-Runner-betarelease-xcconfig-in-your-build-configuration-Flutter-Release-xcconfig\" class=\"headerlink\" title=\"[!] CocoaPods did not set the base configuration of your project because your project already has a custom config set. In order for CocoaPods integration to work at all, please either set the base configurations of the target Runner to Target Support Files/Pods-Runner/Pods-Runner.betarelease.xcconfig or include the Target Support Files/Pods-Runner/Pods-Runner.betarelease.xcconfig in your build configuration (Flutter/Release.xcconfig).\"></a>[!] CocoaPods did not set the base configuration of your project because your project already has a custom config set. In order for CocoaPods integration to work at all, please either set the base configurations of the target <code>Runner</code> to <code>Target Support Files/Pods-Runner/Pods-Runner.betarelease.xcconfig</code> or include the <code>Target Support Files/Pods-Runner/Pods-Runner.betarelease.xcconfig</code> in your build configuration (<code>Flutter/Release.xcconfig</code>).</h2><h2 id=\"The-Runner-Release-target-overrides-the-ALWAYS-EMBED-SWIFT-STANDARD-LIBRARIES-build-setting-defined-in-Pods-Target-Support-Files-Pods-Runner-Pods-Runner-release-xcconfig’-This-can-lead-to-problems-with-the-CocoaPods-installation\"><a href=\"#The-Runner-Release-target-overrides-the-ALWAYS-EMBED-SWIFT-STANDARD-LIBRARIES-build-setting-defined-in-Pods-Target-Support-Files-Pods-Runner-Pods-Runner-release-xcconfig’-This-can-lead-to-problems-with-the-CocoaPods-installation\" class=\"headerlink\" title=\"[!] The Runner [Release] target overrides the ALWAYS_EMBED_SWIFT_STANDARD_LIBRARIES build setting defined in `Pods/Target Support Files/Pods-Runner/Pods-Runner.release.xcconfig’. This can lead to problems with the CocoaPods installation\"></a>[!] The <code>Runner [Release]</code> target overrides the <code>ALWAYS_EMBED_SWIFT_STANDARD_LIBRARIES</code> build setting defined in `Pods/Target Support Files/Pods-Runner/Pods-Runner.release.xcconfig’. This can lead to problems with the CocoaPods installation</h2><pre><code>- Use the `$(inherited)` flag, or\n- Remove the build settings from the target.</code></pre><h2 id=\"Found-multiple-specifications-for-Mantle-1-5-6-Users-bkdevops-cocoapods-repos-master-Specs-5-d-c-Mantle-1-5-6-Mantle-podspec-json-Users-bkdevops-cocoapods-repos-trunk-Specs-5-d-c-Mantle-1-5-6-Mantle-podspec-json\"><a href=\"#Found-multiple-specifications-for-Mantle-1-5-6-Users-bkdevops-cocoapods-repos-master-Specs-5-d-c-Mantle-1-5-6-Mantle-podspec-json-Users-bkdevops-cocoapods-repos-trunk-Specs-5-d-c-Mantle-1-5-6-Mantle-podspec-json\" class=\"headerlink\" title=\"[!] Found multiple specifications for Mantle (1.5.6):- /Users/bkdevops/.cocoapods/repos/master/Specs/5/d/c/Mantle/1.5.6/Mantle.podspec.json- /Users/bkdevops/.cocoapods/repos/trunk/Specs/5/d/c/Mantle/1.5.6/Mantle.podspec.json\"></a>[!] Found multiple specifications for <code>Mantle (1.5.6)</code>:- /Users/bkdevops/.cocoapods/repos/master/Specs/5/d/c/Mantle/1.5.6/Mantle.podspec.json- /Users/bkdevops/.cocoapods/repos/trunk/Specs/5/d/c/Mantle/1.5.6/Mantle.podspec.json</h2><ul>\n<li><p>原因：<br>  源冲突，~/.cocoapods/repos 文件夹下有两个源, 一个叫trunk，一个叫master，这俩源中都有相同的pod库，pod install命令不知道要引用哪个，一般不影响使用，但会提示警告，影响观感。</p>\n</li>\n<li><p>解决:<br>  trunk or master 删掉一个，哪个都行。</p>\n</li>\n</ul>\n<h2 id=\"The-Runner-Profile-target-overrides-the-ALWAYS-EMBED-SWIFT-STANDARD-LIBRARIES-build-setting-defined-in-Pods-Target-Support-Files-Pods-Runner-Pods-Runner-profile-xcconfig’-This-can-lead-to-problems-with-the-CocoaPods-installation\"><a href=\"#The-Runner-Profile-target-overrides-the-ALWAYS-EMBED-SWIFT-STANDARD-LIBRARIES-build-setting-defined-in-Pods-Target-Support-Files-Pods-Runner-Pods-Runner-profile-xcconfig’-This-can-lead-to-problems-with-the-CocoaPods-installation\" class=\"headerlink\" title=\"[!] The Runner [Profile] target overrides the ALWAYS_EMBED_SWIFT_STANDARD_LIBRARIES build setting defined in `Pods/Target Support Files/Pods-Runner/Pods-Runner.profile.xcconfig’. This can lead to problems with the CocoaPods installation\"></a>[!] The <code>Runner [Profile]</code> target overrides the <code>ALWAYS_EMBED_SWIFT_STANDARD_LIBRARIES</code> build setting defined in `Pods/Target Support Files/Pods-Runner/Pods-Runner.profile.xcconfig’. This can lead to problems with the CocoaPods installation</h2>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"pod-install-警告梳理\"><a href=\"#pod-install-警告梳理\" class=\"headerlink\" title=\"pod install 警告梳理\"></a>pod install 警告梳理</h1><h2 id=\"Unable-to-read-the-license-file-LICENSE-for-the-spec-HelperModule-0-0-38\"><a href=\"#Unable-to-read-the-license-file-LICENSE-for-the-spec-HelperModule-0-0-38\" class=\"headerlink\" title=\"[!] Unable to read the license file LICENSE for the spec HelperModule (0.0.38)\"></a>[!] Unable to read the license file <code>LICENSE</code> for the spec <code>HelperModule (0.0.38)</code></h2><ul>\n<li>原因：<br>  无法读LICENSE文件，</li>\n</ul>\n<h2 id=\"CocoaPods-did-not-set-the-base-configuration-of-your-project-because-your-project-already-has-a-custom-config-set-In-order-for-CocoaPods-integration-to-work-at-all-please-either-set-the-base-configurations-of-the-target-Runner-to-Target-Support-Files-Pods-Runner-Pods-Runner-betarelease-xcconfig-or-include-the-Target-Support-Files-Pods-Runner-Pods-Runner-betarelease-xcconfig-in-your-build-configuration-Flutter-Release-xcconfig\"><a href=\"#CocoaPods-did-not-set-the-base-configuration-of-your-project-because-your-project-already-has-a-custom-config-set-In-order-for-CocoaPods-integration-to-work-at-all-please-either-set-the-base-configurations-of-the-target-Runner-to-Target-Support-Files-Pods-Runner-Pods-Runner-betarelease-xcconfig-or-include-the-Target-Support-Files-Pods-Runner-Pods-Runner-betarelease-xcconfig-in-your-build-configuration-Flutter-Release-xcconfig\" class=\"headerlink\" title=\"[!] CocoaPods did not set the base configuration of your project because your project already has a custom config set. In order for CocoaPods integration to work at all, please either set the base configurations of the target Runner to Target Support Files/Pods-Runner/Pods-Runner.betarelease.xcconfig or include the Target Support Files/Pods-Runner/Pods-Runner.betarelease.xcconfig in your build configuration (Flutter/Release.xcconfig).\"></a>[!] CocoaPods did not set the base configuration of your project because your project already has a custom config set. In order for CocoaPods integration to work at all, please either set the base configurations of the target <code>Runner</code> to <code>Target Support Files/Pods-Runner/Pods-Runner.betarelease.xcconfig</code> or include the <code>Target Support Files/Pods-Runner/Pods-Runner.betarelease.xcconfig</code> in your build configuration (<code>Flutter/Release.xcconfig</code>).</h2><h2 id=\"The-Runner-Release-target-overrides-the-ALWAYS-EMBED-SWIFT-STANDARD-LIBRARIES-build-setting-defined-in-Pods-Target-Support-Files-Pods-Runner-Pods-Runner-release-xcconfig’-This-can-lead-to-problems-with-the-CocoaPods-installation\"><a href=\"#The-Runner-Release-target-overrides-the-ALWAYS-EMBED-SWIFT-STANDARD-LIBRARIES-build-setting-defined-in-Pods-Target-Support-Files-Pods-Runner-Pods-Runner-release-xcconfig’-This-can-lead-to-problems-with-the-CocoaPods-installation\" class=\"headerlink\" title=\"[!] The Runner [Release] target overrides the ALWAYS_EMBED_SWIFT_STANDARD_LIBRARIES build setting defined in `Pods/Target Support Files/Pods-Runner/Pods-Runner.release.xcconfig’. This can lead to problems with the CocoaPods installation\"></a>[!] The <code>Runner [Release]</code> target overrides the <code>ALWAYS_EMBED_SWIFT_STANDARD_LIBRARIES</code> build setting defined in `Pods/Target Support Files/Pods-Runner/Pods-Runner.release.xcconfig’. This can lead to problems with the CocoaPods installation</h2><pre><code>- Use the `$(inherited)` flag, or\n- Remove the build settings from the target.</code></pre><h2 id=\"Found-multiple-specifications-for-Mantle-1-5-6-Users-bkdevops-cocoapods-repos-master-Specs-5-d-c-Mantle-1-5-6-Mantle-podspec-json-Users-bkdevops-cocoapods-repos-trunk-Specs-5-d-c-Mantle-1-5-6-Mantle-podspec-json\"><a href=\"#Found-multiple-specifications-for-Mantle-1-5-6-Users-bkdevops-cocoapods-repos-master-Specs-5-d-c-Mantle-1-5-6-Mantle-podspec-json-Users-bkdevops-cocoapods-repos-trunk-Specs-5-d-c-Mantle-1-5-6-Mantle-podspec-json\" class=\"headerlink\" title=\"[!] Found multiple specifications for Mantle (1.5.6):- /Users/bkdevops/.cocoapods/repos/master/Specs/5/d/c/Mantle/1.5.6/Mantle.podspec.json- /Users/bkdevops/.cocoapods/repos/trunk/Specs/5/d/c/Mantle/1.5.6/Mantle.podspec.json\"></a>[!] Found multiple specifications for <code>Mantle (1.5.6)</code>:- /Users/bkdevops/.cocoapods/repos/master/Specs/5/d/c/Mantle/1.5.6/Mantle.podspec.json- /Users/bkdevops/.cocoapods/repos/trunk/Specs/5/d/c/Mantle/1.5.6/Mantle.podspec.json</h2><ul>\n<li><p>原因：<br>  源冲突，~/.cocoapods/repos 文件夹下有两个源, 一个叫trunk，一个叫master，这俩源中都有相同的pod库，pod install命令不知道要引用哪个，一般不影响使用，但会提示警告，影响观感。</p>\n</li>\n<li><p>解决:<br>  trunk or master 删掉一个，哪个都行。</p>\n</li>\n</ul>\n<h2 id=\"The-Runner-Profile-target-overrides-the-ALWAYS-EMBED-SWIFT-STANDARD-LIBRARIES-build-setting-defined-in-Pods-Target-Support-Files-Pods-Runner-Pods-Runner-profile-xcconfig’-This-can-lead-to-problems-with-the-CocoaPods-installation\"><a href=\"#The-Runner-Profile-target-overrides-the-ALWAYS-EMBED-SWIFT-STANDARD-LIBRARIES-build-setting-defined-in-Pods-Target-Support-Files-Pods-Runner-Pods-Runner-profile-xcconfig’-This-can-lead-to-problems-with-the-CocoaPods-installation\" class=\"headerlink\" title=\"[!] The Runner [Profile] target overrides the ALWAYS_EMBED_SWIFT_STANDARD_LIBRARIES build setting defined in `Pods/Target Support Files/Pods-Runner/Pods-Runner.profile.xcconfig’. This can lead to problems with the CocoaPods installation\"></a>[!] The <code>Runner [Profile]</code> target overrides the <code>ALWAYS_EMBED_SWIFT_STANDARD_LIBRARIES</code> build setting defined in `Pods/Target Support Files/Pods-Runner/Pods-Runner.profile.xcconfig’. This can lead to problems with the CocoaPods installation</h2>"},{"title":"arduino 经典开发板引脚图","date":"2020-06-21T06:19:11.000Z","_content":"\n### Arduino Uno 引脚全图\n\n![](https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2020/06/21/15927325596507.jpg)\n\n### Arduino Nano 引脚全图\n\n![40203cfc36975735bddf640b9d8d2313](https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2020/06/21/40203cfc36975735bddf640b9d8d2313.jpeg)\n\n### LCD 1602显示屏 \n![](https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2020/06/21/15927329966113.jpg)\n[参考资料](https://www.cnblogs.com/Bruce_H21/p/11556440.html)\n[参考资料](https://www.basemu.com/create-arduino-and-lcd-controlled-calculator.html)\n\n### DFPlayer Mini mp3模块\n\n![](https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2020/06/21/15927327015325.jpg)\n    [参考资料](https://wiki.dfrobot.com.cn/_SKU_DFR0299_DFPlayer_Mini%E6%A8%A1%E5%9D%97)\n    [参考资料](https://www.ncnynl.com/archives/201606/190.html)\n    \n### 各类板子输入输出电压\n\n**连接** : https://zhuanlan.zhihu.com/p/34624262\n    \n### C4 Proj Code\n\n**GIT** : https://github.com/justinsongtx/BombGame\n","source":"_posts/arduino-经典开发板引脚图.md","raw":"---\ntitle: arduino 经典开发板引脚图\ndate: 2020-06-21 14:19:11\ntags: arduino\n---\n\n### Arduino Uno 引脚全图\n\n![](https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2020/06/21/15927325596507.jpg)\n\n### Arduino Nano 引脚全图\n\n![40203cfc36975735bddf640b9d8d2313](https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2020/06/21/40203cfc36975735bddf640b9d8d2313.jpeg)\n\n### LCD 1602显示屏 \n![](https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2020/06/21/15927329966113.jpg)\n[参考资料](https://www.cnblogs.com/Bruce_H21/p/11556440.html)\n[参考资料](https://www.basemu.com/create-arduino-and-lcd-controlled-calculator.html)\n\n### DFPlayer Mini mp3模块\n\n![](https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2020/06/21/15927327015325.jpg)\n    [参考资料](https://wiki.dfrobot.com.cn/_SKU_DFR0299_DFPlayer_Mini%E6%A8%A1%E5%9D%97)\n    [参考资料](https://www.ncnynl.com/archives/201606/190.html)\n    \n### 各类板子输入输出电压\n\n**连接** : https://zhuanlan.zhihu.com/p/34624262\n    \n### C4 Proj Code\n\n**GIT** : https://github.com/justinsongtx/BombGame\n","slug":"arduino-经典开发板引脚图","published":1,"updated":"2020-06-21T16:02:21.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgyxlisw000d0iu66vtje3vd","content":"<h3 id=\"Arduino-Uno-引脚全图\"><a href=\"#Arduino-Uno-引脚全图\" class=\"headerlink\" title=\"Arduino Uno 引脚全图\"></a>Arduino Uno 引脚全图</h3><p><img src=\"https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2020/06/21/15927325596507.jpg\" alt=\"\"></p>\n<h3 id=\"Arduino-Nano-引脚全图\"><a href=\"#Arduino-Nano-引脚全图\" class=\"headerlink\" title=\"Arduino Nano 引脚全图\"></a>Arduino Nano 引脚全图</h3><p><img src=\"https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2020/06/21/40203cfc36975735bddf640b9d8d2313.jpeg\" alt=\"40203cfc36975735bddf640b9d8d2313\"></p>\n<h3 id=\"LCD-1602显示屏\"><a href=\"#LCD-1602显示屏\" class=\"headerlink\" title=\"LCD 1602显示屏\"></a>LCD 1602显示屏</h3><p><img src=\"https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2020/06/21/15927329966113.jpg\" alt=\"\"><br><a href=\"https://www.cnblogs.com/Bruce_H21/p/11556440.html\" target=\"_blank\" rel=\"noopener\">参考资料</a><br><a href=\"https://www.basemu.com/create-arduino-and-lcd-controlled-calculator.html\" target=\"_blank\" rel=\"noopener\">参考资料</a></p>\n<h3 id=\"DFPlayer-Mini-mp3模块\"><a href=\"#DFPlayer-Mini-mp3模块\" class=\"headerlink\" title=\"DFPlayer Mini mp3模块\"></a>DFPlayer Mini mp3模块</h3><p><img src=\"https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2020/06/21/15927327015325.jpg\" alt=\"\"><br>    <a href=\"https://wiki.dfrobot.com.cn/_SKU_DFR0299_DFPlayer_Mini%E6%A8%A1%E5%9D%97\" target=\"_blank\" rel=\"noopener\">参考资料</a><br>    <a href=\"https://www.ncnynl.com/archives/201606/190.html\" target=\"_blank\" rel=\"noopener\">参考资料</a></p>\n<h3 id=\"各类板子输入输出电压\"><a href=\"#各类板子输入输出电压\" class=\"headerlink\" title=\"各类板子输入输出电压\"></a>各类板子输入输出电压</h3><p><strong>连接</strong> : <a href=\"https://zhuanlan.zhihu.com/p/34624262\" target=\"_blank\" rel=\"noopener\">https://zhuanlan.zhihu.com/p/34624262</a></p>\n<h3 id=\"C4-Proj-Code\"><a href=\"#C4-Proj-Code\" class=\"headerlink\" title=\"C4 Proj Code\"></a>C4 Proj Code</h3><p><strong>GIT</strong> : <a href=\"https://github.com/justinsongtx/BombGame\" target=\"_blank\" rel=\"noopener\">https://github.com/justinsongtx/BombGame</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"Arduino-Uno-引脚全图\"><a href=\"#Arduino-Uno-引脚全图\" class=\"headerlink\" title=\"Arduino Uno 引脚全图\"></a>Arduino Uno 引脚全图</h3><p><img src=\"https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2020/06/21/15927325596507.jpg\" alt=\"\"></p>\n<h3 id=\"Arduino-Nano-引脚全图\"><a href=\"#Arduino-Nano-引脚全图\" class=\"headerlink\" title=\"Arduino Nano 引脚全图\"></a>Arduino Nano 引脚全图</h3><p><img src=\"https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2020/06/21/40203cfc36975735bddf640b9d8d2313.jpeg\" alt=\"40203cfc36975735bddf640b9d8d2313\"></p>\n<h3 id=\"LCD-1602显示屏\"><a href=\"#LCD-1602显示屏\" class=\"headerlink\" title=\"LCD 1602显示屏\"></a>LCD 1602显示屏</h3><p><img src=\"https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2020/06/21/15927329966113.jpg\" alt=\"\"><br><a href=\"https://www.cnblogs.com/Bruce_H21/p/11556440.html\" target=\"_blank\" rel=\"noopener\">参考资料</a><br><a href=\"https://www.basemu.com/create-arduino-and-lcd-controlled-calculator.html\" target=\"_blank\" rel=\"noopener\">参考资料</a></p>\n<h3 id=\"DFPlayer-Mini-mp3模块\"><a href=\"#DFPlayer-Mini-mp3模块\" class=\"headerlink\" title=\"DFPlayer Mini mp3模块\"></a>DFPlayer Mini mp3模块</h3><p><img src=\"https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2020/06/21/15927327015325.jpg\" alt=\"\"><br>    <a href=\"https://wiki.dfrobot.com.cn/_SKU_DFR0299_DFPlayer_Mini%E6%A8%A1%E5%9D%97\" target=\"_blank\" rel=\"noopener\">参考资料</a><br>    <a href=\"https://www.ncnynl.com/archives/201606/190.html\" target=\"_blank\" rel=\"noopener\">参考资料</a></p>\n<h3 id=\"各类板子输入输出电压\"><a href=\"#各类板子输入输出电压\" class=\"headerlink\" title=\"各类板子输入输出电压\"></a>各类板子输入输出电压</h3><p><strong>连接</strong> : <a href=\"https://zhuanlan.zhihu.com/p/34624262\" target=\"_blank\" rel=\"noopener\">https://zhuanlan.zhihu.com/p/34624262</a></p>\n<h3 id=\"C4-Proj-Code\"><a href=\"#C4-Proj-Code\" class=\"headerlink\" title=\"C4 Proj Code\"></a>C4 Proj Code</h3><p><strong>GIT</strong> : <a href=\"https://github.com/justinsongtx/BombGame\" target=\"_blank\" rel=\"noopener\">https://github.com/justinsongtx/BombGame</a></p>\n"},{"title":"xcode历史版本","date":"2020-07-02T12:17:52.000Z","_content":"\nXcode官方安装包:\nhttps://developer.apple.com/download/more/\n\nXcode版本大全：\nhttps://xcodereleases.com/","source":"_posts/xcode历史版本.md","raw":"---\ntitle: xcode历史版本\ndate: 2020-07-02 20:17:52\ntags:\n---\n\nXcode官方安装包:\nhttps://developer.apple.com/download/more/\n\nXcode版本大全：\nhttps://xcodereleases.com/","slug":"xcode历史版本","published":1,"updated":"2020-08-13T17:52:32.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgyxlisw000e0iu6766k1omh","content":"<p>Xcode官方安装包:<br><a href=\"https://developer.apple.com/download/more/\" target=\"_blank\" rel=\"noopener\">https://developer.apple.com/download/more/</a></p>\n<p>Xcode版本大全：<br><a href=\"https://xcodereleases.com/\" target=\"_blank\" rel=\"noopener\">https://xcodereleases.com/</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Xcode官方安装包:<br><a href=\"https://developer.apple.com/download/more/\" target=\"_blank\" rel=\"noopener\">https://developer.apple.com/download/more/</a></p>\n<p>Xcode版本大全：<br><a href=\"https://xcodereleases.com/\" target=\"_blank\" rel=\"noopener\">https://xcodereleases.com/</a></p>\n"},{"title":"iOS各种设备唯一标识符","date":"2020-07-14T07:05:12.000Z","_content":"\n\n**IMEI**：iOS 5 之后被禁止。写在主板上，重装APP不会改变。\n\n**IDFA**：于iOS 6 时面世，可以监控广告效果，同时保证用户设备不被APP追踪的折中方案。可能发生变化，如系统重置、在设置里还原广告标识符。用户可以在设置里打开“限制广告跟踪”。\n\n**mac地址**：硬件标识符，包括WiFi mac地址和蓝牙mac地址。iOS 7 之后被禁止（同时禁止的还有OpenUDID）。\n\n**UDID**：用来标示设备的唯一性 。iOS 6 之后被禁止获取系统原生的UDID，但可以通过uuid，写入到钥匙串中，从而获得自定义的UDID（非系统原生），即使用户重装APP，只要每次都取这个钥匙串返回，就是不变的。\n\n**UUID**：APP重装后会改变。","source":"_posts/iOS各种设备唯一标识符.md","raw":"---\ntitle: iOS各种设备唯一标识符\ndate: 2020-07-14 15:05:12\ntags:\n---\n\n\n**IMEI**：iOS 5 之后被禁止。写在主板上，重装APP不会改变。\n\n**IDFA**：于iOS 6 时面世，可以监控广告效果，同时保证用户设备不被APP追踪的折中方案。可能发生变化，如系统重置、在设置里还原广告标识符。用户可以在设置里打开“限制广告跟踪”。\n\n**mac地址**：硬件标识符，包括WiFi mac地址和蓝牙mac地址。iOS 7 之后被禁止（同时禁止的还有OpenUDID）。\n\n**UDID**：用来标示设备的唯一性 。iOS 6 之后被禁止获取系统原生的UDID，但可以通过uuid，写入到钥匙串中，从而获得自定义的UDID（非系统原生），即使用户重装APP，只要每次都取这个钥匙串返回，就是不变的。\n\n**UUID**：APP重装后会改变。","slug":"iOS各种设备唯一标识符","published":1,"updated":"2020-08-13T17:52:32.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgyxlisx000g0iu61io8app3","content":"<p><strong>IMEI</strong>：iOS 5 之后被禁止。写在主板上，重装APP不会改变。</p>\n<p><strong>IDFA</strong>：于iOS 6 时面世，可以监控广告效果，同时保证用户设备不被APP追踪的折中方案。可能发生变化，如系统重置、在设置里还原广告标识符。用户可以在设置里打开“限制广告跟踪”。</p>\n<p><strong>mac地址</strong>：硬件标识符，包括WiFi mac地址和蓝牙mac地址。iOS 7 之后被禁止（同时禁止的还有OpenUDID）。</p>\n<p><strong>UDID</strong>：用来标示设备的唯一性 。iOS 6 之后被禁止获取系统原生的UDID，但可以通过uuid，写入到钥匙串中，从而获得自定义的UDID（非系统原生），即使用户重装APP，只要每次都取这个钥匙串返回，就是不变的。</p>\n<p><strong>UUID</strong>：APP重装后会改变。</p>\n","site":{"data":{}},"excerpt":"","more":"<p><strong>IMEI</strong>：iOS 5 之后被禁止。写在主板上，重装APP不会改变。</p>\n<p><strong>IDFA</strong>：于iOS 6 时面世，可以监控广告效果，同时保证用户设备不被APP追踪的折中方案。可能发生变化，如系统重置、在设置里还原广告标识符。用户可以在设置里打开“限制广告跟踪”。</p>\n<p><strong>mac地址</strong>：硬件标识符，包括WiFi mac地址和蓝牙mac地址。iOS 7 之后被禁止（同时禁止的还有OpenUDID）。</p>\n<p><strong>UDID</strong>：用来标示设备的唯一性 。iOS 6 之后被禁止获取系统原生的UDID，但可以通过uuid，写入到钥匙串中，从而获得自定义的UDID（非系统原生），即使用户重装APP，只要每次都取这个钥匙串返回，就是不变的。</p>\n<p><strong>UUID</strong>：APP重装后会改变。</p>\n"},{"title":"sourcetree 跳过登陆注册","date":"2020-07-22T02:27:26.000Z","_content":"\n1. 打开sourcetree\n\n2. 关闭sourcetree\n\n3. 命令终端输入\n\n```\ndefaults write com.torusknot.SourceTreeNotMAS completedWelcomeWizardVersion 3\n```\n\n4. 打开sourcetree即可跳过登录","source":"_posts/sourcetree-跳过登陆注册.md","raw":"---\ntitle: sourcetree 跳过登陆注册\ndate: 2020-07-22 10:27:26\ntags:\n---\n\n1. 打开sourcetree\n\n2. 关闭sourcetree\n\n3. 命令终端输入\n\n```\ndefaults write com.torusknot.SourceTreeNotMAS completedWelcomeWizardVersion 3\n```\n\n4. 打开sourcetree即可跳过登录","slug":"sourcetree-跳过登陆注册","published":1,"updated":"2020-08-13T17:52:32.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgyxlisy000h0iu6a0qn6y2e","content":"<ol>\n<li><p>打开sourcetree</p>\n</li>\n<li><p>关闭sourcetree</p>\n</li>\n<li><p>命令终端输入</p>\n</li>\n</ol>\n<pre><code>defaults write com.torusknot.SourceTreeNotMAS completedWelcomeWizardVersion 3</code></pre><ol start=\"4\">\n<li>打开sourcetree即可跳过登录</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<ol>\n<li><p>打开sourcetree</p>\n</li>\n<li><p>关闭sourcetree</p>\n</li>\n<li><p>命令终端输入</p>\n</li>\n</ol>\n<pre><code>defaults write com.torusknot.SourceTreeNotMAS completedWelcomeWizardVersion 3</code></pre><ol start=\"4\">\n<li>打开sourcetree即可跳过登录</li>\n</ol>\n"},{"_content":"# 一个ios第三方库管理工具--Carthage\n\n","source":"_posts/一个ios第三方库管理工具--Carthage.md","raw":"# 一个ios第三方库管理工具--Carthage\n\n","slug":"一个ios第三方库管理工具--Carthage","published":1,"date":"2020-06-17T11:32:50.000Z","updated":"2020-06-17T11:32:50.000Z","title":"一个ios第三方库管理工具--Carthage","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgyxlisy000i0iu675tpfhc2","content":"<h1 id=\"一个ios第三方库管理工具–Carthage\"><a href=\"#一个ios第三方库管理工具–Carthage\" class=\"headerlink\" title=\"一个ios第三方库管理工具–Carthage\"></a>一个ios第三方库管理工具–Carthage</h1>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"一个ios第三方库管理工具–Carthage\"><a href=\"#一个ios第三方库管理工具–Carthage\" class=\"headerlink\" title=\"一个ios第三方库管理工具–Carthage\"></a>一个ios第三方库管理工具–Carthage</h1>"},{"title":"ios知识梳理","date":"2020-09-06T16:04:17.000Z","_content":"\n# ios知识梳理\n\n## 函数调用发生了什么事？\n![15988664259962](https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2020/09/07/15988664259962.jpg)\n\n\n1. object_sendmsg 发送消息\n2. 对象判空，根据不同返回值返回0 or nil\n3. 用SEL先后在category的methodList，Class的cache， 类对象的methodList中查找IMP，查到就调用\n4. 上面找不到就去superClass里找，实例方法在类对象里向上找，类方法在元类对象里向上找\n5. 找到头还没找到就出发消息转发，有三次处理机会，动态方法解析，快速转发，完整转发，三个环节一个比一个消耗大。\n     * 动态消息转发，给机会用runtime加个同名方法，返回yes就会调用新增的方法，返回no就crash了\n     * 快速转发，转发给除自己以外的其他对象\n     * 完整转发，这个比较麻烦，要先用SEL给方法做个签名，在做转发，优点是可以转发给多个对象，转发的方法也可以自定义，可以用于crash拦截，API版本兼容，实现oc伪多继承\n6. 这都走完还没找到方法就抛出异常\n\n待补充：\n* 参数压栈出栈，存在哪个寄存器\n* 类方法的快速转发和完整转发\n* 多继承如何实现\n* 数据的存储区\n\n\n知识链接：\nhttps://juejin.im/post/6844903600968171533\nhttps://www.jianshu.com/p/f900de4a1495\n\n## KVO底层原理\n\nruntime增加一个子类，动态修改isa指针，将对象指向子类，在子类中使用CoreFoundation中的预埋方法重写setXXX方法，在setXXX前后调用BeforeValueChange和AfterValueChange,记录值的变化，然后通知监听者。\n\n## 内存分配\n\n![](https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2020/09/06/15994047841974.jpg)\n\n程序启动时操作系统会给程序分配一段内存，用于存放程序运行中所需的数据，按存储用途，地址由低到高分为：**代码区**、**常量区**、**全局静态区**、**堆**、**栈**，其中全局静态区分为BSS区和数据区，常量区和全局静态区在有些文章里合称全局数据区。\n\n* 代码区，存放可执行程序的二进制代码\n\n* 常量区，存放静态变量，static，const，字面量\n    ```\n    void main(){\n        char array[] = \"aaa\"; // \"aaa\"存放在栈区的array[]内存上\n        char *point = \"aaa\"; // \"aaa\"存放在常量区\n    }\n    ```\n\n* 全局静态区\n    * BSS区，未初始化的全局变量\n    * 数据区，已初始化的全局变量\n\n* 堆\n    由程序员控制，存放程序运行中，动态分配的内存块，大小不固定，扩展时由地地址向高地址扩展。\n    \n* 栈\n     存放函数的参数，临时变量。\n\n* 地址\n    调试时，指针的值，0x10xxx的就是全局数据区，0x60xxx的就是堆区，0x7fxxxxxx的就是栈区\n    \n\n## 内存管理\n\n* 参考\n    * https://www.jianshu.com/p/48665652e4e4\n    * https://www.jianshu.com/p/7bd2f85f03dc  (牛逼)\n    \n* MRC\n    手动引用计数，谁申请谁释放，但有的时候不知道什么时候释放，例如下面例子，函数不能release返回的对象，也不知道何时该release\n    \n```\n    - （NSString *）newName {\n        NSString *name = [NSString alloc] init];\n        name = @\"123\";\n        return name;\n    }\n```\n\n* 自动释放池\n    针对上面的场景，ios引入了一个新的角色——自动释放池，不知道什么时候该释放的时候可以通过调用autorelease，将对象放入自动释放池，当自动式方池销毁的时候，会向池子中所有的对象发送一条release消息，这时如果对象引用计数变为0，则系统会将对象释放，否则就内存泄露了。\n    \n    调用autorelease把对象放入自动释放池不会增加引用计数。  \n```\nPerson *p = [Person new];\np = [p autorelease];\nNSLog(@\"count = %lu\", [p retainCount]); // 计数还为1\n```\n    * autorelease的创建方法\n        * 使用NSAutoreleasePool来创建\n        \n        ```\n        NSAutoreleasePool *autoreleasePool = [[NSAutoreleasePool alloc] init];\n        Person *p = [[[Person alloc] init] autorelease];\n        [autoreleasePool drain];\n        ```\n       \n        * 使用@autoreleasepool创建    \n        \n        ```\n        @autoreleasepool\n{ // 创建一个自动释放池\n        Person *p = [[Person new] autorelease];\n        // 将代码写到这里就放入了自动释放池\n} // 销毁自动释放池(会给池子中所有对象发送一条release消息)\n        \n        ```\n\n* RunLoop和AutoreleasePool的关系\n\n    主线程的NSRunLoop在监测到事件响应开启每一次event loop之前，会自动创建一个autorelease pool，并且会在event loop结束的时候执行drain操作，释放其中的对象。\n\n* Thread和AutoreleasePool的关系\n\n    包括主线程在内的所有线程都维护有它自己的自动释放池的堆栈结构。新的自动释放池被创建的时候，它们会被添加到栈的顶部，而当池子销毁的时候，会从栈移除。对于当前线程来说，Autoreleased对象会被放到栈顶的自动释放池中。当一个线程线程停止，它会自动释放掉与其关联的所有自动释放池。\n\n* 主线程自动释放池\n![](https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2020/09/07/15994159260554.jpg)\n\n    1. 程序启动到加载完成后，主线程对应的RunLoop会停下来等待用户交互\n    2. 用户的每一次交互都会启动一次运行循环，来处理用户所有的点击事件、触摸事件。\n    3. RunLoop检测到事件后，就会创建自动释放池;\n    4. 所有的延迟释放对象都会被添加到这个池子中;\n    5. 在一次完整的运行循环结束之前，会向池中所有对象发送release消息，然后自动释放池被销毁;\n\n* ARC\n    自动引用计数，在新申请的对象前面默认加入_autorelease\n    \n* 解决循环引用\n    * 主动剪短引用循环，使用弱引用\n    * 使用Xcode静态分析\n    * 使用Insurment中的leak，查看引用循环图\n    * 使用MLLeakFinder\n    \n    \n## RunLoop\n* 资料（牛逼）\n    https://blog.ibireme.com/2015/05/18/runloop/\n* RunLoop包含的5种Mode（模式）\n    * 初始化模式\n    * 默认模式\n    * UI模式\n    * 占位模式\n    * 内核事件模式\n只有默认模式和UI模式能用到，其他都是屁，看看就行\n\n* 每个Mode中有三种对象\n    * Observer\n    * Source\n    * Timer\n\n* 执行流程\n    ![](https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2020/09/07/15994818051599.jpg)\n    \n* 底层实现\n    除了装逼，没其他用，不计了\n    \n## 事件响应\n苹果注册了一个 Source1 (基于 mach port 的) 用来接收系统事件，其回调函数为 __IOHIDEventSystemClientQueueCallback()。\n\n当一个硬件事件(触摸/锁屏/摇晃等)发生后，首先由 IOKit.framework 生成一个 IOHIDEvent 事件并由 SpringBoard 接收。这个过程的详细情况可以参考这里。SpringBoard 只接收按键(锁屏/静音等)，触摸，加速，接近传感器等几种 Event，随后用 mach port 转发给需要的App进程。随后苹果注册的那个 Source1 就会触发回调，并调用 _UIApplicationHandleEventQueue() 进行应用内部的分发。\n\n_UIApplicationHandleEventQueue() 会把 IOHIDEvent 处理并包装成 UIEvent 进行处理或分发，其中包括识别 UIGesture/处理屏幕旋转/发送给 UIWindow 等。通常事件比如 UIButton 点击、touchesBegin/Move/End/Cancel 事件都是在这个回调中完成的。\n\n\n## 手势识别\n当上面的 _UIApplicationHandleEventQueue() 识别了一个手势时，其首先会调用 Cancel 将当前的 touchesBegin/Move/End 系列回调打断。随后系统将对应的 UIGestureRecognizer 标记为待处理。\n\n苹果注册了一个 Observer 监测 BeforeWaiting (Loop即将进入休眠) 事件，这个Observer的回调函数是 _UIGestureRecognizerUpdateObserver()，其内部会获取所有刚被标记为待处理的 GestureRecognizer，并执行GestureRecognizer的回调。\n\n当有 UIGestureRecognizer 的变化(创建/销毁/状态改变)时，这个回调都会进行相应处理。\n\n\n## 界面更新\n当在操作 UI 时，比如改变了 Frame、更新了 UIView/CALayer 的层次时，或者手动调用了 UIView/CALayer 的 setNeedsLayout/setNeedsDisplay方法后，这个 UIView/CALayer 就被标记为待处理，并被提交到一个全局的容器去。\n\n苹果注册了一个 Observer 监听 BeforeWaiting(即将进入休眠) 和 Exit (即将退出Loop) 事件，回调去执行一个很长的函数：\n_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv()。这个函数里会遍历所有待处理的 UIView/CAlayer 以执行实际的绘制和调整，并更新 UI 界面。\n\n## iOS 为什么必须在主线程中操作UI\n\n\n因为UIKit不是线程安全的。试想下面这几种情况：\n\n1. 两个线程同时设置同一个背景图片，那么很有可能因为当前图片被释放了两次而导致应用崩溃。\n\n2. 两个线程同时设置同一个UIView的背景颜色，那么很有可能渲染显示的是颜色A，而此时在UIView逻辑树上的背景颜色属性为B。\n\n3. 两个线程同时操作view的树形结构：在线程A中for循环遍历并操作当前View的所有subView，然后此时线程B中将某个subView直接删除，这就导致了错乱还可能导致应用崩溃。\niOS4之后苹果将大部分绘图的方法和诸如 UIColor 和 UIFont 这样的类改写为了线程安全可用，但是仍然强烈建议讲UI操作保证在主线程中执行。\n\n## CALayer\n\n在iOS当中，所有的视图都从一个叫做UIVIew的基类派生而来，UIView可以处理触摸事件，可以支持基于Core Graphics绘图，可以做仿射变换（例如旋转或者缩放），或者简单的类似于滑动或者渐变的动画。\n\nCALayer类在概念上和UIView类似，同样也是一些被层级关系树管理的矩形块，同样也可以包含一些内容（像图片，文本或者背景色），管理子图层的位置。它们有一些方法和属性用来做动画和变换。和UIView最大的不同是CALayer不处理用户的交互。CALayer并不清楚具体的响应链。\n\nUIView和CALayer是一个平行的层级关系，每一个UIView都有一个CALayer实例的图层属性，也就是所谓的backing layer，视图的职责就是创建并管理这个图层，以确保当子视图在层级关系中添加或者被移除的时候，他们关联的图层也同样对应在层级关系树当中有相同的操作。实际上这些背后关联的Layer图层才是真正用来在屏幕上显示和做动画，UIView仅仅是对它的一个封装，提供了一些iOS类似于处理触摸的具体功能，以及Core Animation底层方法的高级接口。\n\nUIView 的 Layer 在系统内部，被维护着三份同样的树形数据结构，分别是：\n\n* 图层树（这里是代码可以操纵的，设置属性的最终值会立刻在这里更新）；\n\n* 呈现树（是一个中间层，系统就在这一层上更改属性，进行各种渲染操作。比如一个动画是更改alpha值从0到1，那么在逻辑树上此属性会被立刻更新为最终属性1，而在动画树上会根据设置的动画时间从0逐步变化到1）；\n\n* 渲染树（其属性值就是当前正被显示在屏幕上的属性值）；\n\n\n## iOS事件处理与图像渲染（牛逼）\nhttps://www.cnblogs.com/yulang314/p/5091894.html\n\n## weak实现\n\nhttps://www.jianshu.com/p/3c5e335341e0\n\n\n## 默认属性\n* 对应基本数据类型，默认关键字为\natomic, assign, readwrite\n\n* 对应对象类型，默认关键字为\natomic, strong, readwrite\n\n*  atomic 和 nonatomic区别\nhttps://www.jianshu.com/p/7288eacbb1a2\n\n\n## Block原理\nhttps://www.jianshu.com/p/221d0778dcaa\n\n## YUV\nhttps://glumes.com/post/ffmpeg/understand-yuv-format/\n\n## I帧B帧P帧\nhttps://www.cnblogs.com/yongdaimi/p/10676309.html\n\n## H264\nhttps://www.cnblogs.com/Lxk0825/p/9925041.html\n\n## 直播开发大全\nhttps://www.jianshu.com/p/bd42bacbe4cc\n\n## 20分钟OpenGL\nhttps://zhuanlan.zhihu.com/p/56693625\n\n## 自研直播协议（牛逼 详细）\nhttps://yq.aliyun.com/articles/668499\n\n## WebRTC协议\nhttps://blog.csdn.net/moyebaobei1/article/details/86703258\n\n## HLS协议和RTMP协议\nhttps://cloud.tencent.com/developer/article/1509053\n\n## H264(比较全)\nhttps://www.jianshu.com/p/0c296b05ef2a\n\n## App启动耗时优化\n* 启动时间 = pre-main耗时+main耗时\n* pre-main阶段优化：\n    * 删除无用代码\n    * 抽象重复代码\n    * +load方法做的事情延迟到initialize中，或者+load的事情不宜花费太多时间\n    * 减少不必要的framework，或者优化已有framework\n* Main阶段优化\n    * didFinishLauchingwithOptions里代码延后执行\n    * 首次启动渲染的页面优化\n\n## crash防护\n* unrecognized selector crash\n    https://www.jianshu.com/p/6a12e9d92366\n* KVO crash\n    https://www.jianshu.com/p/e3713d309283\n* NSNotification crash\n    https://www.cnblogs.com/Xylophone/p/6394056.html\n* NSTimer crash\n    https://www.cnblogs.com/Xylophone/p/6394076.html\n* Container crash（数组越界，插nil等）\n* NSString crash （字符串操作的crash）\n* Bad Access crash （野指针）\n* UI not on Main Thread Crash (非主线程刷UI (机制待改善))\n\n## 内存泄露问题\n主要集中在循环引用问题中，如block、NSTime、perform selector引用计数问题。\n* 使用Xcode静态分析\n* 使用Insurment中的leak，查看引用循环图\n* 使用MLLeakFinder\n\n## UI卡顿优化\nhttps://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/\n\n* CPU优化\n    * 对象懒加载\n    * Time Profile找出大量耗时的操作\n    * 布局计算，cell(缓存高度，后台线程提前计算布局)，文本布局计算（后台提前计算）\n    * 视图创建消耗（cell复用）\n    * 减少自动布局的使用\n    * 图片解码（后台线程提前解码成Bitmap，不要用JPEG，用PNG）\n* GPU优化\n    * 图片的渲染，tableview里面大量图片（可以将多张图片合成一张，或使用低清晰度的缩略图）\n    * 减少视图混合（减少UIview层级）\n    * 减少离屏渲染，（CALayer 的 border、圆角、阴影、mask都会触发离屏渲染，可以将需要显示的效果在后台绘制成一张图片）\n    \n## GPUImage源码\n\n\n## Opengl ES\n\nhttps://juejin.im/post/6844903843180838920","source":"_posts/ios知识梳理.md","raw":"---\ntitle: ios知识梳理\ndate: 2020-09-07 00:04:17\ntags:\n---\n\n# ios知识梳理\n\n## 函数调用发生了什么事？\n![15988664259962](https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2020/09/07/15988664259962.jpg)\n\n\n1. object_sendmsg 发送消息\n2. 对象判空，根据不同返回值返回0 or nil\n3. 用SEL先后在category的methodList，Class的cache， 类对象的methodList中查找IMP，查到就调用\n4. 上面找不到就去superClass里找，实例方法在类对象里向上找，类方法在元类对象里向上找\n5. 找到头还没找到就出发消息转发，有三次处理机会，动态方法解析，快速转发，完整转发，三个环节一个比一个消耗大。\n     * 动态消息转发，给机会用runtime加个同名方法，返回yes就会调用新增的方法，返回no就crash了\n     * 快速转发，转发给除自己以外的其他对象\n     * 完整转发，这个比较麻烦，要先用SEL给方法做个签名，在做转发，优点是可以转发给多个对象，转发的方法也可以自定义，可以用于crash拦截，API版本兼容，实现oc伪多继承\n6. 这都走完还没找到方法就抛出异常\n\n待补充：\n* 参数压栈出栈，存在哪个寄存器\n* 类方法的快速转发和完整转发\n* 多继承如何实现\n* 数据的存储区\n\n\n知识链接：\nhttps://juejin.im/post/6844903600968171533\nhttps://www.jianshu.com/p/f900de4a1495\n\n## KVO底层原理\n\nruntime增加一个子类，动态修改isa指针，将对象指向子类，在子类中使用CoreFoundation中的预埋方法重写setXXX方法，在setXXX前后调用BeforeValueChange和AfterValueChange,记录值的变化，然后通知监听者。\n\n## 内存分配\n\n![](https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2020/09/06/15994047841974.jpg)\n\n程序启动时操作系统会给程序分配一段内存，用于存放程序运行中所需的数据，按存储用途，地址由低到高分为：**代码区**、**常量区**、**全局静态区**、**堆**、**栈**，其中全局静态区分为BSS区和数据区，常量区和全局静态区在有些文章里合称全局数据区。\n\n* 代码区，存放可执行程序的二进制代码\n\n* 常量区，存放静态变量，static，const，字面量\n    ```\n    void main(){\n        char array[] = \"aaa\"; // \"aaa\"存放在栈区的array[]内存上\n        char *point = \"aaa\"; // \"aaa\"存放在常量区\n    }\n    ```\n\n* 全局静态区\n    * BSS区，未初始化的全局变量\n    * 数据区，已初始化的全局变量\n\n* 堆\n    由程序员控制，存放程序运行中，动态分配的内存块，大小不固定，扩展时由地地址向高地址扩展。\n    \n* 栈\n     存放函数的参数，临时变量。\n\n* 地址\n    调试时，指针的值，0x10xxx的就是全局数据区，0x60xxx的就是堆区，0x7fxxxxxx的就是栈区\n    \n\n## 内存管理\n\n* 参考\n    * https://www.jianshu.com/p/48665652e4e4\n    * https://www.jianshu.com/p/7bd2f85f03dc  (牛逼)\n    \n* MRC\n    手动引用计数，谁申请谁释放，但有的时候不知道什么时候释放，例如下面例子，函数不能release返回的对象，也不知道何时该release\n    \n```\n    - （NSString *）newName {\n        NSString *name = [NSString alloc] init];\n        name = @\"123\";\n        return name;\n    }\n```\n\n* 自动释放池\n    针对上面的场景，ios引入了一个新的角色——自动释放池，不知道什么时候该释放的时候可以通过调用autorelease，将对象放入自动释放池，当自动式方池销毁的时候，会向池子中所有的对象发送一条release消息，这时如果对象引用计数变为0，则系统会将对象释放，否则就内存泄露了。\n    \n    调用autorelease把对象放入自动释放池不会增加引用计数。  \n```\nPerson *p = [Person new];\np = [p autorelease];\nNSLog(@\"count = %lu\", [p retainCount]); // 计数还为1\n```\n    * autorelease的创建方法\n        * 使用NSAutoreleasePool来创建\n        \n        ```\n        NSAutoreleasePool *autoreleasePool = [[NSAutoreleasePool alloc] init];\n        Person *p = [[[Person alloc] init] autorelease];\n        [autoreleasePool drain];\n        ```\n       \n        * 使用@autoreleasepool创建    \n        \n        ```\n        @autoreleasepool\n{ // 创建一个自动释放池\n        Person *p = [[Person new] autorelease];\n        // 将代码写到这里就放入了自动释放池\n} // 销毁自动释放池(会给池子中所有对象发送一条release消息)\n        \n        ```\n\n* RunLoop和AutoreleasePool的关系\n\n    主线程的NSRunLoop在监测到事件响应开启每一次event loop之前，会自动创建一个autorelease pool，并且会在event loop结束的时候执行drain操作，释放其中的对象。\n\n* Thread和AutoreleasePool的关系\n\n    包括主线程在内的所有线程都维护有它自己的自动释放池的堆栈结构。新的自动释放池被创建的时候，它们会被添加到栈的顶部，而当池子销毁的时候，会从栈移除。对于当前线程来说，Autoreleased对象会被放到栈顶的自动释放池中。当一个线程线程停止，它会自动释放掉与其关联的所有自动释放池。\n\n* 主线程自动释放池\n![](https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2020/09/07/15994159260554.jpg)\n\n    1. 程序启动到加载完成后，主线程对应的RunLoop会停下来等待用户交互\n    2. 用户的每一次交互都会启动一次运行循环，来处理用户所有的点击事件、触摸事件。\n    3. RunLoop检测到事件后，就会创建自动释放池;\n    4. 所有的延迟释放对象都会被添加到这个池子中;\n    5. 在一次完整的运行循环结束之前，会向池中所有对象发送release消息，然后自动释放池被销毁;\n\n* ARC\n    自动引用计数，在新申请的对象前面默认加入_autorelease\n    \n* 解决循环引用\n    * 主动剪短引用循环，使用弱引用\n    * 使用Xcode静态分析\n    * 使用Insurment中的leak，查看引用循环图\n    * 使用MLLeakFinder\n    \n    \n## RunLoop\n* 资料（牛逼）\n    https://blog.ibireme.com/2015/05/18/runloop/\n* RunLoop包含的5种Mode（模式）\n    * 初始化模式\n    * 默认模式\n    * UI模式\n    * 占位模式\n    * 内核事件模式\n只有默认模式和UI模式能用到，其他都是屁，看看就行\n\n* 每个Mode中有三种对象\n    * Observer\n    * Source\n    * Timer\n\n* 执行流程\n    ![](https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2020/09/07/15994818051599.jpg)\n    \n* 底层实现\n    除了装逼，没其他用，不计了\n    \n## 事件响应\n苹果注册了一个 Source1 (基于 mach port 的) 用来接收系统事件，其回调函数为 __IOHIDEventSystemClientQueueCallback()。\n\n当一个硬件事件(触摸/锁屏/摇晃等)发生后，首先由 IOKit.framework 生成一个 IOHIDEvent 事件并由 SpringBoard 接收。这个过程的详细情况可以参考这里。SpringBoard 只接收按键(锁屏/静音等)，触摸，加速，接近传感器等几种 Event，随后用 mach port 转发给需要的App进程。随后苹果注册的那个 Source1 就会触发回调，并调用 _UIApplicationHandleEventQueue() 进行应用内部的分发。\n\n_UIApplicationHandleEventQueue() 会把 IOHIDEvent 处理并包装成 UIEvent 进行处理或分发，其中包括识别 UIGesture/处理屏幕旋转/发送给 UIWindow 等。通常事件比如 UIButton 点击、touchesBegin/Move/End/Cancel 事件都是在这个回调中完成的。\n\n\n## 手势识别\n当上面的 _UIApplicationHandleEventQueue() 识别了一个手势时，其首先会调用 Cancel 将当前的 touchesBegin/Move/End 系列回调打断。随后系统将对应的 UIGestureRecognizer 标记为待处理。\n\n苹果注册了一个 Observer 监测 BeforeWaiting (Loop即将进入休眠) 事件，这个Observer的回调函数是 _UIGestureRecognizerUpdateObserver()，其内部会获取所有刚被标记为待处理的 GestureRecognizer，并执行GestureRecognizer的回调。\n\n当有 UIGestureRecognizer 的变化(创建/销毁/状态改变)时，这个回调都会进行相应处理。\n\n\n## 界面更新\n当在操作 UI 时，比如改变了 Frame、更新了 UIView/CALayer 的层次时，或者手动调用了 UIView/CALayer 的 setNeedsLayout/setNeedsDisplay方法后，这个 UIView/CALayer 就被标记为待处理，并被提交到一个全局的容器去。\n\n苹果注册了一个 Observer 监听 BeforeWaiting(即将进入休眠) 和 Exit (即将退出Loop) 事件，回调去执行一个很长的函数：\n_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv()。这个函数里会遍历所有待处理的 UIView/CAlayer 以执行实际的绘制和调整，并更新 UI 界面。\n\n## iOS 为什么必须在主线程中操作UI\n\n\n因为UIKit不是线程安全的。试想下面这几种情况：\n\n1. 两个线程同时设置同一个背景图片，那么很有可能因为当前图片被释放了两次而导致应用崩溃。\n\n2. 两个线程同时设置同一个UIView的背景颜色，那么很有可能渲染显示的是颜色A，而此时在UIView逻辑树上的背景颜色属性为B。\n\n3. 两个线程同时操作view的树形结构：在线程A中for循环遍历并操作当前View的所有subView，然后此时线程B中将某个subView直接删除，这就导致了错乱还可能导致应用崩溃。\niOS4之后苹果将大部分绘图的方法和诸如 UIColor 和 UIFont 这样的类改写为了线程安全可用，但是仍然强烈建议讲UI操作保证在主线程中执行。\n\n## CALayer\n\n在iOS当中，所有的视图都从一个叫做UIVIew的基类派生而来，UIView可以处理触摸事件，可以支持基于Core Graphics绘图，可以做仿射变换（例如旋转或者缩放），或者简单的类似于滑动或者渐变的动画。\n\nCALayer类在概念上和UIView类似，同样也是一些被层级关系树管理的矩形块，同样也可以包含一些内容（像图片，文本或者背景色），管理子图层的位置。它们有一些方法和属性用来做动画和变换。和UIView最大的不同是CALayer不处理用户的交互。CALayer并不清楚具体的响应链。\n\nUIView和CALayer是一个平行的层级关系，每一个UIView都有一个CALayer实例的图层属性，也就是所谓的backing layer，视图的职责就是创建并管理这个图层，以确保当子视图在层级关系中添加或者被移除的时候，他们关联的图层也同样对应在层级关系树当中有相同的操作。实际上这些背后关联的Layer图层才是真正用来在屏幕上显示和做动画，UIView仅仅是对它的一个封装，提供了一些iOS类似于处理触摸的具体功能，以及Core Animation底层方法的高级接口。\n\nUIView 的 Layer 在系统内部，被维护着三份同样的树形数据结构，分别是：\n\n* 图层树（这里是代码可以操纵的，设置属性的最终值会立刻在这里更新）；\n\n* 呈现树（是一个中间层，系统就在这一层上更改属性，进行各种渲染操作。比如一个动画是更改alpha值从0到1，那么在逻辑树上此属性会被立刻更新为最终属性1，而在动画树上会根据设置的动画时间从0逐步变化到1）；\n\n* 渲染树（其属性值就是当前正被显示在屏幕上的属性值）；\n\n\n## iOS事件处理与图像渲染（牛逼）\nhttps://www.cnblogs.com/yulang314/p/5091894.html\n\n## weak实现\n\nhttps://www.jianshu.com/p/3c5e335341e0\n\n\n## 默认属性\n* 对应基本数据类型，默认关键字为\natomic, assign, readwrite\n\n* 对应对象类型，默认关键字为\natomic, strong, readwrite\n\n*  atomic 和 nonatomic区别\nhttps://www.jianshu.com/p/7288eacbb1a2\n\n\n## Block原理\nhttps://www.jianshu.com/p/221d0778dcaa\n\n## YUV\nhttps://glumes.com/post/ffmpeg/understand-yuv-format/\n\n## I帧B帧P帧\nhttps://www.cnblogs.com/yongdaimi/p/10676309.html\n\n## H264\nhttps://www.cnblogs.com/Lxk0825/p/9925041.html\n\n## 直播开发大全\nhttps://www.jianshu.com/p/bd42bacbe4cc\n\n## 20分钟OpenGL\nhttps://zhuanlan.zhihu.com/p/56693625\n\n## 自研直播协议（牛逼 详细）\nhttps://yq.aliyun.com/articles/668499\n\n## WebRTC协议\nhttps://blog.csdn.net/moyebaobei1/article/details/86703258\n\n## HLS协议和RTMP协议\nhttps://cloud.tencent.com/developer/article/1509053\n\n## H264(比较全)\nhttps://www.jianshu.com/p/0c296b05ef2a\n\n## App启动耗时优化\n* 启动时间 = pre-main耗时+main耗时\n* pre-main阶段优化：\n    * 删除无用代码\n    * 抽象重复代码\n    * +load方法做的事情延迟到initialize中，或者+load的事情不宜花费太多时间\n    * 减少不必要的framework，或者优化已有framework\n* Main阶段优化\n    * didFinishLauchingwithOptions里代码延后执行\n    * 首次启动渲染的页面优化\n\n## crash防护\n* unrecognized selector crash\n    https://www.jianshu.com/p/6a12e9d92366\n* KVO crash\n    https://www.jianshu.com/p/e3713d309283\n* NSNotification crash\n    https://www.cnblogs.com/Xylophone/p/6394056.html\n* NSTimer crash\n    https://www.cnblogs.com/Xylophone/p/6394076.html\n* Container crash（数组越界，插nil等）\n* NSString crash （字符串操作的crash）\n* Bad Access crash （野指针）\n* UI not on Main Thread Crash (非主线程刷UI (机制待改善))\n\n## 内存泄露问题\n主要集中在循环引用问题中，如block、NSTime、perform selector引用计数问题。\n* 使用Xcode静态分析\n* 使用Insurment中的leak，查看引用循环图\n* 使用MLLeakFinder\n\n## UI卡顿优化\nhttps://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/\n\n* CPU优化\n    * 对象懒加载\n    * Time Profile找出大量耗时的操作\n    * 布局计算，cell(缓存高度，后台线程提前计算布局)，文本布局计算（后台提前计算）\n    * 视图创建消耗（cell复用）\n    * 减少自动布局的使用\n    * 图片解码（后台线程提前解码成Bitmap，不要用JPEG，用PNG）\n* GPU优化\n    * 图片的渲染，tableview里面大量图片（可以将多张图片合成一张，或使用低清晰度的缩略图）\n    * 减少视图混合（减少UIview层级）\n    * 减少离屏渲染，（CALayer 的 border、圆角、阴影、mask都会触发离屏渲染，可以将需要显示的效果在后台绘制成一张图片）\n    \n## GPUImage源码\n\n\n## Opengl ES\n\nhttps://juejin.im/post/6844903843180838920","slug":"ios知识梳理","published":1,"updated":"2020-09-20T17:24:19.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgyxlisz000j0iu69vjg0ucv","content":"<h1 id=\"ios知识梳理\"><a href=\"#ios知识梳理\" class=\"headerlink\" title=\"ios知识梳理\"></a>ios知识梳理</h1><h2 id=\"函数调用发生了什么事？\"><a href=\"#函数调用发生了什么事？\" class=\"headerlink\" title=\"函数调用发生了什么事？\"></a>函数调用发生了什么事？</h2><p><img src=\"https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2020/09/07/15988664259962.jpg\" alt=\"15988664259962\"></p>\n<ol>\n<li>object_sendmsg 发送消息</li>\n<li>对象判空，根据不同返回值返回0 or nil</li>\n<li>用SEL先后在category的methodList，Class的cache， 类对象的methodList中查找IMP，查到就调用</li>\n<li>上面找不到就去superClass里找，实例方法在类对象里向上找，类方法在元类对象里向上找</li>\n<li>找到头还没找到就出发消息转发，有三次处理机会，动态方法解析，快速转发，完整转发，三个环节一个比一个消耗大。<ul>\n<li>动态消息转发，给机会用runtime加个同名方法，返回yes就会调用新增的方法，返回no就crash了</li>\n<li>快速转发，转发给除自己以外的其他对象</li>\n<li>完整转发，这个比较麻烦，要先用SEL给方法做个签名，在做转发，优点是可以转发给多个对象，转发的方法也可以自定义，可以用于crash拦截，API版本兼容，实现oc伪多继承</li>\n</ul>\n</li>\n<li>这都走完还没找到方法就抛出异常</li>\n</ol>\n<p>待补充：</p>\n<ul>\n<li>参数压栈出栈，存在哪个寄存器</li>\n<li>类方法的快速转发和完整转发</li>\n<li>多继承如何实现</li>\n<li>数据的存储区</li>\n</ul>\n<p>知识链接：<br><a href=\"https://juejin.im/post/6844903600968171533\" target=\"_blank\" rel=\"noopener\">https://juejin.im/post/6844903600968171533</a><br><a href=\"https://www.jianshu.com/p/f900de4a1495\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/f900de4a1495</a></p>\n<h2 id=\"KVO底层原理\"><a href=\"#KVO底层原理\" class=\"headerlink\" title=\"KVO底层原理\"></a>KVO底层原理</h2><p>runtime增加一个子类，动态修改isa指针，将对象指向子类，在子类中使用CoreFoundation中的预埋方法重写setXXX方法，在setXXX前后调用BeforeValueChange和AfterValueChange,记录值的变化，然后通知监听者。</p>\n<h2 id=\"内存分配\"><a href=\"#内存分配\" class=\"headerlink\" title=\"内存分配\"></a>内存分配</h2><p><img src=\"https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2020/09/06/15994047841974.jpg\" alt=\"\"></p>\n<p>程序启动时操作系统会给程序分配一段内存，用于存放程序运行中所需的数据，按存储用途，地址由低到高分为：<strong>代码区</strong>、<strong>常量区</strong>、<strong>全局静态区</strong>、<strong>堆</strong>、<strong>栈</strong>，其中全局静态区分为BSS区和数据区，常量区和全局静态区在有些文章里合称全局数据区。</p>\n<ul>\n<li><p>代码区，存放可执行程序的二进制代码</p>\n</li>\n<li><p>常量区，存放静态变量，static，const，字面量</p>\n<pre><code>  void main(){\n      char array[] = &quot;aaa&quot;; // &quot;aaa&quot;存放在栈区的array[]内存上\n      char *point = &quot;aaa&quot;; // &quot;aaa&quot;存放在常量区\n  }</code></pre></li>\n<li><p>全局静态区</p>\n<ul>\n<li>BSS区，未初始化的全局变量</li>\n<li>数据区，已初始化的全局变量</li>\n</ul>\n</li>\n<li><p>堆<br>  由程序员控制，存放程序运行中，动态分配的内存块，大小不固定，扩展时由地地址向高地址扩展。</p>\n</li>\n<li><p>栈<br>   存放函数的参数，临时变量。</p>\n</li>\n<li><p>地址<br>  调试时，指针的值，0x10xxx的就是全局数据区，0x60xxx的就是堆区，0x7fxxxxxx的就是栈区</p>\n</li>\n</ul>\n<h2 id=\"内存管理\"><a href=\"#内存管理\" class=\"headerlink\" title=\"内存管理\"></a>内存管理</h2><ul>\n<li><p>参考</p>\n<ul>\n<li><a href=\"https://www.jianshu.com/p/48665652e4e4\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/48665652e4e4</a></li>\n<li><a href=\"https://www.jianshu.com/p/7bd2f85f03dc\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/7bd2f85f03dc</a>  (牛逼)</li>\n</ul>\n</li>\n<li><p>MRC<br>  手动引用计数，谁申请谁释放，但有的时候不知道什么时候释放，例如下面例子，函数不能release返回的对象，也不知道何时该release</p>\n</li>\n</ul>\n<pre><code>    - （NSString *）newName {\n        NSString *name = [NSString alloc] init];\n        name = @&quot;123&quot;;\n        return name;\n    }</code></pre><ul>\n<li><p>自动释放池<br>  针对上面的场景，ios引入了一个新的角色——自动释放池，不知道什么时候该释放的时候可以通过调用autorelease，将对象放入自动释放池，当自动式方池销毁的时候，会向池子中所有的对象发送一条release消息，这时如果对象引用计数变为0，则系统会将对象释放，否则就内存泄露了。</p>\n<p>  调用autorelease把对象放入自动释放池不会增加引用计数。  </p>\n<pre><code>Person *p = [Person new];\np = [p autorelease];\nNSLog(@&quot;count = %lu&quot;, [p retainCount]); // 计数还为1</code></pre><ul>\n<li><p>autorelease的创建方法</p>\n<ul>\n<li><p>使用NSAutoreleasePool来创建</p>\n<pre><code>NSAutoreleasePool *autoreleasePool = [[NSAutoreleasePool alloc] init];\nPerson *p = [[[Person alloc] init] autorelease];\n[autoreleasePool drain];</code></pre></li>\n<li><p>使用@autoreleasepool创建    </p>\n<pre><code>@autoreleasepool\n{ // 创建一个自动释放池\nPerson *p = [[Person new] autorelease];\n// 将代码写到这里就放入了自动释放池\n} // 销毁自动释放池(会给池子中所有对象发送一条release消息)\n</code></pre></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>RunLoop和AutoreleasePool的关系</p>\n<p>  主线程的NSRunLoop在监测到事件响应开启每一次event loop之前，会自动创建一个autorelease pool，并且会在event loop结束的时候执行drain操作，释放其中的对象。</p>\n</li>\n<li><p>Thread和AutoreleasePool的关系</p>\n<p>  包括主线程在内的所有线程都维护有它自己的自动释放池的堆栈结构。新的自动释放池被创建的时候，它们会被添加到栈的顶部，而当池子销毁的时候，会从栈移除。对于当前线程来说，Autoreleased对象会被放到栈顶的自动释放池中。当一个线程线程停止，它会自动释放掉与其关联的所有自动释放池。</p>\n</li>\n<li><p>主线程自动释放池<br><img src=\"https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2020/09/07/15994159260554.jpg\" alt=\"\"></p>\n<ol>\n<li>程序启动到加载完成后，主线程对应的RunLoop会停下来等待用户交互</li>\n<li>用户的每一次交互都会启动一次运行循环，来处理用户所有的点击事件、触摸事件。</li>\n<li>RunLoop检测到事件后，就会创建自动释放池;</li>\n<li>所有的延迟释放对象都会被添加到这个池子中;</li>\n<li>在一次完整的运行循环结束之前，会向池中所有对象发送release消息，然后自动释放池被销毁;</li>\n</ol>\n</li>\n<li><p>ARC<br>  自动引用计数，在新申请的对象前面默认加入_autorelease</p>\n</li>\n<li><p>解决循环引用</p>\n<ul>\n<li>主动剪短引用循环，使用弱引用</li>\n<li>使用Xcode静态分析</li>\n<li>使用Insurment中的leak，查看引用循环图</li>\n<li>使用MLLeakFinder</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"RunLoop\"><a href=\"#RunLoop\" class=\"headerlink\" title=\"RunLoop\"></a>RunLoop</h2><ul>\n<li><p>资料（牛逼）<br>  <a href=\"https://blog.ibireme.com/2015/05/18/runloop/\" target=\"_blank\" rel=\"noopener\">https://blog.ibireme.com/2015/05/18/runloop/</a></p>\n</li>\n<li><p>RunLoop包含的5种Mode（模式）</p>\n<ul>\n<li>初始化模式</li>\n<li>默认模式</li>\n<li>UI模式</li>\n<li>占位模式</li>\n<li>内核事件模式<br>只有默认模式和UI模式能用到，其他都是屁，看看就行</li>\n</ul>\n</li>\n<li><p>每个Mode中有三种对象</p>\n<ul>\n<li>Observer</li>\n<li>Source</li>\n<li>Timer</li>\n</ul>\n</li>\n<li><p>执行流程<br>  <img src=\"https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2020/09/07/15994818051599.jpg\" alt=\"\"></p>\n</li>\n<li><p>底层实现<br>  除了装逼，没其他用，不计了</p>\n</li>\n</ul>\n<h2 id=\"事件响应\"><a href=\"#事件响应\" class=\"headerlink\" title=\"事件响应\"></a>事件响应</h2><p>苹果注册了一个 Source1 (基于 mach port 的) 用来接收系统事件，其回调函数为 __IOHIDEventSystemClientQueueCallback()。</p>\n<p>当一个硬件事件(触摸/锁屏/摇晃等)发生后，首先由 IOKit.framework 生成一个 IOHIDEvent 事件并由 SpringBoard 接收。这个过程的详细情况可以参考这里。SpringBoard 只接收按键(锁屏/静音等)，触摸，加速，接近传感器等几种 Event，随后用 mach port 转发给需要的App进程。随后苹果注册的那个 Source1 就会触发回调，并调用 _UIApplicationHandleEventQueue() 进行应用内部的分发。</p>\n<p>_UIApplicationHandleEventQueue() 会把 IOHIDEvent 处理并包装成 UIEvent 进行处理或分发，其中包括识别 UIGesture/处理屏幕旋转/发送给 UIWindow 等。通常事件比如 UIButton 点击、touchesBegin/Move/End/Cancel 事件都是在这个回调中完成的。</p>\n<h2 id=\"手势识别\"><a href=\"#手势识别\" class=\"headerlink\" title=\"手势识别\"></a>手势识别</h2><p>当上面的 _UIApplicationHandleEventQueue() 识别了一个手势时，其首先会调用 Cancel 将当前的 touchesBegin/Move/End 系列回调打断。随后系统将对应的 UIGestureRecognizer 标记为待处理。</p>\n<p>苹果注册了一个 Observer 监测 BeforeWaiting (Loop即将进入休眠) 事件，这个Observer的回调函数是 _UIGestureRecognizerUpdateObserver()，其内部会获取所有刚被标记为待处理的 GestureRecognizer，并执行GestureRecognizer的回调。</p>\n<p>当有 UIGestureRecognizer 的变化(创建/销毁/状态改变)时，这个回调都会进行相应处理。</p>\n<h2 id=\"界面更新\"><a href=\"#界面更新\" class=\"headerlink\" title=\"界面更新\"></a>界面更新</h2><p>当在操作 UI 时，比如改变了 Frame、更新了 UIView/CALayer 的层次时，或者手动调用了 UIView/CALayer 的 setNeedsLayout/setNeedsDisplay方法后，这个 UIView/CALayer 就被标记为待处理，并被提交到一个全局的容器去。</p>\n<p>苹果注册了一个 Observer 监听 BeforeWaiting(即将进入休眠) 和 Exit (即将退出Loop) 事件，回调去执行一个很长的函数：<br>_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv()。这个函数里会遍历所有待处理的 UIView/CAlayer 以执行实际的绘制和调整，并更新 UI 界面。</p>\n<h2 id=\"iOS-为什么必须在主线程中操作UI\"><a href=\"#iOS-为什么必须在主线程中操作UI\" class=\"headerlink\" title=\"iOS 为什么必须在主线程中操作UI\"></a>iOS 为什么必须在主线程中操作UI</h2><p>因为UIKit不是线程安全的。试想下面这几种情况：</p>\n<ol>\n<li><p>两个线程同时设置同一个背景图片，那么很有可能因为当前图片被释放了两次而导致应用崩溃。</p>\n</li>\n<li><p>两个线程同时设置同一个UIView的背景颜色，那么很有可能渲染显示的是颜色A，而此时在UIView逻辑树上的背景颜色属性为B。</p>\n</li>\n<li><p>两个线程同时操作view的树形结构：在线程A中for循环遍历并操作当前View的所有subView，然后此时线程B中将某个subView直接删除，这就导致了错乱还可能导致应用崩溃。<br>iOS4之后苹果将大部分绘图的方法和诸如 UIColor 和 UIFont 这样的类改写为了线程安全可用，但是仍然强烈建议讲UI操作保证在主线程中执行。</p>\n</li>\n</ol>\n<h2 id=\"CALayer\"><a href=\"#CALayer\" class=\"headerlink\" title=\"CALayer\"></a>CALayer</h2><p>在iOS当中，所有的视图都从一个叫做UIVIew的基类派生而来，UIView可以处理触摸事件，可以支持基于Core Graphics绘图，可以做仿射变换（例如旋转或者缩放），或者简单的类似于滑动或者渐变的动画。</p>\n<p>CALayer类在概念上和UIView类似，同样也是一些被层级关系树管理的矩形块，同样也可以包含一些内容（像图片，文本或者背景色），管理子图层的位置。它们有一些方法和属性用来做动画和变换。和UIView最大的不同是CALayer不处理用户的交互。CALayer并不清楚具体的响应链。</p>\n<p>UIView和CALayer是一个平行的层级关系，每一个UIView都有一个CALayer实例的图层属性，也就是所谓的backing layer，视图的职责就是创建并管理这个图层，以确保当子视图在层级关系中添加或者被移除的时候，他们关联的图层也同样对应在层级关系树当中有相同的操作。实际上这些背后关联的Layer图层才是真正用来在屏幕上显示和做动画，UIView仅仅是对它的一个封装，提供了一些iOS类似于处理触摸的具体功能，以及Core Animation底层方法的高级接口。</p>\n<p>UIView 的 Layer 在系统内部，被维护着三份同样的树形数据结构，分别是：</p>\n<ul>\n<li><p>图层树（这里是代码可以操纵的，设置属性的最终值会立刻在这里更新）；</p>\n</li>\n<li><p>呈现树（是一个中间层，系统就在这一层上更改属性，进行各种渲染操作。比如一个动画是更改alpha值从0到1，那么在逻辑树上此属性会被立刻更新为最终属性1，而在动画树上会根据设置的动画时间从0逐步变化到1）；</p>\n</li>\n<li><p>渲染树（其属性值就是当前正被显示在屏幕上的属性值）；</p>\n</li>\n</ul>\n<h2 id=\"iOS事件处理与图像渲染（牛逼）\"><a href=\"#iOS事件处理与图像渲染（牛逼）\" class=\"headerlink\" title=\"iOS事件处理与图像渲染（牛逼）\"></a>iOS事件处理与图像渲染（牛逼）</h2><p><a href=\"https://www.cnblogs.com/yulang314/p/5091894.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/yulang314/p/5091894.html</a></p>\n<h2 id=\"weak实现\"><a href=\"#weak实现\" class=\"headerlink\" title=\"weak实现\"></a>weak实现</h2><p><a href=\"https://www.jianshu.com/p/3c5e335341e0\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/3c5e335341e0</a></p>\n<h2 id=\"默认属性\"><a href=\"#默认属性\" class=\"headerlink\" title=\"默认属性\"></a>默认属性</h2><ul>\n<li><p>对应基本数据类型，默认关键字为<br>atomic, assign, readwrite</p>\n</li>\n<li><p>对应对象类型，默认关键字为<br>atomic, strong, readwrite</p>\n</li>\n<li><p>atomic 和 nonatomic区别<br><a href=\"https://www.jianshu.com/p/7288eacbb1a2\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/7288eacbb1a2</a></p>\n</li>\n</ul>\n<h2 id=\"Block原理\"><a href=\"#Block原理\" class=\"headerlink\" title=\"Block原理\"></a>Block原理</h2><p><a href=\"https://www.jianshu.com/p/221d0778dcaa\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/221d0778dcaa</a></p>\n<h2 id=\"YUV\"><a href=\"#YUV\" class=\"headerlink\" title=\"YUV\"></a>YUV</h2><p><a href=\"https://glumes.com/post/ffmpeg/understand-yuv-format/\" target=\"_blank\" rel=\"noopener\">https://glumes.com/post/ffmpeg/understand-yuv-format/</a></p>\n<h2 id=\"I帧B帧P帧\"><a href=\"#I帧B帧P帧\" class=\"headerlink\" title=\"I帧B帧P帧\"></a>I帧B帧P帧</h2><p><a href=\"https://www.cnblogs.com/yongdaimi/p/10676309.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/yongdaimi/p/10676309.html</a></p>\n<h2 id=\"H264\"><a href=\"#H264\" class=\"headerlink\" title=\"H264\"></a>H264</h2><p><a href=\"https://www.cnblogs.com/Lxk0825/p/9925041.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/Lxk0825/p/9925041.html</a></p>\n<h2 id=\"直播开发大全\"><a href=\"#直播开发大全\" class=\"headerlink\" title=\"直播开发大全\"></a>直播开发大全</h2><p><a href=\"https://www.jianshu.com/p/bd42bacbe4cc\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/bd42bacbe4cc</a></p>\n<h2 id=\"20分钟OpenGL\"><a href=\"#20分钟OpenGL\" class=\"headerlink\" title=\"20分钟OpenGL\"></a>20分钟OpenGL</h2><p><a href=\"https://zhuanlan.zhihu.com/p/56693625\" target=\"_blank\" rel=\"noopener\">https://zhuanlan.zhihu.com/p/56693625</a></p>\n<h2 id=\"自研直播协议（牛逼-详细）\"><a href=\"#自研直播协议（牛逼-详细）\" class=\"headerlink\" title=\"自研直播协议（牛逼 详细）\"></a>自研直播协议（牛逼 详细）</h2><p><a href=\"https://yq.aliyun.com/articles/668499\" target=\"_blank\" rel=\"noopener\">https://yq.aliyun.com/articles/668499</a></p>\n<h2 id=\"WebRTC协议\"><a href=\"#WebRTC协议\" class=\"headerlink\" title=\"WebRTC协议\"></a>WebRTC协议</h2><p><a href=\"https://blog.csdn.net/moyebaobei1/article/details/86703258\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/moyebaobei1/article/details/86703258</a></p>\n<h2 id=\"HLS协议和RTMP协议\"><a href=\"#HLS协议和RTMP协议\" class=\"headerlink\" title=\"HLS协议和RTMP协议\"></a>HLS协议和RTMP协议</h2><p><a href=\"https://cloud.tencent.com/developer/article/1509053\" target=\"_blank\" rel=\"noopener\">https://cloud.tencent.com/developer/article/1509053</a></p>\n<h2 id=\"H264-比较全\"><a href=\"#H264-比较全\" class=\"headerlink\" title=\"H264(比较全)\"></a>H264(比较全)</h2><p><a href=\"https://www.jianshu.com/p/0c296b05ef2a\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/0c296b05ef2a</a></p>\n<h2 id=\"App启动耗时优化\"><a href=\"#App启动耗时优化\" class=\"headerlink\" title=\"App启动耗时优化\"></a>App启动耗时优化</h2><ul>\n<li>启动时间 = pre-main耗时+main耗时</li>\n<li>pre-main阶段优化：<ul>\n<li>删除无用代码</li>\n<li>抽象重复代码</li>\n<li>+load方法做的事情延迟到initialize中，或者+load的事情不宜花费太多时间</li>\n<li>减少不必要的framework，或者优化已有framework</li>\n</ul>\n</li>\n<li>Main阶段优化<ul>\n<li>didFinishLauchingwithOptions里代码延后执行</li>\n<li>首次启动渲染的页面优化</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"crash防护\"><a href=\"#crash防护\" class=\"headerlink\" title=\"crash防护\"></a>crash防护</h2><ul>\n<li>unrecognized selector crash<br>  <a href=\"https://www.jianshu.com/p/6a12e9d92366\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/6a12e9d92366</a></li>\n<li>KVO crash<br>  <a href=\"https://www.jianshu.com/p/e3713d309283\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/e3713d309283</a></li>\n<li>NSNotification crash<br>  <a href=\"https://www.cnblogs.com/Xylophone/p/6394056.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/Xylophone/p/6394056.html</a></li>\n<li>NSTimer crash<br>  <a href=\"https://www.cnblogs.com/Xylophone/p/6394076.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/Xylophone/p/6394076.html</a></li>\n<li>Container crash（数组越界，插nil等）</li>\n<li>NSString crash （字符串操作的crash）</li>\n<li>Bad Access crash （野指针）</li>\n<li>UI not on Main Thread Crash (非主线程刷UI (机制待改善))</li>\n</ul>\n<h2 id=\"内存泄露问题\"><a href=\"#内存泄露问题\" class=\"headerlink\" title=\"内存泄露问题\"></a>内存泄露问题</h2><p>主要集中在循环引用问题中，如block、NSTime、perform selector引用计数问题。</p>\n<ul>\n<li>使用Xcode静态分析</li>\n<li>使用Insurment中的leak，查看引用循环图</li>\n<li>使用MLLeakFinder</li>\n</ul>\n<h2 id=\"UI卡顿优化\"><a href=\"#UI卡顿优化\" class=\"headerlink\" title=\"UI卡顿优化\"></a>UI卡顿优化</h2><p><a href=\"https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/\" target=\"_blank\" rel=\"noopener\">https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/</a></p>\n<ul>\n<li>CPU优化<ul>\n<li>对象懒加载</li>\n<li>Time Profile找出大量耗时的操作</li>\n<li>布局计算，cell(缓存高度，后台线程提前计算布局)，文本布局计算（后台提前计算）</li>\n<li>视图创建消耗（cell复用）</li>\n<li>减少自动布局的使用</li>\n<li>图片解码（后台线程提前解码成Bitmap，不要用JPEG，用PNG）</li>\n</ul>\n</li>\n<li>GPU优化<ul>\n<li>图片的渲染，tableview里面大量图片（可以将多张图片合成一张，或使用低清晰度的缩略图）</li>\n<li>减少视图混合（减少UIview层级）</li>\n<li>减少离屏渲染，（CALayer 的 border、圆角、阴影、mask都会触发离屏渲染，可以将需要显示的效果在后台绘制成一张图片）</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"GPUImage源码\"><a href=\"#GPUImage源码\" class=\"headerlink\" title=\"GPUImage源码\"></a>GPUImage源码</h2><h2 id=\"Opengl-ES\"><a href=\"#Opengl-ES\" class=\"headerlink\" title=\"Opengl ES\"></a>Opengl ES</h2><p><a href=\"https://juejin.im/post/6844903843180838920\" target=\"_blank\" rel=\"noopener\">https://juejin.im/post/6844903843180838920</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"ios知识梳理\"><a href=\"#ios知识梳理\" class=\"headerlink\" title=\"ios知识梳理\"></a>ios知识梳理</h1><h2 id=\"函数调用发生了什么事？\"><a href=\"#函数调用发生了什么事？\" class=\"headerlink\" title=\"函数调用发生了什么事？\"></a>函数调用发生了什么事？</h2><p><img src=\"https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2020/09/07/15988664259962.jpg\" alt=\"15988664259962\"></p>\n<ol>\n<li>object_sendmsg 发送消息</li>\n<li>对象判空，根据不同返回值返回0 or nil</li>\n<li>用SEL先后在category的methodList，Class的cache， 类对象的methodList中查找IMP，查到就调用</li>\n<li>上面找不到就去superClass里找，实例方法在类对象里向上找，类方法在元类对象里向上找</li>\n<li>找到头还没找到就出发消息转发，有三次处理机会，动态方法解析，快速转发，完整转发，三个环节一个比一个消耗大。<ul>\n<li>动态消息转发，给机会用runtime加个同名方法，返回yes就会调用新增的方法，返回no就crash了</li>\n<li>快速转发，转发给除自己以外的其他对象</li>\n<li>完整转发，这个比较麻烦，要先用SEL给方法做个签名，在做转发，优点是可以转发给多个对象，转发的方法也可以自定义，可以用于crash拦截，API版本兼容，实现oc伪多继承</li>\n</ul>\n</li>\n<li>这都走完还没找到方法就抛出异常</li>\n</ol>\n<p>待补充：</p>\n<ul>\n<li>参数压栈出栈，存在哪个寄存器</li>\n<li>类方法的快速转发和完整转发</li>\n<li>多继承如何实现</li>\n<li>数据的存储区</li>\n</ul>\n<p>知识链接：<br><a href=\"https://juejin.im/post/6844903600968171533\" target=\"_blank\" rel=\"noopener\">https://juejin.im/post/6844903600968171533</a><br><a href=\"https://www.jianshu.com/p/f900de4a1495\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/f900de4a1495</a></p>\n<h2 id=\"KVO底层原理\"><a href=\"#KVO底层原理\" class=\"headerlink\" title=\"KVO底层原理\"></a>KVO底层原理</h2><p>runtime增加一个子类，动态修改isa指针，将对象指向子类，在子类中使用CoreFoundation中的预埋方法重写setXXX方法，在setXXX前后调用BeforeValueChange和AfterValueChange,记录值的变化，然后通知监听者。</p>\n<h2 id=\"内存分配\"><a href=\"#内存分配\" class=\"headerlink\" title=\"内存分配\"></a>内存分配</h2><p><img src=\"https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2020/09/06/15994047841974.jpg\" alt=\"\"></p>\n<p>程序启动时操作系统会给程序分配一段内存，用于存放程序运行中所需的数据，按存储用途，地址由低到高分为：<strong>代码区</strong>、<strong>常量区</strong>、<strong>全局静态区</strong>、<strong>堆</strong>、<strong>栈</strong>，其中全局静态区分为BSS区和数据区，常量区和全局静态区在有些文章里合称全局数据区。</p>\n<ul>\n<li><p>代码区，存放可执行程序的二进制代码</p>\n</li>\n<li><p>常量区，存放静态变量，static，const，字面量</p>\n<pre><code>  void main(){\n      char array[] = &quot;aaa&quot;; // &quot;aaa&quot;存放在栈区的array[]内存上\n      char *point = &quot;aaa&quot;; // &quot;aaa&quot;存放在常量区\n  }</code></pre></li>\n<li><p>全局静态区</p>\n<ul>\n<li>BSS区，未初始化的全局变量</li>\n<li>数据区，已初始化的全局变量</li>\n</ul>\n</li>\n<li><p>堆<br>  由程序员控制，存放程序运行中，动态分配的内存块，大小不固定，扩展时由地地址向高地址扩展。</p>\n</li>\n<li><p>栈<br>   存放函数的参数，临时变量。</p>\n</li>\n<li><p>地址<br>  调试时，指针的值，0x10xxx的就是全局数据区，0x60xxx的就是堆区，0x7fxxxxxx的就是栈区</p>\n</li>\n</ul>\n<h2 id=\"内存管理\"><a href=\"#内存管理\" class=\"headerlink\" title=\"内存管理\"></a>内存管理</h2><ul>\n<li><p>参考</p>\n<ul>\n<li><a href=\"https://www.jianshu.com/p/48665652e4e4\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/48665652e4e4</a></li>\n<li><a href=\"https://www.jianshu.com/p/7bd2f85f03dc\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/7bd2f85f03dc</a>  (牛逼)</li>\n</ul>\n</li>\n<li><p>MRC<br>  手动引用计数，谁申请谁释放，但有的时候不知道什么时候释放，例如下面例子，函数不能release返回的对象，也不知道何时该release</p>\n</li>\n</ul>\n<pre><code>    - （NSString *）newName {\n        NSString *name = [NSString alloc] init];\n        name = @&quot;123&quot;;\n        return name;\n    }</code></pre><ul>\n<li><p>自动释放池<br>  针对上面的场景，ios引入了一个新的角色——自动释放池，不知道什么时候该释放的时候可以通过调用autorelease，将对象放入自动释放池，当自动式方池销毁的时候，会向池子中所有的对象发送一条release消息，这时如果对象引用计数变为0，则系统会将对象释放，否则就内存泄露了。</p>\n<p>  调用autorelease把对象放入自动释放池不会增加引用计数。  </p>\n<pre><code>Person *p = [Person new];\np = [p autorelease];\nNSLog(@&quot;count = %lu&quot;, [p retainCount]); // 计数还为1</code></pre><ul>\n<li><p>autorelease的创建方法</p>\n<ul>\n<li><p>使用NSAutoreleasePool来创建</p>\n<pre><code>NSAutoreleasePool *autoreleasePool = [[NSAutoreleasePool alloc] init];\nPerson *p = [[[Person alloc] init] autorelease];\n[autoreleasePool drain];</code></pre></li>\n<li><p>使用@autoreleasepool创建    </p>\n<pre><code>@autoreleasepool\n{ // 创建一个自动释放池\nPerson *p = [[Person new] autorelease];\n// 将代码写到这里就放入了自动释放池\n} // 销毁自动释放池(会给池子中所有对象发送一条release消息)\n</code></pre></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>RunLoop和AutoreleasePool的关系</p>\n<p>  主线程的NSRunLoop在监测到事件响应开启每一次event loop之前，会自动创建一个autorelease pool，并且会在event loop结束的时候执行drain操作，释放其中的对象。</p>\n</li>\n<li><p>Thread和AutoreleasePool的关系</p>\n<p>  包括主线程在内的所有线程都维护有它自己的自动释放池的堆栈结构。新的自动释放池被创建的时候，它们会被添加到栈的顶部，而当池子销毁的时候，会从栈移除。对于当前线程来说，Autoreleased对象会被放到栈顶的自动释放池中。当一个线程线程停止，它会自动释放掉与其关联的所有自动释放池。</p>\n</li>\n<li><p>主线程自动释放池<br><img src=\"https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2020/09/07/15994159260554.jpg\" alt=\"\"></p>\n<ol>\n<li>程序启动到加载完成后，主线程对应的RunLoop会停下来等待用户交互</li>\n<li>用户的每一次交互都会启动一次运行循环，来处理用户所有的点击事件、触摸事件。</li>\n<li>RunLoop检测到事件后，就会创建自动释放池;</li>\n<li>所有的延迟释放对象都会被添加到这个池子中;</li>\n<li>在一次完整的运行循环结束之前，会向池中所有对象发送release消息，然后自动释放池被销毁;</li>\n</ol>\n</li>\n<li><p>ARC<br>  自动引用计数，在新申请的对象前面默认加入_autorelease</p>\n</li>\n<li><p>解决循环引用</p>\n<ul>\n<li>主动剪短引用循环，使用弱引用</li>\n<li>使用Xcode静态分析</li>\n<li>使用Insurment中的leak，查看引用循环图</li>\n<li>使用MLLeakFinder</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"RunLoop\"><a href=\"#RunLoop\" class=\"headerlink\" title=\"RunLoop\"></a>RunLoop</h2><ul>\n<li><p>资料（牛逼）<br>  <a href=\"https://blog.ibireme.com/2015/05/18/runloop/\" target=\"_blank\" rel=\"noopener\">https://blog.ibireme.com/2015/05/18/runloop/</a></p>\n</li>\n<li><p>RunLoop包含的5种Mode（模式）</p>\n<ul>\n<li>初始化模式</li>\n<li>默认模式</li>\n<li>UI模式</li>\n<li>占位模式</li>\n<li>内核事件模式<br>只有默认模式和UI模式能用到，其他都是屁，看看就行</li>\n</ul>\n</li>\n<li><p>每个Mode中有三种对象</p>\n<ul>\n<li>Observer</li>\n<li>Source</li>\n<li>Timer</li>\n</ul>\n</li>\n<li><p>执行流程<br>  <img src=\"https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2020/09/07/15994818051599.jpg\" alt=\"\"></p>\n</li>\n<li><p>底层实现<br>  除了装逼，没其他用，不计了</p>\n</li>\n</ul>\n<h2 id=\"事件响应\"><a href=\"#事件响应\" class=\"headerlink\" title=\"事件响应\"></a>事件响应</h2><p>苹果注册了一个 Source1 (基于 mach port 的) 用来接收系统事件，其回调函数为 __IOHIDEventSystemClientQueueCallback()。</p>\n<p>当一个硬件事件(触摸/锁屏/摇晃等)发生后，首先由 IOKit.framework 生成一个 IOHIDEvent 事件并由 SpringBoard 接收。这个过程的详细情况可以参考这里。SpringBoard 只接收按键(锁屏/静音等)，触摸，加速，接近传感器等几种 Event，随后用 mach port 转发给需要的App进程。随后苹果注册的那个 Source1 就会触发回调，并调用 _UIApplicationHandleEventQueue() 进行应用内部的分发。</p>\n<p>_UIApplicationHandleEventQueue() 会把 IOHIDEvent 处理并包装成 UIEvent 进行处理或分发，其中包括识别 UIGesture/处理屏幕旋转/发送给 UIWindow 等。通常事件比如 UIButton 点击、touchesBegin/Move/End/Cancel 事件都是在这个回调中完成的。</p>\n<h2 id=\"手势识别\"><a href=\"#手势识别\" class=\"headerlink\" title=\"手势识别\"></a>手势识别</h2><p>当上面的 _UIApplicationHandleEventQueue() 识别了一个手势时，其首先会调用 Cancel 将当前的 touchesBegin/Move/End 系列回调打断。随后系统将对应的 UIGestureRecognizer 标记为待处理。</p>\n<p>苹果注册了一个 Observer 监测 BeforeWaiting (Loop即将进入休眠) 事件，这个Observer的回调函数是 _UIGestureRecognizerUpdateObserver()，其内部会获取所有刚被标记为待处理的 GestureRecognizer，并执行GestureRecognizer的回调。</p>\n<p>当有 UIGestureRecognizer 的变化(创建/销毁/状态改变)时，这个回调都会进行相应处理。</p>\n<h2 id=\"界面更新\"><a href=\"#界面更新\" class=\"headerlink\" title=\"界面更新\"></a>界面更新</h2><p>当在操作 UI 时，比如改变了 Frame、更新了 UIView/CALayer 的层次时，或者手动调用了 UIView/CALayer 的 setNeedsLayout/setNeedsDisplay方法后，这个 UIView/CALayer 就被标记为待处理，并被提交到一个全局的容器去。</p>\n<p>苹果注册了一个 Observer 监听 BeforeWaiting(即将进入休眠) 和 Exit (即将退出Loop) 事件，回调去执行一个很长的函数：<br>_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv()。这个函数里会遍历所有待处理的 UIView/CAlayer 以执行实际的绘制和调整，并更新 UI 界面。</p>\n<h2 id=\"iOS-为什么必须在主线程中操作UI\"><a href=\"#iOS-为什么必须在主线程中操作UI\" class=\"headerlink\" title=\"iOS 为什么必须在主线程中操作UI\"></a>iOS 为什么必须在主线程中操作UI</h2><p>因为UIKit不是线程安全的。试想下面这几种情况：</p>\n<ol>\n<li><p>两个线程同时设置同一个背景图片，那么很有可能因为当前图片被释放了两次而导致应用崩溃。</p>\n</li>\n<li><p>两个线程同时设置同一个UIView的背景颜色，那么很有可能渲染显示的是颜色A，而此时在UIView逻辑树上的背景颜色属性为B。</p>\n</li>\n<li><p>两个线程同时操作view的树形结构：在线程A中for循环遍历并操作当前View的所有subView，然后此时线程B中将某个subView直接删除，这就导致了错乱还可能导致应用崩溃。<br>iOS4之后苹果将大部分绘图的方法和诸如 UIColor 和 UIFont 这样的类改写为了线程安全可用，但是仍然强烈建议讲UI操作保证在主线程中执行。</p>\n</li>\n</ol>\n<h2 id=\"CALayer\"><a href=\"#CALayer\" class=\"headerlink\" title=\"CALayer\"></a>CALayer</h2><p>在iOS当中，所有的视图都从一个叫做UIVIew的基类派生而来，UIView可以处理触摸事件，可以支持基于Core Graphics绘图，可以做仿射变换（例如旋转或者缩放），或者简单的类似于滑动或者渐变的动画。</p>\n<p>CALayer类在概念上和UIView类似，同样也是一些被层级关系树管理的矩形块，同样也可以包含一些内容（像图片，文本或者背景色），管理子图层的位置。它们有一些方法和属性用来做动画和变换。和UIView最大的不同是CALayer不处理用户的交互。CALayer并不清楚具体的响应链。</p>\n<p>UIView和CALayer是一个平行的层级关系，每一个UIView都有一个CALayer实例的图层属性，也就是所谓的backing layer，视图的职责就是创建并管理这个图层，以确保当子视图在层级关系中添加或者被移除的时候，他们关联的图层也同样对应在层级关系树当中有相同的操作。实际上这些背后关联的Layer图层才是真正用来在屏幕上显示和做动画，UIView仅仅是对它的一个封装，提供了一些iOS类似于处理触摸的具体功能，以及Core Animation底层方法的高级接口。</p>\n<p>UIView 的 Layer 在系统内部，被维护着三份同样的树形数据结构，分别是：</p>\n<ul>\n<li><p>图层树（这里是代码可以操纵的，设置属性的最终值会立刻在这里更新）；</p>\n</li>\n<li><p>呈现树（是一个中间层，系统就在这一层上更改属性，进行各种渲染操作。比如一个动画是更改alpha值从0到1，那么在逻辑树上此属性会被立刻更新为最终属性1，而在动画树上会根据设置的动画时间从0逐步变化到1）；</p>\n</li>\n<li><p>渲染树（其属性值就是当前正被显示在屏幕上的属性值）；</p>\n</li>\n</ul>\n<h2 id=\"iOS事件处理与图像渲染（牛逼）\"><a href=\"#iOS事件处理与图像渲染（牛逼）\" class=\"headerlink\" title=\"iOS事件处理与图像渲染（牛逼）\"></a>iOS事件处理与图像渲染（牛逼）</h2><p><a href=\"https://www.cnblogs.com/yulang314/p/5091894.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/yulang314/p/5091894.html</a></p>\n<h2 id=\"weak实现\"><a href=\"#weak实现\" class=\"headerlink\" title=\"weak实现\"></a>weak实现</h2><p><a href=\"https://www.jianshu.com/p/3c5e335341e0\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/3c5e335341e0</a></p>\n<h2 id=\"默认属性\"><a href=\"#默认属性\" class=\"headerlink\" title=\"默认属性\"></a>默认属性</h2><ul>\n<li><p>对应基本数据类型，默认关键字为<br>atomic, assign, readwrite</p>\n</li>\n<li><p>对应对象类型，默认关键字为<br>atomic, strong, readwrite</p>\n</li>\n<li><p>atomic 和 nonatomic区别<br><a href=\"https://www.jianshu.com/p/7288eacbb1a2\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/7288eacbb1a2</a></p>\n</li>\n</ul>\n<h2 id=\"Block原理\"><a href=\"#Block原理\" class=\"headerlink\" title=\"Block原理\"></a>Block原理</h2><p><a href=\"https://www.jianshu.com/p/221d0778dcaa\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/221d0778dcaa</a></p>\n<h2 id=\"YUV\"><a href=\"#YUV\" class=\"headerlink\" title=\"YUV\"></a>YUV</h2><p><a href=\"https://glumes.com/post/ffmpeg/understand-yuv-format/\" target=\"_blank\" rel=\"noopener\">https://glumes.com/post/ffmpeg/understand-yuv-format/</a></p>\n<h2 id=\"I帧B帧P帧\"><a href=\"#I帧B帧P帧\" class=\"headerlink\" title=\"I帧B帧P帧\"></a>I帧B帧P帧</h2><p><a href=\"https://www.cnblogs.com/yongdaimi/p/10676309.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/yongdaimi/p/10676309.html</a></p>\n<h2 id=\"H264\"><a href=\"#H264\" class=\"headerlink\" title=\"H264\"></a>H264</h2><p><a href=\"https://www.cnblogs.com/Lxk0825/p/9925041.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/Lxk0825/p/9925041.html</a></p>\n<h2 id=\"直播开发大全\"><a href=\"#直播开发大全\" class=\"headerlink\" title=\"直播开发大全\"></a>直播开发大全</h2><p><a href=\"https://www.jianshu.com/p/bd42bacbe4cc\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/bd42bacbe4cc</a></p>\n<h2 id=\"20分钟OpenGL\"><a href=\"#20分钟OpenGL\" class=\"headerlink\" title=\"20分钟OpenGL\"></a>20分钟OpenGL</h2><p><a href=\"https://zhuanlan.zhihu.com/p/56693625\" target=\"_blank\" rel=\"noopener\">https://zhuanlan.zhihu.com/p/56693625</a></p>\n<h2 id=\"自研直播协议（牛逼-详细）\"><a href=\"#自研直播协议（牛逼-详细）\" class=\"headerlink\" title=\"自研直播协议（牛逼 详细）\"></a>自研直播协议（牛逼 详细）</h2><p><a href=\"https://yq.aliyun.com/articles/668499\" target=\"_blank\" rel=\"noopener\">https://yq.aliyun.com/articles/668499</a></p>\n<h2 id=\"WebRTC协议\"><a href=\"#WebRTC协议\" class=\"headerlink\" title=\"WebRTC协议\"></a>WebRTC协议</h2><p><a href=\"https://blog.csdn.net/moyebaobei1/article/details/86703258\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/moyebaobei1/article/details/86703258</a></p>\n<h2 id=\"HLS协议和RTMP协议\"><a href=\"#HLS协议和RTMP协议\" class=\"headerlink\" title=\"HLS协议和RTMP协议\"></a>HLS协议和RTMP协议</h2><p><a href=\"https://cloud.tencent.com/developer/article/1509053\" target=\"_blank\" rel=\"noopener\">https://cloud.tencent.com/developer/article/1509053</a></p>\n<h2 id=\"H264-比较全\"><a href=\"#H264-比较全\" class=\"headerlink\" title=\"H264(比较全)\"></a>H264(比较全)</h2><p><a href=\"https://www.jianshu.com/p/0c296b05ef2a\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/0c296b05ef2a</a></p>\n<h2 id=\"App启动耗时优化\"><a href=\"#App启动耗时优化\" class=\"headerlink\" title=\"App启动耗时优化\"></a>App启动耗时优化</h2><ul>\n<li>启动时间 = pre-main耗时+main耗时</li>\n<li>pre-main阶段优化：<ul>\n<li>删除无用代码</li>\n<li>抽象重复代码</li>\n<li>+load方法做的事情延迟到initialize中，或者+load的事情不宜花费太多时间</li>\n<li>减少不必要的framework，或者优化已有framework</li>\n</ul>\n</li>\n<li>Main阶段优化<ul>\n<li>didFinishLauchingwithOptions里代码延后执行</li>\n<li>首次启动渲染的页面优化</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"crash防护\"><a href=\"#crash防护\" class=\"headerlink\" title=\"crash防护\"></a>crash防护</h2><ul>\n<li>unrecognized selector crash<br>  <a href=\"https://www.jianshu.com/p/6a12e9d92366\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/6a12e9d92366</a></li>\n<li>KVO crash<br>  <a href=\"https://www.jianshu.com/p/e3713d309283\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/e3713d309283</a></li>\n<li>NSNotification crash<br>  <a href=\"https://www.cnblogs.com/Xylophone/p/6394056.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/Xylophone/p/6394056.html</a></li>\n<li>NSTimer crash<br>  <a href=\"https://www.cnblogs.com/Xylophone/p/6394076.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/Xylophone/p/6394076.html</a></li>\n<li>Container crash（数组越界，插nil等）</li>\n<li>NSString crash （字符串操作的crash）</li>\n<li>Bad Access crash （野指针）</li>\n<li>UI not on Main Thread Crash (非主线程刷UI (机制待改善))</li>\n</ul>\n<h2 id=\"内存泄露问题\"><a href=\"#内存泄露问题\" class=\"headerlink\" title=\"内存泄露问题\"></a>内存泄露问题</h2><p>主要集中在循环引用问题中，如block、NSTime、perform selector引用计数问题。</p>\n<ul>\n<li>使用Xcode静态分析</li>\n<li>使用Insurment中的leak，查看引用循环图</li>\n<li>使用MLLeakFinder</li>\n</ul>\n<h2 id=\"UI卡顿优化\"><a href=\"#UI卡顿优化\" class=\"headerlink\" title=\"UI卡顿优化\"></a>UI卡顿优化</h2><p><a href=\"https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/\" target=\"_blank\" rel=\"noopener\">https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/</a></p>\n<ul>\n<li>CPU优化<ul>\n<li>对象懒加载</li>\n<li>Time Profile找出大量耗时的操作</li>\n<li>布局计算，cell(缓存高度，后台线程提前计算布局)，文本布局计算（后台提前计算）</li>\n<li>视图创建消耗（cell复用）</li>\n<li>减少自动布局的使用</li>\n<li>图片解码（后台线程提前解码成Bitmap，不要用JPEG，用PNG）</li>\n</ul>\n</li>\n<li>GPU优化<ul>\n<li>图片的渲染，tableview里面大量图片（可以将多张图片合成一张，或使用低清晰度的缩略图）</li>\n<li>减少视图混合（减少UIview层级）</li>\n<li>减少离屏渲染，（CALayer 的 border、圆角、阴影、mask都会触发离屏渲染，可以将需要显示的效果在后台绘制成一张图片）</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"GPUImage源码\"><a href=\"#GPUImage源码\" class=\"headerlink\" title=\"GPUImage源码\"></a>GPUImage源码</h2><h2 id=\"Opengl-ES\"><a href=\"#Opengl-ES\" class=\"headerlink\" title=\"Opengl ES\"></a>Opengl ES</h2><p><a href=\"https://juejin.im/post/6844903843180838920\" target=\"_blank\" rel=\"noopener\">https://juejin.im/post/6844903843180838920</a></p>\n"},{"title":"代码中的'一等公民'","date":"2020-06-16T06:19:11.000Z","_content":"\n### 代码中的一等公民\n\n第一等公民，又称为第一类对象。\n\n《维基百科》\n第一类对象（英语：First-class object）在计算机科学中指可以在执行期创造并作为参数传递给其他函数或存入一个变数的实体[1]。将一个实体变为第一类对象的过程叫做“物件化”（Reification）[2]。\n\n**一等参数的标准：**\n* 可以被存入变数或其他结构\n* 可以被作为参数传递给其他函数\n* 可以被作为函数的返回值\n* 可以在执行期创造，而无需完全在设计期全部写出\n* 即使没有被系结至某一名称，也可以存在\n\n在Dart中函数是一等公民既能做返回值又能做参数。举个二等公民的例子：C++中的数组，它不能当做返回值，函数返回数组时，返回的实际是指针。\n\n参考资料：https://zhuanlan.zhihu.com/p/114285501\n        https://blog.csdn.net/u013524455/article/details/80294116\n        https://juejin.im/post/5b5418886fb9a04fab450f0f","source":"_posts/代码中的-一等公民.md","raw":"---\ntitle: 代码中的'一等公民'\ndate: 2020-06-16 14:19:11\ntags:\n---\n\n### 代码中的一等公民\n\n第一等公民，又称为第一类对象。\n\n《维基百科》\n第一类对象（英语：First-class object）在计算机科学中指可以在执行期创造并作为参数传递给其他函数或存入一个变数的实体[1]。将一个实体变为第一类对象的过程叫做“物件化”（Reification）[2]。\n\n**一等参数的标准：**\n* 可以被存入变数或其他结构\n* 可以被作为参数传递给其他函数\n* 可以被作为函数的返回值\n* 可以在执行期创造，而无需完全在设计期全部写出\n* 即使没有被系结至某一名称，也可以存在\n\n在Dart中函数是一等公民既能做返回值又能做参数。举个二等公民的例子：C++中的数组，它不能当做返回值，函数返回数组时，返回的实际是指针。\n\n参考资料：https://zhuanlan.zhihu.com/p/114285501\n        https://blog.csdn.net/u013524455/article/details/80294116\n        https://juejin.im/post/5b5418886fb9a04fab450f0f","slug":"代码中的-一等公民","published":1,"updated":"2020-06-21T14:29:32.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgyxlit0000k0iu68yws7tu9","content":"<h3 id=\"代码中的一等公民\"><a href=\"#代码中的一等公民\" class=\"headerlink\" title=\"代码中的一等公民\"></a>代码中的一等公民</h3><p>第一等公民，又称为第一类对象。</p>\n<p>《维基百科》<br>第一类对象（英语：First-class object）在计算机科学中指可以在执行期创造并作为参数传递给其他函数或存入一个变数的实体[1]。将一个实体变为第一类对象的过程叫做“物件化”（Reification）[2]。</p>\n<p><strong>一等参数的标准：</strong></p>\n<ul>\n<li>可以被存入变数或其他结构</li>\n<li>可以被作为参数传递给其他函数</li>\n<li>可以被作为函数的返回值</li>\n<li>可以在执行期创造，而无需完全在设计期全部写出</li>\n<li>即使没有被系结至某一名称，也可以存在</li>\n</ul>\n<p>在Dart中函数是一等公民既能做返回值又能做参数。举个二等公民的例子：C++中的数组，它不能当做返回值，函数返回数组时，返回的实际是指针。</p>\n<p>参考资料：<a href=\"https://zhuanlan.zhihu.com/p/114285501\" target=\"_blank\" rel=\"noopener\">https://zhuanlan.zhihu.com/p/114285501</a><br>        <a href=\"https://blog.csdn.net/u013524455/article/details/80294116\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/u013524455/article/details/80294116</a><br>        <a href=\"https://juejin.im/post/5b5418886fb9a04fab450f0f\" target=\"_blank\" rel=\"noopener\">https://juejin.im/post/5b5418886fb9a04fab450f0f</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"代码中的一等公民\"><a href=\"#代码中的一等公民\" class=\"headerlink\" title=\"代码中的一等公民\"></a>代码中的一等公民</h3><p>第一等公民，又称为第一类对象。</p>\n<p>《维基百科》<br>第一类对象（英语：First-class object）在计算机科学中指可以在执行期创造并作为参数传递给其他函数或存入一个变数的实体[1]。将一个实体变为第一类对象的过程叫做“物件化”（Reification）[2]。</p>\n<p><strong>一等参数的标准：</strong></p>\n<ul>\n<li>可以被存入变数或其他结构</li>\n<li>可以被作为参数传递给其他函数</li>\n<li>可以被作为函数的返回值</li>\n<li>可以在执行期创造，而无需完全在设计期全部写出</li>\n<li>即使没有被系结至某一名称，也可以存在</li>\n</ul>\n<p>在Dart中函数是一等公民既能做返回值又能做参数。举个二等公民的例子：C++中的数组，它不能当做返回值，函数返回数组时，返回的实际是指针。</p>\n<p>参考资料：<a href=\"https://zhuanlan.zhihu.com/p/114285501\" target=\"_blank\" rel=\"noopener\">https://zhuanlan.zhihu.com/p/114285501</a><br>        <a href=\"https://blog.csdn.net/u013524455/article/details/80294116\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/u013524455/article/details/80294116</a><br>        <a href=\"https://juejin.im/post/5b5418886fb9a04fab450f0f\" target=\"_blank\" rel=\"noopener\">https://juejin.im/post/5b5418886fb9a04fab450f0f</a></p>\n"},{"title":"人肉方法随记","date":"2020-06-27T18:07:58.000Z","_content":"\n# ip定位地理位置\n\n根据ip定位地理位置：https://ipplus360.com/\n\n**PS**：试了一下，定位并不准确，甚至省市都定错了，可能是姿势不对，没充钱？\n\n# Mac 命令行查看自己的公网IP\n\nMac 查看本机公网IP 命令\n\n```\ncurl ifconfig.me  \n```\n如果想更好看一点\n\n```\ncurl ipinfo.io/json\n```\n还可以用wget\n\n```wget http://ipecho.net/plain -O - -q ; echo\nwget http://observebox.com/ip -O - -q ; echo\n```\n查看本机内网IP\n\n```\nifconfig\n```","source":"_posts/人肉方法随记.md","raw":"---\ntitle: 人肉方法随记\ndate: 2020-06-28 02:07:58\ntags:\n---\n\n# ip定位地理位置\n\n根据ip定位地理位置：https://ipplus360.com/\n\n**PS**：试了一下，定位并不准确，甚至省市都定错了，可能是姿势不对，没充钱？\n\n# Mac 命令行查看自己的公网IP\n\nMac 查看本机公网IP 命令\n\n```\ncurl ifconfig.me  \n```\n如果想更好看一点\n\n```\ncurl ipinfo.io/json\n```\n还可以用wget\n\n```wget http://ipecho.net/plain -O - -q ; echo\nwget http://observebox.com/ip -O - -q ; echo\n```\n查看本机内网IP\n\n```\nifconfig\n```","slug":"人肉方法随记","published":1,"updated":"2020-06-28T17:43:52.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgyxlit2000l0iu60hi00o0f","content":"<h1 id=\"ip定位地理位置\"><a href=\"#ip定位地理位置\" class=\"headerlink\" title=\"ip定位地理位置\"></a>ip定位地理位置</h1><p>根据ip定位地理位置：<a href=\"https://ipplus360.com/\" target=\"_blank\" rel=\"noopener\">https://ipplus360.com/</a></p>\n<p><strong>PS</strong>：试了一下，定位并不准确，甚至省市都定错了，可能是姿势不对，没充钱？</p>\n<h1 id=\"Mac-命令行查看自己的公网IP\"><a href=\"#Mac-命令行查看自己的公网IP\" class=\"headerlink\" title=\"Mac 命令行查看自己的公网IP\"></a>Mac 命令行查看自己的公网IP</h1><p>Mac 查看本机公网IP 命令</p>\n<pre><code>curl ifconfig.me  </code></pre><p>如果想更好看一点</p>\n<pre><code>curl ipinfo.io/json</code></pre><p>还可以用wget</p>\n<pre><code class=\"wget\">wget http://observebox.com/ip -O - -q ; echo</code></pre>\n<p>查看本机内网IP</p>\n<pre><code>ifconfig</code></pre>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"ip定位地理位置\"><a href=\"#ip定位地理位置\" class=\"headerlink\" title=\"ip定位地理位置\"></a>ip定位地理位置</h1><p>根据ip定位地理位置：<a href=\"https://ipplus360.com/\" target=\"_blank\" rel=\"noopener\">https://ipplus360.com/</a></p>\n<p><strong>PS</strong>：试了一下，定位并不准确，甚至省市都定错了，可能是姿势不对，没充钱？</p>\n<h1 id=\"Mac-命令行查看自己的公网IP\"><a href=\"#Mac-命令行查看自己的公网IP\" class=\"headerlink\" title=\"Mac 命令行查看自己的公网IP\"></a>Mac 命令行查看自己的公网IP</h1><p>Mac 查看本机公网IP 命令</p>\n<pre><code>curl ifconfig.me  </code></pre><p>如果想更好看一点</p>\n<pre><code>curl ipinfo.io/json</code></pre><p>还可以用wget</p>\n<pre><code class=\"wget\">wget http://observebox.com/ip -O - -q ; echo</code></pre>\n<p>查看本机内网IP</p>\n<pre><code>ifconfig</code></pre>"},{"title":"从编译失败了解Xcode中的各种架构 armv7,armv7s,arm64,i386,x86_64","date":"2020-09-22T08:31:49.000Z","_content":"\n## 起因\n\n![企业微信截图_8b7a02ae-f77c-459f-88a6-52b666835309](https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2020/09/22/qi-ye-wei-xin-jie-tu8b7a02aef77c459f88a652b6668353.png)\n\n更新了一下工程代码，发现编译失败了，我们的工程是子工程，主工程在link阶段找不到我们子工程的符号。\n\n## 分析\n\n![-w582](https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2020/09/22/16007605923900.jpg)\n细看错误提示写的是主工程在x86_64架构下找不到子工程的符号，好了，那就来看看子工程的工程设置\n\n找到工程，打开build setting，真相了，支持的架构是armv7,arm64,i386，没有支持x86_64架构。\n![-w550](https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2020/09/22/16007606982543.jpg)\n\n加上x86_64后编译成功\n![-w253](https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2020/09/22/16007608180330.jpg)\n\n## 细品\n\n那么这些armv7 arm64 i386 x86_64都是个啥？\n\n* ARM架构\n\n　　ARM架构过去称作进阶精简指令集机器（Advanced RISC Machine，更早称作：Acorn RISC Machine），是一个32位精简指令集（RISC）处理器架构，ARM处理器非常适用于移动通讯领域，符合其主要设计目标为低耗电的特性。\n\n　　ARM和Intel处理器的第一个区别是，前者使用精简指令集（RISC），而后者使用复杂指令集（CISC)。\n　　\n* ARM处理器指令集\n\n　　ARM指令集是指计算机ARM操作指令系统。\n\n　　armv6、armv7、armv7s、arm64、arm64e都是arm处理器的指令集，所有指令集原则上都是向下兼容的。比如，你的设备是armv7s指令集，那么它也可以兼容运行比armv7s版本低的指令集：armv7、armv6。Xcode4.5起不再支持armv6。\n\n　　苹果A7处理器支持两个不同的指令集：32位ARM指令集（armv6｜armv7｜armv7s）和64位ARM指令集（arm64）。i386｜x86_64 是Mac处理器的指令集。i386是针对intel通用微处理器32位处理器，x86_64是针对x86架构的64位处理器\n\n　　i386通常被用来作为对Intel 32位微处理器的统称。X86-64可在同一时间内处理64位的整数运算，并兼容X86-32架构,x86_64是针对x86架构的64位处理器。当使用iOS模拟器的时候会遇到i386｜x86_64，iOS模拟器没有运行arm指令集，编译运行的是x86指令集，所以，只有在iOS设备上，才会执行设备对应的arm指令集。\n　　\n\n## iOS设备支持的指令集\n* armv6:\n\n　　iPhone, iPhone 3G, iPod 1G/2G\n\n* armv7:\n\n　　iPhone 3GS, iPhone 4, iPhone 4S, iPod 3G/4G/5G, iPad, iPad 2, iPad 3, iPad Mini\n\n* armv7s：\n\n　　 iPhone 5, iPhone 5c, iPad 4\n\n* arm64:\n\n　　iPhone X，iPhone 8(Plus)，iPhone 7(Plus)，iPhone 6(Plus)，iPhone 6s(Plus), iPhone 5s, iPad Air(2), Retina iPad Mini(2,3)\n\n* arm64e:\n\n　　iPhone XS\\XR\\XS Max\n* i386：\n\n    模拟器32位处理器测试需要架构，现在已经没有32位的模拟器，这个选项告别舞台了\n\n* x86_64：\n\n    模拟器64位处理器测试需要架构\n    \n　\n## XCode设置\n\n* Architectures\n\n　　指定工程被编译成支持哪些指令集类型，而支持的指令集越多，就会编译出很多个指令集代码的数据包，对应生成二进制包就越大，也就是ipa包越大。\n\n　　现在XCode->build setting 中Architectures的默认值是Standard architectures- $(ARCHS-STANDARD)， $(ARCHS-STANDARD)的值如下图所示：\n![](https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2020/09/22/16007612106947.jpg)\n\n　　地址：https://pewpewthespells.com/blog/buildsettings.html#current_arch\n\n\n* Valid Architectures\n　　该编译项指定可能支持的指令集，该列表和Architectures列表的交集，将是Xcode最终生成二进制包所支持的指令集。\n\n　　比如，你的Valid Architectures设置的支持arm指令集版本有：armv7/armv7s/arm64，对应的Architectures设置的支持arm指令集版本有：arm64，这时Xcode只会生成一个arm64指令集的二进制包。\n\n　　减少安装包中的指令集数据包可以减小打包ipa的大小。\n\n* Build Active Architecture Only:\n\n　　指明是否只编译当前连接设备所支持的指令集。\n　　\n　　默认Debug的时候设置为YES，Release的时候设置为NO。设置为YES是只编译当前的architecture版本，生成的包只包含当前连接设备的指令集代码。设置为NO，则生成的包包含所有的指令集代码（上面的Valid Architectures跟Architectures的交集）。因此为了调试速度更快，则Debug应该设置为YES。\n\n　　特殊：设置此值为YES，如果连接的设备是arm64的（ iPhone 5s，iPhone6（plus）等），则Valid Architecture 中必须包含arm64, 否则编译会报错.\n　　\n　　\n## XCode中应该使用的配置\n\n大多数工程的设置：arm64 armv7 x_86_64\n\n剩余疑问：为什么不用指定armv7s和arm64e？ \n\n　\n本文参考以下文档：\nhttps://www.cnblogs.com/lulushen/p/8135269.html\nhttps://www.jianshu.com/p/e01e3ee5a612","source":"_posts/从编译失败了解Xcode中的各种架构-armv7-armv7s-arm64-i386-x86-64.md","raw":"---\ntitle: '从编译失败了解Xcode中的各种架构 armv7,armv7s,arm64,i386,x86_64'\ndate: 2020-09-22 16:31:49\ntags:\n---\n\n## 起因\n\n![企业微信截图_8b7a02ae-f77c-459f-88a6-52b666835309](https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2020/09/22/qi-ye-wei-xin-jie-tu8b7a02aef77c459f88a652b6668353.png)\n\n更新了一下工程代码，发现编译失败了，我们的工程是子工程，主工程在link阶段找不到我们子工程的符号。\n\n## 分析\n\n![-w582](https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2020/09/22/16007605923900.jpg)\n细看错误提示写的是主工程在x86_64架构下找不到子工程的符号，好了，那就来看看子工程的工程设置\n\n找到工程，打开build setting，真相了，支持的架构是armv7,arm64,i386，没有支持x86_64架构。\n![-w550](https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2020/09/22/16007606982543.jpg)\n\n加上x86_64后编译成功\n![-w253](https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2020/09/22/16007608180330.jpg)\n\n## 细品\n\n那么这些armv7 arm64 i386 x86_64都是个啥？\n\n* ARM架构\n\n　　ARM架构过去称作进阶精简指令集机器（Advanced RISC Machine，更早称作：Acorn RISC Machine），是一个32位精简指令集（RISC）处理器架构，ARM处理器非常适用于移动通讯领域，符合其主要设计目标为低耗电的特性。\n\n　　ARM和Intel处理器的第一个区别是，前者使用精简指令集（RISC），而后者使用复杂指令集（CISC)。\n　　\n* ARM处理器指令集\n\n　　ARM指令集是指计算机ARM操作指令系统。\n\n　　armv6、armv7、armv7s、arm64、arm64e都是arm处理器的指令集，所有指令集原则上都是向下兼容的。比如，你的设备是armv7s指令集，那么它也可以兼容运行比armv7s版本低的指令集：armv7、armv6。Xcode4.5起不再支持armv6。\n\n　　苹果A7处理器支持两个不同的指令集：32位ARM指令集（armv6｜armv7｜armv7s）和64位ARM指令集（arm64）。i386｜x86_64 是Mac处理器的指令集。i386是针对intel通用微处理器32位处理器，x86_64是针对x86架构的64位处理器\n\n　　i386通常被用来作为对Intel 32位微处理器的统称。X86-64可在同一时间内处理64位的整数运算，并兼容X86-32架构,x86_64是针对x86架构的64位处理器。当使用iOS模拟器的时候会遇到i386｜x86_64，iOS模拟器没有运行arm指令集，编译运行的是x86指令集，所以，只有在iOS设备上，才会执行设备对应的arm指令集。\n　　\n\n## iOS设备支持的指令集\n* armv6:\n\n　　iPhone, iPhone 3G, iPod 1G/2G\n\n* armv7:\n\n　　iPhone 3GS, iPhone 4, iPhone 4S, iPod 3G/4G/5G, iPad, iPad 2, iPad 3, iPad Mini\n\n* armv7s：\n\n　　 iPhone 5, iPhone 5c, iPad 4\n\n* arm64:\n\n　　iPhone X，iPhone 8(Plus)，iPhone 7(Plus)，iPhone 6(Plus)，iPhone 6s(Plus), iPhone 5s, iPad Air(2), Retina iPad Mini(2,3)\n\n* arm64e:\n\n　　iPhone XS\\XR\\XS Max\n* i386：\n\n    模拟器32位处理器测试需要架构，现在已经没有32位的模拟器，这个选项告别舞台了\n\n* x86_64：\n\n    模拟器64位处理器测试需要架构\n    \n　\n## XCode设置\n\n* Architectures\n\n　　指定工程被编译成支持哪些指令集类型，而支持的指令集越多，就会编译出很多个指令集代码的数据包，对应生成二进制包就越大，也就是ipa包越大。\n\n　　现在XCode->build setting 中Architectures的默认值是Standard architectures- $(ARCHS-STANDARD)， $(ARCHS-STANDARD)的值如下图所示：\n![](https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2020/09/22/16007612106947.jpg)\n\n　　地址：https://pewpewthespells.com/blog/buildsettings.html#current_arch\n\n\n* Valid Architectures\n　　该编译项指定可能支持的指令集，该列表和Architectures列表的交集，将是Xcode最终生成二进制包所支持的指令集。\n\n　　比如，你的Valid Architectures设置的支持arm指令集版本有：armv7/armv7s/arm64，对应的Architectures设置的支持arm指令集版本有：arm64，这时Xcode只会生成一个arm64指令集的二进制包。\n\n　　减少安装包中的指令集数据包可以减小打包ipa的大小。\n\n* Build Active Architecture Only:\n\n　　指明是否只编译当前连接设备所支持的指令集。\n　　\n　　默认Debug的时候设置为YES，Release的时候设置为NO。设置为YES是只编译当前的architecture版本，生成的包只包含当前连接设备的指令集代码。设置为NO，则生成的包包含所有的指令集代码（上面的Valid Architectures跟Architectures的交集）。因此为了调试速度更快，则Debug应该设置为YES。\n\n　　特殊：设置此值为YES，如果连接的设备是arm64的（ iPhone 5s，iPhone6（plus）等），则Valid Architecture 中必须包含arm64, 否则编译会报错.\n　　\n　　\n## XCode中应该使用的配置\n\n大多数工程的设置：arm64 armv7 x_86_64\n\n剩余疑问：为什么不用指定armv7s和arm64e？ \n\n　\n本文参考以下文档：\nhttps://www.cnblogs.com/lulushen/p/8135269.html\nhttps://www.jianshu.com/p/e01e3ee5a612","slug":"从编译失败了解Xcode中的各种架构-armv7-armv7s-arm64-i386-x86-64","published":1,"updated":"2020-09-22T08:37:06.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgyxlit4000m0iu60tw30ovc","content":"<h2 id=\"起因\"><a href=\"#起因\" class=\"headerlink\" title=\"起因\"></a>起因</h2><p><img src=\"https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2020/09/22/qi-ye-wei-xin-jie-tu8b7a02aef77c459f88a652b6668353.png\" alt=\"企业微信截图_8b7a02ae-f77c-459f-88a6-52b666835309\"></p>\n<p>更新了一下工程代码，发现编译失败了，我们的工程是子工程，主工程在link阶段找不到我们子工程的符号。</p>\n<h2 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h2><p><img src=\"https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2020/09/22/16007605923900.jpg\" alt=\"-w582\"><br>细看错误提示写的是主工程在x86_64架构下找不到子工程的符号，好了，那就来看看子工程的工程设置</p>\n<p>找到工程，打开build setting，真相了，支持的架构是armv7,arm64,i386，没有支持x86_64架构。<br><img src=\"https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2020/09/22/16007606982543.jpg\" alt=\"-w550\"></p>\n<p>加上x86_64后编译成功<br><img src=\"https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2020/09/22/16007608180330.jpg\" alt=\"-w253\"></p>\n<h2 id=\"细品\"><a href=\"#细品\" class=\"headerlink\" title=\"细品\"></a>细品</h2><p>那么这些armv7 arm64 i386 x86_64都是个啥？</p>\n<ul>\n<li>ARM架构</li>\n</ul>\n<p>　　ARM架构过去称作进阶精简指令集机器（Advanced RISC Machine，更早称作：Acorn RISC Machine），是一个32位精简指令集（RISC）处理器架构，ARM处理器非常适用于移动通讯领域，符合其主要设计目标为低耗电的特性。</p>\n<p>　　ARM和Intel处理器的第一个区别是，前者使用精简指令集（RISC），而后者使用复杂指令集（CISC)。\n　　</p>\n<ul>\n<li>ARM处理器指令集</li>\n</ul>\n<p>　　ARM指令集是指计算机ARM操作指令系统。</p>\n<p>　　armv6、armv7、armv7s、arm64、arm64e都是arm处理器的指令集，所有指令集原则上都是向下兼容的。比如，你的设备是armv7s指令集，那么它也可以兼容运行比armv7s版本低的指令集：armv7、armv6。Xcode4.5起不再支持armv6。</p>\n<p>　　苹果A7处理器支持两个不同的指令集：32位ARM指令集（armv6｜armv7｜armv7s）和64位ARM指令集（arm64）。i386｜x86_64 是Mac处理器的指令集。i386是针对intel通用微处理器32位处理器，x86_64是针对x86架构的64位处理器</p>\n<p>　　i386通常被用来作为对Intel 32位微处理器的统称。X86-64可在同一时间内处理64位的整数运算，并兼容X86-32架构,x86_64是针对x86架构的64位处理器。当使用iOS模拟器的时候会遇到i386｜x86_64，iOS模拟器没有运行arm指令集，编译运行的是x86指令集，所以，只有在iOS设备上，才会执行设备对应的arm指令集。\n　　</p>\n<h2 id=\"iOS设备支持的指令集\"><a href=\"#iOS设备支持的指令集\" class=\"headerlink\" title=\"iOS设备支持的指令集\"></a>iOS设备支持的指令集</h2><ul>\n<li>armv6:</li>\n</ul>\n<p>　　iPhone, iPhone 3G, iPod 1G/2G</p>\n<ul>\n<li>armv7:</li>\n</ul>\n<p>　　iPhone 3GS, iPhone 4, iPhone 4S, iPod 3G/4G/5G, iPad, iPad 2, iPad 3, iPad Mini</p>\n<ul>\n<li>armv7s：</li>\n</ul>\n<p>　　 iPhone 5, iPhone 5c, iPad 4</p>\n<ul>\n<li>arm64:</li>\n</ul>\n<p>　　iPhone X，iPhone 8(Plus)，iPhone 7(Plus)，iPhone 6(Plus)，iPhone 6s(Plus), iPhone 5s, iPad Air(2), Retina iPad Mini(2,3)</p>\n<ul>\n<li>arm64e:</li>\n</ul>\n<p>　　iPhone XS\\XR\\XS Max</p>\n<ul>\n<li><p>i386：</p>\n<p>  模拟器32位处理器测试需要架构，现在已经没有32位的模拟器，这个选项告别舞台了</p>\n</li>\n<li><p>x86_64：</p>\n<p>  模拟器64位处理器测试需要架构</p>\n</li>\n</ul>\n<p>　</p>\n<h2 id=\"XCode设置\"><a href=\"#XCode设置\" class=\"headerlink\" title=\"XCode设置\"></a>XCode设置</h2><ul>\n<li>Architectures</li>\n</ul>\n<p>　　指定工程被编译成支持哪些指令集类型，而支持的指令集越多，就会编译出很多个指令集代码的数据包，对应生成二进制包就越大，也就是ipa包越大。</p>\n<p>　　现在XCode-&gt;build setting 中Architectures的默认值是Standard architectures- $(ARCHS-STANDARD)， $(ARCHS-STANDARD)的值如下图所示：<br><img src=\"https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2020/09/22/16007612106947.jpg\" alt=\"\"></p>\n<p>　　地址：<a href=\"https://pewpewthespells.com/blog/buildsettings.html#current_arch\" target=\"_blank\" rel=\"noopener\">https://pewpewthespells.com/blog/buildsettings.html#current_arch</a></p>\n<ul>\n<li>Valid Architectures<br>　　该编译项指定可能支持的指令集，该列表和Architectures列表的交集，将是Xcode最终生成二进制包所支持的指令集。</li>\n</ul>\n<p>　　比如，你的Valid Architectures设置的支持arm指令集版本有：armv7/armv7s/arm64，对应的Architectures设置的支持arm指令集版本有：arm64，这时Xcode只会生成一个arm64指令集的二进制包。</p>\n<p>　　减少安装包中的指令集数据包可以减小打包ipa的大小。</p>\n<ul>\n<li>Build Active Architecture Only:</li>\n</ul>\n<p>　　指明是否只编译当前连接设备所支持的指令集。<br>　　<br>　　默认Debug的时候设置为YES，Release的时候设置为NO。设置为YES是只编译当前的architecture版本，生成的包只包含当前连接设备的指令集代码。设置为NO，则生成的包包含所有的指令集代码（上面的Valid Architectures跟Architectures的交集）。因此为了调试速度更快，则Debug应该设置为YES。</p>\n<p>　　特殊：设置此值为YES，如果连接的设备是arm64的（ iPhone 5s，iPhone6（plus）等），则Valid Architecture 中必须包含arm64, 否则编译会报错.\n　　\n　　</p>\n<h2 id=\"XCode中应该使用的配置\"><a href=\"#XCode中应该使用的配置\" class=\"headerlink\" title=\"XCode中应该使用的配置\"></a>XCode中应该使用的配置</h2><p>大多数工程的设置：arm64 armv7 x_86_64</p>\n<p>剩余疑问：为什么不用指定armv7s和arm64e？ </p>\n<p>　<br>本文参考以下文档：<br><a href=\"https://www.cnblogs.com/lulushen/p/8135269.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/lulushen/p/8135269.html</a><br><a href=\"https://www.jianshu.com/p/e01e3ee5a612\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/e01e3ee5a612</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"起因\"><a href=\"#起因\" class=\"headerlink\" title=\"起因\"></a>起因</h2><p><img src=\"https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2020/09/22/qi-ye-wei-xin-jie-tu8b7a02aef77c459f88a652b6668353.png\" alt=\"企业微信截图_8b7a02ae-f77c-459f-88a6-52b666835309\"></p>\n<p>更新了一下工程代码，发现编译失败了，我们的工程是子工程，主工程在link阶段找不到我们子工程的符号。</p>\n<h2 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h2><p><img src=\"https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2020/09/22/16007605923900.jpg\" alt=\"-w582\"><br>细看错误提示写的是主工程在x86_64架构下找不到子工程的符号，好了，那就来看看子工程的工程设置</p>\n<p>找到工程，打开build setting，真相了，支持的架构是armv7,arm64,i386，没有支持x86_64架构。<br><img src=\"https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2020/09/22/16007606982543.jpg\" alt=\"-w550\"></p>\n<p>加上x86_64后编译成功<br><img src=\"https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2020/09/22/16007608180330.jpg\" alt=\"-w253\"></p>\n<h2 id=\"细品\"><a href=\"#细品\" class=\"headerlink\" title=\"细品\"></a>细品</h2><p>那么这些armv7 arm64 i386 x86_64都是个啥？</p>\n<ul>\n<li>ARM架构</li>\n</ul>\n<p>　　ARM架构过去称作进阶精简指令集机器（Advanced RISC Machine，更早称作：Acorn RISC Machine），是一个32位精简指令集（RISC）处理器架构，ARM处理器非常适用于移动通讯领域，符合其主要设计目标为低耗电的特性。</p>\n<p>　　ARM和Intel处理器的第一个区别是，前者使用精简指令集（RISC），而后者使用复杂指令集（CISC)。\n　　</p>\n<ul>\n<li>ARM处理器指令集</li>\n</ul>\n<p>　　ARM指令集是指计算机ARM操作指令系统。</p>\n<p>　　armv6、armv7、armv7s、arm64、arm64e都是arm处理器的指令集，所有指令集原则上都是向下兼容的。比如，你的设备是armv7s指令集，那么它也可以兼容运行比armv7s版本低的指令集：armv7、armv6。Xcode4.5起不再支持armv6。</p>\n<p>　　苹果A7处理器支持两个不同的指令集：32位ARM指令集（armv6｜armv7｜armv7s）和64位ARM指令集（arm64）。i386｜x86_64 是Mac处理器的指令集。i386是针对intel通用微处理器32位处理器，x86_64是针对x86架构的64位处理器</p>\n<p>　　i386通常被用来作为对Intel 32位微处理器的统称。X86-64可在同一时间内处理64位的整数运算，并兼容X86-32架构,x86_64是针对x86架构的64位处理器。当使用iOS模拟器的时候会遇到i386｜x86_64，iOS模拟器没有运行arm指令集，编译运行的是x86指令集，所以，只有在iOS设备上，才会执行设备对应的arm指令集。\n　　</p>\n<h2 id=\"iOS设备支持的指令集\"><a href=\"#iOS设备支持的指令集\" class=\"headerlink\" title=\"iOS设备支持的指令集\"></a>iOS设备支持的指令集</h2><ul>\n<li>armv6:</li>\n</ul>\n<p>　　iPhone, iPhone 3G, iPod 1G/2G</p>\n<ul>\n<li>armv7:</li>\n</ul>\n<p>　　iPhone 3GS, iPhone 4, iPhone 4S, iPod 3G/4G/5G, iPad, iPad 2, iPad 3, iPad Mini</p>\n<ul>\n<li>armv7s：</li>\n</ul>\n<p>　　 iPhone 5, iPhone 5c, iPad 4</p>\n<ul>\n<li>arm64:</li>\n</ul>\n<p>　　iPhone X，iPhone 8(Plus)，iPhone 7(Plus)，iPhone 6(Plus)，iPhone 6s(Plus), iPhone 5s, iPad Air(2), Retina iPad Mini(2,3)</p>\n<ul>\n<li>arm64e:</li>\n</ul>\n<p>　　iPhone XS\\XR\\XS Max</p>\n<ul>\n<li><p>i386：</p>\n<p>  模拟器32位处理器测试需要架构，现在已经没有32位的模拟器，这个选项告别舞台了</p>\n</li>\n<li><p>x86_64：</p>\n<p>  模拟器64位处理器测试需要架构</p>\n</li>\n</ul>\n<p>　</p>\n<h2 id=\"XCode设置\"><a href=\"#XCode设置\" class=\"headerlink\" title=\"XCode设置\"></a>XCode设置</h2><ul>\n<li>Architectures</li>\n</ul>\n<p>　　指定工程被编译成支持哪些指令集类型，而支持的指令集越多，就会编译出很多个指令集代码的数据包，对应生成二进制包就越大，也就是ipa包越大。</p>\n<p>　　现在XCode-&gt;build setting 中Architectures的默认值是Standard architectures- $(ARCHS-STANDARD)， $(ARCHS-STANDARD)的值如下图所示：<br><img src=\"https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2020/09/22/16007612106947.jpg\" alt=\"\"></p>\n<p>　　地址：<a href=\"https://pewpewthespells.com/blog/buildsettings.html#current_arch\" target=\"_blank\" rel=\"noopener\">https://pewpewthespells.com/blog/buildsettings.html#current_arch</a></p>\n<ul>\n<li>Valid Architectures<br>　　该编译项指定可能支持的指令集，该列表和Architectures列表的交集，将是Xcode最终生成二进制包所支持的指令集。</li>\n</ul>\n<p>　　比如，你的Valid Architectures设置的支持arm指令集版本有：armv7/armv7s/arm64，对应的Architectures设置的支持arm指令集版本有：arm64，这时Xcode只会生成一个arm64指令集的二进制包。</p>\n<p>　　减少安装包中的指令集数据包可以减小打包ipa的大小。</p>\n<ul>\n<li>Build Active Architecture Only:</li>\n</ul>\n<p>　　指明是否只编译当前连接设备所支持的指令集。<br>　　<br>　　默认Debug的时候设置为YES，Release的时候设置为NO。设置为YES是只编译当前的architecture版本，生成的包只包含当前连接设备的指令集代码。设置为NO，则生成的包包含所有的指令集代码（上面的Valid Architectures跟Architectures的交集）。因此为了调试速度更快，则Debug应该设置为YES。</p>\n<p>　　特殊：设置此值为YES，如果连接的设备是arm64的（ iPhone 5s，iPhone6（plus）等），则Valid Architecture 中必须包含arm64, 否则编译会报错.\n　　\n　　</p>\n<h2 id=\"XCode中应该使用的配置\"><a href=\"#XCode中应该使用的配置\" class=\"headerlink\" title=\"XCode中应该使用的配置\"></a>XCode中应该使用的配置</h2><p>大多数工程的设置：arm64 armv7 x_86_64</p>\n<p>剩余疑问：为什么不用指定armv7s和arm64e？ </p>\n<p>　<br>本文参考以下文档：<br><a href=\"https://www.cnblogs.com/lulushen/p/8135269.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/lulushen/p/8135269.html</a><br><a href=\"https://www.jianshu.com/p/e01e3ee5a612\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/e01e3ee5a612</a></p>\n"},{"title":"如何检测项目中对UIWebview的引用 (ITMS-90809)","_content":"\n\n自从去年开始苹果就发布了通知，禁用UIWebview，替换为WKWebview，继续使用会在提交时收到苹果粑粑的警告:\n\n> ITMS-90809: Deprecated API Usage - Apple will no longer accept submissions of new apps that use UIWebView as of April 30, 2020 and app updates that use UIWebView as of December 2020. Instead, use WKWebView for improved security and reliability. Learn more (https://developer.apple.com/documentation/uikit/uiwebview).\n\nUIWebview可能存在与业务代码中、pod中、动静态库中，单单使用Xcode的查找是不行的。\n\n那么，要把大象装冰箱，拢共分几步？ 答：三步\n\n### 第一步\n控制台打开工程目录\n    \n### 第二部\n输入命令\n```\ngrep -R UIWebView *\n```\n### 第三步：\n把搜索出来的结果挨个干掉or升级，AFNetwork升级最新，微信SDK升级1.8.2以上，等等，注意有用到UIWebviewDelegate的也要干掉，不要给自己找麻烦。\n    \n\n完成，鞠躬下台。\n    ","source":"_posts/如何检测项目中对UIWebview的引用 (ITMS-90809).md","raw":"---\ntitle: 如何检测项目中对UIWebview的引用 (ITMS-90809)\n---\n\n\n自从去年开始苹果就发布了通知，禁用UIWebview，替换为WKWebview，继续使用会在提交时收到苹果粑粑的警告:\n\n> ITMS-90809: Deprecated API Usage - Apple will no longer accept submissions of new apps that use UIWebView as of April 30, 2020 and app updates that use UIWebView as of December 2020. Instead, use WKWebView for improved security and reliability. Learn more (https://developer.apple.com/documentation/uikit/uiwebview).\n\nUIWebview可能存在与业务代码中、pod中、动静态库中，单单使用Xcode的查找是不行的。\n\n那么，要把大象装冰箱，拢共分几步？ 答：三步\n\n### 第一步\n控制台打开工程目录\n    \n### 第二部\n输入命令\n```\ngrep -R UIWebView *\n```\n### 第三步：\n把搜索出来的结果挨个干掉or升级，AFNetwork升级最新，微信SDK升级1.8.2以上，等等，注意有用到UIWebviewDelegate的也要干掉，不要给自己找麻烦。\n    \n\n完成，鞠躬下台。\n    ","slug":"如何检测项目中对UIWebview的引用 (ITMS-90809)","published":1,"date":"2020-06-11T16:02:03.000Z","updated":"2020-06-13T08:00:15.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgyxlit5000n0iu6gqmdehad","content":"<p>自从去年开始苹果就发布了通知，禁用UIWebview，替换为WKWebview，继续使用会在提交时收到苹果粑粑的警告:</p>\n<blockquote>\n<p>ITMS-90809: Deprecated API Usage - Apple will no longer accept submissions of new apps that use UIWebView as of April 30, 2020 and app updates that use UIWebView as of December 2020. Instead, use WKWebView for improved security and reliability. Learn more (<a href=\"https://developer.apple.com/documentation/uikit/uiwebview\" target=\"_blank\" rel=\"noopener\">https://developer.apple.com/documentation/uikit/uiwebview</a>).</p>\n</blockquote>\n<p>UIWebview可能存在与业务代码中、pod中、动静态库中，单单使用Xcode的查找是不行的。</p>\n<p>那么，要把大象装冰箱，拢共分几步？ 答：三步</p>\n<h3 id=\"第一步\"><a href=\"#第一步\" class=\"headerlink\" title=\"第一步\"></a>第一步</h3><p>控制台打开工程目录</p>\n<h3 id=\"第二部\"><a href=\"#第二部\" class=\"headerlink\" title=\"第二部\"></a>第二部</h3><p>输入命令</p>\n<pre><code>grep -R UIWebView *</code></pre><h3 id=\"第三步：\"><a href=\"#第三步：\" class=\"headerlink\" title=\"第三步：\"></a>第三步：</h3><p>把搜索出来的结果挨个干掉or升级，AFNetwork升级最新，微信SDK升级1.8.2以上，等等，注意有用到UIWebviewDelegate的也要干掉，不要给自己找麻烦。</p>\n<p>完成，鞠躬下台。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>自从去年开始苹果就发布了通知，禁用UIWebview，替换为WKWebview，继续使用会在提交时收到苹果粑粑的警告:</p>\n<blockquote>\n<p>ITMS-90809: Deprecated API Usage - Apple will no longer accept submissions of new apps that use UIWebView as of April 30, 2020 and app updates that use UIWebView as of December 2020. Instead, use WKWebView for improved security and reliability. Learn more (<a href=\"https://developer.apple.com/documentation/uikit/uiwebview\" target=\"_blank\" rel=\"noopener\">https://developer.apple.com/documentation/uikit/uiwebview</a>).</p>\n</blockquote>\n<p>UIWebview可能存在与业务代码中、pod中、动静态库中，单单使用Xcode的查找是不行的。</p>\n<p>那么，要把大象装冰箱，拢共分几步？ 答：三步</p>\n<h3 id=\"第一步\"><a href=\"#第一步\" class=\"headerlink\" title=\"第一步\"></a>第一步</h3><p>控制台打开工程目录</p>\n<h3 id=\"第二部\"><a href=\"#第二部\" class=\"headerlink\" title=\"第二部\"></a>第二部</h3><p>输入命令</p>\n<pre><code>grep -R UIWebView *</code></pre><h3 id=\"第三步：\"><a href=\"#第三步：\" class=\"headerlink\" title=\"第三步：\"></a>第三步：</h3><p>把搜索出来的结果挨个干掉or升级，AFNetwork升级最新，微信SDK升级1.8.2以上，等等，注意有用到UIWebviewDelegate的也要干掉，不要给自己找麻烦。</p>\n<p>完成，鞠躬下台。</p>\n"},{"title":"好用的软件下载网站","date":"2020-07-03T05:12:14.000Z","_content":"\n好用的Mac软件下载网:https://www.macwk.com/soft/sublime-text","source":"_posts/好用的软件下载网站.md","raw":"---\ntitle: 好用的软件下载网站\ndate: 2020-07-03 13:12:14\ntags:\n---\n\n好用的Mac软件下载网:https://www.macwk.com/soft/sublime-text","slug":"好用的软件下载网站","published":1,"updated":"2020-07-05T09:19:38.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgyxlit7000o0iu61cx294sw","content":"<p>好用的Mac软件下载网:<a href=\"https://www.macwk.com/soft/sublime-text\" target=\"_blank\" rel=\"noopener\">https://www.macwk.com/soft/sublime-text</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>好用的Mac软件下载网:<a href=\"https://www.macwk.com/soft/sublime-text\" target=\"_blank\" rel=\"noopener\">https://www.macwk.com/soft/sublime-text</a></p>\n"},{"title":"手q环境配置踩坑记","date":"2020-07-05T09:29:35.000Z","_content":"","source":"_posts/手q环境配置踩坑记.md","raw":"---\ntitle: 手q环境配置踩坑记\ndate: 2020-07-05 17:29:35\ntags:\n---\n","slug":"手q环境配置踩坑记","published":1,"updated":"2020-07-05T09:29:35.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgyxlit8000p0iu6e2fkg5ms","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"滤镜资料","date":"2020-08-13T17:37:20.000Z","_content":"\n# 滤镜\n\n###### 未读：\n* https://www.cnblogs.com/kenshincui/p/12181735.html\n* https://blog.csdn.net/u013282174/article/details/50128897\n* https://juejin.im/entry/6844903615123947528\n\n###### 已读：\n\n* https://www.jianshu.com/p/2e0ee2412114\n* http://sipdar.github.io/2015/01/23/ios%E5%BA%94%E7%94%A8%E4%B8%AD%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E6%BB%A4%E9%95%9C%E7%9A%84%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E6%96%B9%E6%B3%95/\n* 位图理解 https://blog.csdn.net/csdn66_2016/article/details/82850695\n\n有提到渲染框架：（重点看）\n* http://blog.itpub.net/69971523/viewspace-2695755/\n\n* https://xiaozhuanlan.com/topic/5094762183\n\n# 渲染框架\n\nhttps://iwiki.oa.tencent.com/pages/viewpage.action?pageId=40338726\n\nhttps://iwiki.oa.tencent.com/pages/viewpage.action?pageId=40338699\n\nhttps://iwiki.oa.tencent.com/pages/viewpage.action?pageId=40338716\n\n\n# 机器学习\n\nhttps://codelabs.developers.google.com/codelabs/tensorflow-lab1-helloworld/#0\n\nhttps://github.com/kevinjliang/tf-Faster-RCNN\n\nhttps://blog.csdn.net/leeyisong/article/details/92410325\n\nhttps://www.jianshu.com/p/dda97b547f95\n\nhttp://km.oa.com/group/19135/articles/show/275934?kmref=search&from_page=1&no=1\n\n\n# flutter\n\nhttps://www.infoq.cn/article/VBqfCIuwdjtU_CmcKaEu\n\n# 直播（美颜必看）\n\nhttps://www.jianshu.com/p/4646894245ba\nhttps://www.jianshu.com/p/bd42bacbe4cc\nhttps://www.jianshu.com/p/4646894245ba（美颜）\n\n\n# 卷积\n\nhttps://zhuanlan.zhihu.com/p/76606892","source":"_posts/滤镜资料.md","raw":"---\ntitle: 滤镜资料\ndate: 2020-08-14 01:37:20\ntags:\n---\n\n# 滤镜\n\n###### 未读：\n* https://www.cnblogs.com/kenshincui/p/12181735.html\n* https://blog.csdn.net/u013282174/article/details/50128897\n* https://juejin.im/entry/6844903615123947528\n\n###### 已读：\n\n* https://www.jianshu.com/p/2e0ee2412114\n* http://sipdar.github.io/2015/01/23/ios%E5%BA%94%E7%94%A8%E4%B8%AD%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E6%BB%A4%E9%95%9C%E7%9A%84%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E6%96%B9%E6%B3%95/\n* 位图理解 https://blog.csdn.net/csdn66_2016/article/details/82850695\n\n有提到渲染框架：（重点看）\n* http://blog.itpub.net/69971523/viewspace-2695755/\n\n* https://xiaozhuanlan.com/topic/5094762183\n\n# 渲染框架\n\nhttps://iwiki.oa.tencent.com/pages/viewpage.action?pageId=40338726\n\nhttps://iwiki.oa.tencent.com/pages/viewpage.action?pageId=40338699\n\nhttps://iwiki.oa.tencent.com/pages/viewpage.action?pageId=40338716\n\n\n# 机器学习\n\nhttps://codelabs.developers.google.com/codelabs/tensorflow-lab1-helloworld/#0\n\nhttps://github.com/kevinjliang/tf-Faster-RCNN\n\nhttps://blog.csdn.net/leeyisong/article/details/92410325\n\nhttps://www.jianshu.com/p/dda97b547f95\n\nhttp://km.oa.com/group/19135/articles/show/275934?kmref=search&from_page=1&no=1\n\n\n# flutter\n\nhttps://www.infoq.cn/article/VBqfCIuwdjtU_CmcKaEu\n\n# 直播（美颜必看）\n\nhttps://www.jianshu.com/p/4646894245ba\nhttps://www.jianshu.com/p/bd42bacbe4cc\nhttps://www.jianshu.com/p/4646894245ba（美颜）\n\n\n# 卷积\n\nhttps://zhuanlan.zhihu.com/p/76606892","slug":"滤镜资料","published":1,"updated":"2020-08-15T16:52:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgyxlit8000q0iu6h5n76xam","content":"<h1 id=\"滤镜\"><a href=\"#滤镜\" class=\"headerlink\" title=\"滤镜\"></a>滤镜</h1><h6 id=\"未读：\"><a href=\"#未读：\" class=\"headerlink\" title=\"未读：\"></a>未读：</h6><ul>\n<li><a href=\"https://www.cnblogs.com/kenshincui/p/12181735.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/kenshincui/p/12181735.html</a></li>\n<li><a href=\"https://blog.csdn.net/u013282174/article/details/50128897\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/u013282174/article/details/50128897</a></li>\n<li><a href=\"https://juejin.im/entry/6844903615123947528\" target=\"_blank\" rel=\"noopener\">https://juejin.im/entry/6844903615123947528</a></li>\n</ul>\n<h6 id=\"已读：\"><a href=\"#已读：\" class=\"headerlink\" title=\"已读：\"></a>已读：</h6><ul>\n<li><a href=\"https://www.jianshu.com/p/2e0ee2412114\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/2e0ee2412114</a></li>\n<li><a href=\"http://sipdar.github.io/2015/01/23/ios%E5%BA%94%E7%94%A8%E4%B8%AD%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E6%BB%A4%E9%95%9C%E7%9A%84%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E6%96%B9%E6%B3%95/\" target=\"_blank\" rel=\"noopener\">http://sipdar.github.io/2015/01/23/ios%E5%BA%94%E7%94%A8%E4%B8%AD%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E6%BB%A4%E9%95%9C%E7%9A%84%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E6%96%B9%E6%B3%95/</a></li>\n<li>位图理解 <a href=\"https://blog.csdn.net/csdn66_2016/article/details/82850695\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/csdn66_2016/article/details/82850695</a></li>\n</ul>\n<p>有提到渲染框架：（重点看）</p>\n<ul>\n<li><p><a href=\"http://blog.itpub.net/69971523/viewspace-2695755/\" target=\"_blank\" rel=\"noopener\">http://blog.itpub.net/69971523/viewspace-2695755/</a></p>\n</li>\n<li><p><a href=\"https://xiaozhuanlan.com/topic/5094762183\" target=\"_blank\" rel=\"noopener\">https://xiaozhuanlan.com/topic/5094762183</a></p>\n</li>\n</ul>\n<h1 id=\"渲染框架\"><a href=\"#渲染框架\" class=\"headerlink\" title=\"渲染框架\"></a>渲染框架</h1><p><a href=\"https://iwiki.oa.tencent.com/pages/viewpage.action?pageId=40338726\" target=\"_blank\" rel=\"noopener\">https://iwiki.oa.tencent.com/pages/viewpage.action?pageId=40338726</a></p>\n<p><a href=\"https://iwiki.oa.tencent.com/pages/viewpage.action?pageId=40338699\" target=\"_blank\" rel=\"noopener\">https://iwiki.oa.tencent.com/pages/viewpage.action?pageId=40338699</a></p>\n<p><a href=\"https://iwiki.oa.tencent.com/pages/viewpage.action?pageId=40338716\" target=\"_blank\" rel=\"noopener\">https://iwiki.oa.tencent.com/pages/viewpage.action?pageId=40338716</a></p>\n<h1 id=\"机器学习\"><a href=\"#机器学习\" class=\"headerlink\" title=\"机器学习\"></a>机器学习</h1><p><a href=\"https://codelabs.developers.google.com/codelabs/tensorflow-lab1-helloworld/#0\" target=\"_blank\" rel=\"noopener\">https://codelabs.developers.google.com/codelabs/tensorflow-lab1-helloworld/#0</a></p>\n<p><a href=\"https://github.com/kevinjliang/tf-Faster-RCNN\" target=\"_blank\" rel=\"noopener\">https://github.com/kevinjliang/tf-Faster-RCNN</a></p>\n<p><a href=\"https://blog.csdn.net/leeyisong/article/details/92410325\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/leeyisong/article/details/92410325</a></p>\n<p><a href=\"https://www.jianshu.com/p/dda97b547f95\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/dda97b547f95</a></p>\n<p><a href=\"http://km.oa.com/group/19135/articles/show/275934?kmref=search&amp;from_page=1&amp;no=1\" target=\"_blank\" rel=\"noopener\">http://km.oa.com/group/19135/articles/show/275934?kmref=search&amp;from_page=1&amp;no=1</a></p>\n<h1 id=\"flutter\"><a href=\"#flutter\" class=\"headerlink\" title=\"flutter\"></a>flutter</h1><p><a href=\"https://www.infoq.cn/article/VBqfCIuwdjtU_CmcKaEu\" target=\"_blank\" rel=\"noopener\">https://www.infoq.cn/article/VBqfCIuwdjtU_CmcKaEu</a></p>\n<h1 id=\"直播（美颜必看）\"><a href=\"#直播（美颜必看）\" class=\"headerlink\" title=\"直播（美颜必看）\"></a>直播（美颜必看）</h1><p><a href=\"https://www.jianshu.com/p/4646894245ba\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/4646894245ba</a><br><a href=\"https://www.jianshu.com/p/bd42bacbe4cc\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/bd42bacbe4cc</a><br><a href=\"https://www.jianshu.com/p/4646894245ba（美颜）\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/4646894245ba（美颜）</a></p>\n<h1 id=\"卷积\"><a href=\"#卷积\" class=\"headerlink\" title=\"卷积\"></a>卷积</h1><p><a href=\"https://zhuanlan.zhihu.com/p/76606892\" target=\"_blank\" rel=\"noopener\">https://zhuanlan.zhihu.com/p/76606892</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"滤镜\"><a href=\"#滤镜\" class=\"headerlink\" title=\"滤镜\"></a>滤镜</h1><h6 id=\"未读：\"><a href=\"#未读：\" class=\"headerlink\" title=\"未读：\"></a>未读：</h6><ul>\n<li><a href=\"https://www.cnblogs.com/kenshincui/p/12181735.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/kenshincui/p/12181735.html</a></li>\n<li><a href=\"https://blog.csdn.net/u013282174/article/details/50128897\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/u013282174/article/details/50128897</a></li>\n<li><a href=\"https://juejin.im/entry/6844903615123947528\" target=\"_blank\" rel=\"noopener\">https://juejin.im/entry/6844903615123947528</a></li>\n</ul>\n<h6 id=\"已读：\"><a href=\"#已读：\" class=\"headerlink\" title=\"已读：\"></a>已读：</h6><ul>\n<li><a href=\"https://www.jianshu.com/p/2e0ee2412114\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/2e0ee2412114</a></li>\n<li><a href=\"http://sipdar.github.io/2015/01/23/ios%E5%BA%94%E7%94%A8%E4%B8%AD%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E6%BB%A4%E9%95%9C%E7%9A%84%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E6%96%B9%E6%B3%95/\" target=\"_blank\" rel=\"noopener\">http://sipdar.github.io/2015/01/23/ios%E5%BA%94%E7%94%A8%E4%B8%AD%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E6%BB%A4%E9%95%9C%E7%9A%84%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E6%96%B9%E6%B3%95/</a></li>\n<li>位图理解 <a href=\"https://blog.csdn.net/csdn66_2016/article/details/82850695\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/csdn66_2016/article/details/82850695</a></li>\n</ul>\n<p>有提到渲染框架：（重点看）</p>\n<ul>\n<li><p><a href=\"http://blog.itpub.net/69971523/viewspace-2695755/\" target=\"_blank\" rel=\"noopener\">http://blog.itpub.net/69971523/viewspace-2695755/</a></p>\n</li>\n<li><p><a href=\"https://xiaozhuanlan.com/topic/5094762183\" target=\"_blank\" rel=\"noopener\">https://xiaozhuanlan.com/topic/5094762183</a></p>\n</li>\n</ul>\n<h1 id=\"渲染框架\"><a href=\"#渲染框架\" class=\"headerlink\" title=\"渲染框架\"></a>渲染框架</h1><p><a href=\"https://iwiki.oa.tencent.com/pages/viewpage.action?pageId=40338726\" target=\"_blank\" rel=\"noopener\">https://iwiki.oa.tencent.com/pages/viewpage.action?pageId=40338726</a></p>\n<p><a href=\"https://iwiki.oa.tencent.com/pages/viewpage.action?pageId=40338699\" target=\"_blank\" rel=\"noopener\">https://iwiki.oa.tencent.com/pages/viewpage.action?pageId=40338699</a></p>\n<p><a href=\"https://iwiki.oa.tencent.com/pages/viewpage.action?pageId=40338716\" target=\"_blank\" rel=\"noopener\">https://iwiki.oa.tencent.com/pages/viewpage.action?pageId=40338716</a></p>\n<h1 id=\"机器学习\"><a href=\"#机器学习\" class=\"headerlink\" title=\"机器学习\"></a>机器学习</h1><p><a href=\"https://codelabs.developers.google.com/codelabs/tensorflow-lab1-helloworld/#0\" target=\"_blank\" rel=\"noopener\">https://codelabs.developers.google.com/codelabs/tensorflow-lab1-helloworld/#0</a></p>\n<p><a href=\"https://github.com/kevinjliang/tf-Faster-RCNN\" target=\"_blank\" rel=\"noopener\">https://github.com/kevinjliang/tf-Faster-RCNN</a></p>\n<p><a href=\"https://blog.csdn.net/leeyisong/article/details/92410325\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/leeyisong/article/details/92410325</a></p>\n<p><a href=\"https://www.jianshu.com/p/dda97b547f95\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/dda97b547f95</a></p>\n<p><a href=\"http://km.oa.com/group/19135/articles/show/275934?kmref=search&amp;from_page=1&amp;no=1\" target=\"_blank\" rel=\"noopener\">http://km.oa.com/group/19135/articles/show/275934?kmref=search&amp;from_page=1&amp;no=1</a></p>\n<h1 id=\"flutter\"><a href=\"#flutter\" class=\"headerlink\" title=\"flutter\"></a>flutter</h1><p><a href=\"https://www.infoq.cn/article/VBqfCIuwdjtU_CmcKaEu\" target=\"_blank\" rel=\"noopener\">https://www.infoq.cn/article/VBqfCIuwdjtU_CmcKaEu</a></p>\n<h1 id=\"直播（美颜必看）\"><a href=\"#直播（美颜必看）\" class=\"headerlink\" title=\"直播（美颜必看）\"></a>直播（美颜必看）</h1><p><a href=\"https://www.jianshu.com/p/4646894245ba\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/4646894245ba</a><br><a href=\"https://www.jianshu.com/p/bd42bacbe4cc\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/bd42bacbe4cc</a><br><a href=\"https://www.jianshu.com/p/4646894245ba（美颜）\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/4646894245ba（美颜）</a></p>\n<h1 id=\"卷积\"><a href=\"#卷积\" class=\"headerlink\" title=\"卷积\"></a>卷积</h1><p><a href=\"https://zhuanlan.zhihu.com/p/76606892\" target=\"_blank\" rel=\"noopener\">https://zhuanlan.zhihu.com/p/76606892</a></p>\n"},{"title":"封装内嵌UICollectionView和UIPageControl的ScrollView","date":"2020-09-20T16:38:36.000Z","_content":"\n在需求中涉及到一个比较通用的控件，ScrollView里面嵌入CollectionView，封装一下，后面再有相同交互不用重复造轮子。\n\n##### 一。交互样式\n\n控件交互：\n![](http://km.oa.com/files/photos/pictures/201707/1501504788_13_w752_h510.jpg)\n\n\n如下类似样式都可以复用同一控件:\n![](http://km.oa.com/files/photos/pictures/201707/1501504866_52_w740_h416.jpg)\n![](http://km.oa.com/files/photos/pictures/201707/1501504879_57_w1468_h912.jpg)\n\n##### 二。接口\n\n* 接口\n\ninit的时候传入view布局相关的TBCollectionViewParamsModel参数；拿到数据后调用setDataList传入数据，展示CollectionScrollView。\n\n```\n@interface TBHorizontalItemListView : UIView\n\n- (instancetype)initWithFrame:(CGRect)frame collectionViewParamsModel:(TBCollectionViewParamsModel *)viewParams;\n\n- (void)setDataList:(NSArray<TBCollectionDataListModel *>*)listData;\n\n@end    \n\n```\n\n* 参数\n\n```\n@interface TBCollectionViewParamsModel : NSObject\n@property (nonatomic, assign) CGSize itemSize;                  //collectionView的cell大小\n@property (nonatomic, assign) CGFloat minimumInteritemSpacing;  //collectionView的cell间水平间距\n@property (nonatomic, assign) CGFloat minimumLineSpacing;       //collectionView的cell间的竖直间距\n@end\n\n\n@interface TBCollectionDataListModel : NSObject\n@property (nonatomic, retain) NSArray<id> *itemList;            //单个collectionView中的数据list\n@property (nonatomic, strong) Class cellClass;                  //单个collectionView中使用的cell类型, 需要实现TBCollectionViewCellProtocol\n@property (nonatomic, assign) int type;                         //扩展，暂时无用\n@end\n\n```\n\n##### 三。实现\n\n![](http://km.oa.com/files/photos/pictures/201707/1501504913_57_w718_h556.jpg)UICollectionViewUICollectionViewUICollectionViewUICollectionView\n\n\n* 灰色的是容器`View`\n* 紫色的是`UIScrollView`\n* 蓝色的是`UICollectionView`\n* 红色的是`UICollectionViewCell`\n* 下方小点点是`TBScrollPageControl`\n\n关键代码：\n\n根据setDataList传入的数据创建CollectionView并为其布局\n\n```\n- (void)initCollectionViews\n{\n    _bgScrollView.contentSize = CGSizeMake(TBHorizontalItemListViewWidth * _listData.count, 0);\n    \n    CGFloat x_offset = 0;\n    for (NSInteger i = 0; i < _listData.count; i++)\n    {\n        UICollectionViewFlowLayout *flowLayout = [self getCollectionViewFlowLayout:_viewParams];\n        \n        CGRect frame = CGRectMake(x_offset + 23 / 2, 20, TBHorizontalItemListViewWidth - 23, 199);\n        UICollectionView *collectionView = [[UICollectionView alloc] initWithFrame:frame collectionViewLayout:flowLayout];\n        collectionView.tag = 100+i;\n        collectionView.dataSource = self;\n        collectionView.delegate = self;\n        collectionView.alwaysBounceHorizontal = NO;\n        collectionView.alwaysBounceVertical = YES;\n        collectionView.backgroundColor = [UIColor colorWithWhite:0 alpha:0];\n        collectionView.showsHorizontalScrollIndicator = NO;\n        collectionView.showsVerticalScrollIndicator = NO;\n        collectionView.scrollEnabled = NO;\n        collectionView.backgroundColor = [UIColor blueColor];\n        [_bgScrollView addSubview:collectionView];\n        \n        Class cellClass = [_listData objectAtIndex:i].cellClass;\n        NSString *identifier = [NSString stringWithFormat:@\"ItemLandscapeCollectionCellIdentifier_%ld\",(long)collectionView.tag];\n        [collectionView registerClass:cellClass forCellWithReuseIdentifier:identifier];\n        \n        x_offset += TBHorizontalItemListViewWidth;\n        [collectionView reloadData];\n    }\n    [self layoutIfNeeded];\n}\n\n```\n\nCollectionView的代理：\n\n```\n#pragma mark - UICollectionDataSource\n\n- (CGSize)collectionView:(UICollectionView *)collectionView layout:(UICollectionViewLayout *)collectionViewLayout sizeForItemAtIndexPath:(NSIndexPath *)indexPath\n{\n    return _viewParams.itemSize;\n}\n\n- (NSInteger)collectionView:(UICollectionView *)collectionView numberOfItemsInSection:(NSInteger)section\n{\n    NSInteger groupIndex = collectionView.tag - 100;\n    return _listData[groupIndex].itemList.count;\n}\n\n- (UICollectionViewCell *)collectionView:(UICollectionView *)collectionView cellForItemAtIndexPath:(NSIndexPath *)indexPath\n{\n    /**取数据*/\n    NSInteger groupIndex = collectionView.tag - 100;\n    TBCollectionDataListModel *listModel = _listData[groupIndex];\n    id itemModel = listModel.itemList[indexPath.row];\n    \n    /**创建cell&&赋值*/\n    NSString *identifier = [NSString stringWithFormat:@\"ItemLandscapeCollectionCellIdentifier_%ld\",collectionView.tag];\n    UICollectionViewCell<TBCollectionViewCellProtocol> *cell = [collectionView dequeueReusableCellWithReuseIdentifier:identifier forIndexPath:indexPath];\n    if ([cell respondsToSelector:@selector(setModel:)])\n    {\n        [cell setModel:itemModel];\n    }\n    \n    return cell;\n}\n\n```\n","source":"_posts/封装内嵌UICollectionView和UIPageControl的ScrollView.md","raw":"---\ntitle: 封装内嵌UICollectionView和UIPageControl的ScrollView\ndate: 2020-09-21 00:38:36\ntags:\n---\n\n在需求中涉及到一个比较通用的控件，ScrollView里面嵌入CollectionView，封装一下，后面再有相同交互不用重复造轮子。\n\n##### 一。交互样式\n\n控件交互：\n![](http://km.oa.com/files/photos/pictures/201707/1501504788_13_w752_h510.jpg)\n\n\n如下类似样式都可以复用同一控件:\n![](http://km.oa.com/files/photos/pictures/201707/1501504866_52_w740_h416.jpg)\n![](http://km.oa.com/files/photos/pictures/201707/1501504879_57_w1468_h912.jpg)\n\n##### 二。接口\n\n* 接口\n\ninit的时候传入view布局相关的TBCollectionViewParamsModel参数；拿到数据后调用setDataList传入数据，展示CollectionScrollView。\n\n```\n@interface TBHorizontalItemListView : UIView\n\n- (instancetype)initWithFrame:(CGRect)frame collectionViewParamsModel:(TBCollectionViewParamsModel *)viewParams;\n\n- (void)setDataList:(NSArray<TBCollectionDataListModel *>*)listData;\n\n@end    \n\n```\n\n* 参数\n\n```\n@interface TBCollectionViewParamsModel : NSObject\n@property (nonatomic, assign) CGSize itemSize;                  //collectionView的cell大小\n@property (nonatomic, assign) CGFloat minimumInteritemSpacing;  //collectionView的cell间水平间距\n@property (nonatomic, assign) CGFloat minimumLineSpacing;       //collectionView的cell间的竖直间距\n@end\n\n\n@interface TBCollectionDataListModel : NSObject\n@property (nonatomic, retain) NSArray<id> *itemList;            //单个collectionView中的数据list\n@property (nonatomic, strong) Class cellClass;                  //单个collectionView中使用的cell类型, 需要实现TBCollectionViewCellProtocol\n@property (nonatomic, assign) int type;                         //扩展，暂时无用\n@end\n\n```\n\n##### 三。实现\n\n![](http://km.oa.com/files/photos/pictures/201707/1501504913_57_w718_h556.jpg)UICollectionViewUICollectionViewUICollectionViewUICollectionView\n\n\n* 灰色的是容器`View`\n* 紫色的是`UIScrollView`\n* 蓝色的是`UICollectionView`\n* 红色的是`UICollectionViewCell`\n* 下方小点点是`TBScrollPageControl`\n\n关键代码：\n\n根据setDataList传入的数据创建CollectionView并为其布局\n\n```\n- (void)initCollectionViews\n{\n    _bgScrollView.contentSize = CGSizeMake(TBHorizontalItemListViewWidth * _listData.count, 0);\n    \n    CGFloat x_offset = 0;\n    for (NSInteger i = 0; i < _listData.count; i++)\n    {\n        UICollectionViewFlowLayout *flowLayout = [self getCollectionViewFlowLayout:_viewParams];\n        \n        CGRect frame = CGRectMake(x_offset + 23 / 2, 20, TBHorizontalItemListViewWidth - 23, 199);\n        UICollectionView *collectionView = [[UICollectionView alloc] initWithFrame:frame collectionViewLayout:flowLayout];\n        collectionView.tag = 100+i;\n        collectionView.dataSource = self;\n        collectionView.delegate = self;\n        collectionView.alwaysBounceHorizontal = NO;\n        collectionView.alwaysBounceVertical = YES;\n        collectionView.backgroundColor = [UIColor colorWithWhite:0 alpha:0];\n        collectionView.showsHorizontalScrollIndicator = NO;\n        collectionView.showsVerticalScrollIndicator = NO;\n        collectionView.scrollEnabled = NO;\n        collectionView.backgroundColor = [UIColor blueColor];\n        [_bgScrollView addSubview:collectionView];\n        \n        Class cellClass = [_listData objectAtIndex:i].cellClass;\n        NSString *identifier = [NSString stringWithFormat:@\"ItemLandscapeCollectionCellIdentifier_%ld\",(long)collectionView.tag];\n        [collectionView registerClass:cellClass forCellWithReuseIdentifier:identifier];\n        \n        x_offset += TBHorizontalItemListViewWidth;\n        [collectionView reloadData];\n    }\n    [self layoutIfNeeded];\n}\n\n```\n\nCollectionView的代理：\n\n```\n#pragma mark - UICollectionDataSource\n\n- (CGSize)collectionView:(UICollectionView *)collectionView layout:(UICollectionViewLayout *)collectionViewLayout sizeForItemAtIndexPath:(NSIndexPath *)indexPath\n{\n    return _viewParams.itemSize;\n}\n\n- (NSInteger)collectionView:(UICollectionView *)collectionView numberOfItemsInSection:(NSInteger)section\n{\n    NSInteger groupIndex = collectionView.tag - 100;\n    return _listData[groupIndex].itemList.count;\n}\n\n- (UICollectionViewCell *)collectionView:(UICollectionView *)collectionView cellForItemAtIndexPath:(NSIndexPath *)indexPath\n{\n    /**取数据*/\n    NSInteger groupIndex = collectionView.tag - 100;\n    TBCollectionDataListModel *listModel = _listData[groupIndex];\n    id itemModel = listModel.itemList[indexPath.row];\n    \n    /**创建cell&&赋值*/\n    NSString *identifier = [NSString stringWithFormat:@\"ItemLandscapeCollectionCellIdentifier_%ld\",collectionView.tag];\n    UICollectionViewCell<TBCollectionViewCellProtocol> *cell = [collectionView dequeueReusableCellWithReuseIdentifier:identifier forIndexPath:indexPath];\n    if ([cell respondsToSelector:@selector(setModel:)])\n    {\n        [cell setModel:itemModel];\n    }\n    \n    return cell;\n}\n\n```\n","slug":"封装内嵌UICollectionView和UIPageControl的ScrollView","published":1,"updated":"2020-09-22T08:36:14.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgyxlit9000r0iu664yk7vn1","content":"<p>在需求中涉及到一个比较通用的控件，ScrollView里面嵌入CollectionView，封装一下，后面再有相同交互不用重复造轮子。</p>\n<h5 id=\"一。交互样式\"><a href=\"#一。交互样式\" class=\"headerlink\" title=\"一。交互样式\"></a>一。交互样式</h5><p>控件交互：<br><img src=\"http://km.oa.com/files/photos/pictures/201707/1501504788_13_w752_h510.jpg\" alt=\"\"></p>\n<p>如下类似样式都可以复用同一控件:<br><img src=\"http://km.oa.com/files/photos/pictures/201707/1501504866_52_w740_h416.jpg\" alt=\"\"><br><img src=\"http://km.oa.com/files/photos/pictures/201707/1501504879_57_w1468_h912.jpg\" alt=\"\"></p>\n<h5 id=\"二。接口\"><a href=\"#二。接口\" class=\"headerlink\" title=\"二。接口\"></a>二。接口</h5><ul>\n<li>接口</li>\n</ul>\n<p>init的时候传入view布局相关的TBCollectionViewParamsModel参数；拿到数据后调用setDataList传入数据，展示CollectionScrollView。</p>\n<pre><code>@interface TBHorizontalItemListView : UIView\n\n- (instancetype)initWithFrame:(CGRect)frame collectionViewParamsModel:(TBCollectionViewParamsModel *)viewParams;\n\n- (void)setDataList:(NSArray&lt;TBCollectionDataListModel *&gt;*)listData;\n\n@end    \n</code></pre><ul>\n<li>参数</li>\n</ul>\n<pre><code>@interface TBCollectionViewParamsModel : NSObject\n@property (nonatomic, assign) CGSize itemSize;                  //collectionView的cell大小\n@property (nonatomic, assign) CGFloat minimumInteritemSpacing;  //collectionView的cell间水平间距\n@property (nonatomic, assign) CGFloat minimumLineSpacing;       //collectionView的cell间的竖直间距\n@end\n\n\n@interface TBCollectionDataListModel : NSObject\n@property (nonatomic, retain) NSArray&lt;id&gt; *itemList;            //单个collectionView中的数据list\n@property (nonatomic, strong) Class cellClass;                  //单个collectionView中使用的cell类型, 需要实现TBCollectionViewCellProtocol\n@property (nonatomic, assign) int type;                         //扩展，暂时无用\n@end\n</code></pre><h5 id=\"三。实现\"><a href=\"#三。实现\" class=\"headerlink\" title=\"三。实现\"></a>三。实现</h5><p><img src=\"http://km.oa.com/files/photos/pictures/201707/1501504913_57_w718_h556.jpg\" alt=\"\">UICollectionViewUICollectionViewUICollectionViewUICollectionView</p>\n<ul>\n<li>灰色的是容器<code>View</code></li>\n<li>紫色的是<code>UIScrollView</code></li>\n<li>蓝色的是<code>UICollectionView</code></li>\n<li>红色的是<code>UICollectionViewCell</code></li>\n<li>下方小点点是<code>TBScrollPageControl</code></li>\n</ul>\n<p>关键代码：</p>\n<p>根据setDataList传入的数据创建CollectionView并为其布局</p>\n<pre><code>- (void)initCollectionViews\n{\n    _bgScrollView.contentSize = CGSizeMake(TBHorizontalItemListViewWidth * _listData.count, 0);\n\n    CGFloat x_offset = 0;\n    for (NSInteger i = 0; i &lt; _listData.count; i++)\n    {\n        UICollectionViewFlowLayout *flowLayout = [self getCollectionViewFlowLayout:_viewParams];\n\n        CGRect frame = CGRectMake(x_offset + 23 / 2, 20, TBHorizontalItemListViewWidth - 23, 199);\n        UICollectionView *collectionView = [[UICollectionView alloc] initWithFrame:frame collectionViewLayout:flowLayout];\n        collectionView.tag = 100+i;\n        collectionView.dataSource = self;\n        collectionView.delegate = self;\n        collectionView.alwaysBounceHorizontal = NO;\n        collectionView.alwaysBounceVertical = YES;\n        collectionView.backgroundColor = [UIColor colorWithWhite:0 alpha:0];\n        collectionView.showsHorizontalScrollIndicator = NO;\n        collectionView.showsVerticalScrollIndicator = NO;\n        collectionView.scrollEnabled = NO;\n        collectionView.backgroundColor = [UIColor blueColor];\n        [_bgScrollView addSubview:collectionView];\n\n        Class cellClass = [_listData objectAtIndex:i].cellClass;\n        NSString *identifier = [NSString stringWithFormat:@&quot;ItemLandscapeCollectionCellIdentifier_%ld&quot;,(long)collectionView.tag];\n        [collectionView registerClass:cellClass forCellWithReuseIdentifier:identifier];\n\n        x_offset += TBHorizontalItemListViewWidth;\n        [collectionView reloadData];\n    }\n    [self layoutIfNeeded];\n}\n</code></pre><p>CollectionView的代理：</p>\n<pre><code>#pragma mark - UICollectionDataSource\n\n- (CGSize)collectionView:(UICollectionView *)collectionView layout:(UICollectionViewLayout *)collectionViewLayout sizeForItemAtIndexPath:(NSIndexPath *)indexPath\n{\n    return _viewParams.itemSize;\n}\n\n- (NSInteger)collectionView:(UICollectionView *)collectionView numberOfItemsInSection:(NSInteger)section\n{\n    NSInteger groupIndex = collectionView.tag - 100;\n    return _listData[groupIndex].itemList.count;\n}\n\n- (UICollectionViewCell *)collectionView:(UICollectionView *)collectionView cellForItemAtIndexPath:(NSIndexPath *)indexPath\n{\n    /**取数据*/\n    NSInteger groupIndex = collectionView.tag - 100;\n    TBCollectionDataListModel *listModel = _listData[groupIndex];\n    id itemModel = listModel.itemList[indexPath.row];\n\n    /**创建cell&amp;&amp;赋值*/\n    NSString *identifier = [NSString stringWithFormat:@&quot;ItemLandscapeCollectionCellIdentifier_%ld&quot;,collectionView.tag];\n    UICollectionViewCell&lt;TBCollectionViewCellProtocol&gt; *cell = [collectionView dequeueReusableCellWithReuseIdentifier:identifier forIndexPath:indexPath];\n    if ([cell respondsToSelector:@selector(setModel:)])\n    {\n        [cell setModel:itemModel];\n    }\n\n    return cell;\n}\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<p>在需求中涉及到一个比较通用的控件，ScrollView里面嵌入CollectionView，封装一下，后面再有相同交互不用重复造轮子。</p>\n<h5 id=\"一。交互样式\"><a href=\"#一。交互样式\" class=\"headerlink\" title=\"一。交互样式\"></a>一。交互样式</h5><p>控件交互：<br><img src=\"http://km.oa.com/files/photos/pictures/201707/1501504788_13_w752_h510.jpg\" alt=\"\"></p>\n<p>如下类似样式都可以复用同一控件:<br><img src=\"http://km.oa.com/files/photos/pictures/201707/1501504866_52_w740_h416.jpg\" alt=\"\"><br><img src=\"http://km.oa.com/files/photos/pictures/201707/1501504879_57_w1468_h912.jpg\" alt=\"\"></p>\n<h5 id=\"二。接口\"><a href=\"#二。接口\" class=\"headerlink\" title=\"二。接口\"></a>二。接口</h5><ul>\n<li>接口</li>\n</ul>\n<p>init的时候传入view布局相关的TBCollectionViewParamsModel参数；拿到数据后调用setDataList传入数据，展示CollectionScrollView。</p>\n<pre><code>@interface TBHorizontalItemListView : UIView\n\n- (instancetype)initWithFrame:(CGRect)frame collectionViewParamsModel:(TBCollectionViewParamsModel *)viewParams;\n\n- (void)setDataList:(NSArray&lt;TBCollectionDataListModel *&gt;*)listData;\n\n@end    \n</code></pre><ul>\n<li>参数</li>\n</ul>\n<pre><code>@interface TBCollectionViewParamsModel : NSObject\n@property (nonatomic, assign) CGSize itemSize;                  //collectionView的cell大小\n@property (nonatomic, assign) CGFloat minimumInteritemSpacing;  //collectionView的cell间水平间距\n@property (nonatomic, assign) CGFloat minimumLineSpacing;       //collectionView的cell间的竖直间距\n@end\n\n\n@interface TBCollectionDataListModel : NSObject\n@property (nonatomic, retain) NSArray&lt;id&gt; *itemList;            //单个collectionView中的数据list\n@property (nonatomic, strong) Class cellClass;                  //单个collectionView中使用的cell类型, 需要实现TBCollectionViewCellProtocol\n@property (nonatomic, assign) int type;                         //扩展，暂时无用\n@end\n</code></pre><h5 id=\"三。实现\"><a href=\"#三。实现\" class=\"headerlink\" title=\"三。实现\"></a>三。实现</h5><p><img src=\"http://km.oa.com/files/photos/pictures/201707/1501504913_57_w718_h556.jpg\" alt=\"\">UICollectionViewUICollectionViewUICollectionViewUICollectionView</p>\n<ul>\n<li>灰色的是容器<code>View</code></li>\n<li>紫色的是<code>UIScrollView</code></li>\n<li>蓝色的是<code>UICollectionView</code></li>\n<li>红色的是<code>UICollectionViewCell</code></li>\n<li>下方小点点是<code>TBScrollPageControl</code></li>\n</ul>\n<p>关键代码：</p>\n<p>根据setDataList传入的数据创建CollectionView并为其布局</p>\n<pre><code>- (void)initCollectionViews\n{\n    _bgScrollView.contentSize = CGSizeMake(TBHorizontalItemListViewWidth * _listData.count, 0);\n\n    CGFloat x_offset = 0;\n    for (NSInteger i = 0; i &lt; _listData.count; i++)\n    {\n        UICollectionViewFlowLayout *flowLayout = [self getCollectionViewFlowLayout:_viewParams];\n\n        CGRect frame = CGRectMake(x_offset + 23 / 2, 20, TBHorizontalItemListViewWidth - 23, 199);\n        UICollectionView *collectionView = [[UICollectionView alloc] initWithFrame:frame collectionViewLayout:flowLayout];\n        collectionView.tag = 100+i;\n        collectionView.dataSource = self;\n        collectionView.delegate = self;\n        collectionView.alwaysBounceHorizontal = NO;\n        collectionView.alwaysBounceVertical = YES;\n        collectionView.backgroundColor = [UIColor colorWithWhite:0 alpha:0];\n        collectionView.showsHorizontalScrollIndicator = NO;\n        collectionView.showsVerticalScrollIndicator = NO;\n        collectionView.scrollEnabled = NO;\n        collectionView.backgroundColor = [UIColor blueColor];\n        [_bgScrollView addSubview:collectionView];\n\n        Class cellClass = [_listData objectAtIndex:i].cellClass;\n        NSString *identifier = [NSString stringWithFormat:@&quot;ItemLandscapeCollectionCellIdentifier_%ld&quot;,(long)collectionView.tag];\n        [collectionView registerClass:cellClass forCellWithReuseIdentifier:identifier];\n\n        x_offset += TBHorizontalItemListViewWidth;\n        [collectionView reloadData];\n    }\n    [self layoutIfNeeded];\n}\n</code></pre><p>CollectionView的代理：</p>\n<pre><code>#pragma mark - UICollectionDataSource\n\n- (CGSize)collectionView:(UICollectionView *)collectionView layout:(UICollectionViewLayout *)collectionViewLayout sizeForItemAtIndexPath:(NSIndexPath *)indexPath\n{\n    return _viewParams.itemSize;\n}\n\n- (NSInteger)collectionView:(UICollectionView *)collectionView numberOfItemsInSection:(NSInteger)section\n{\n    NSInteger groupIndex = collectionView.tag - 100;\n    return _listData[groupIndex].itemList.count;\n}\n\n- (UICollectionViewCell *)collectionView:(UICollectionView *)collectionView cellForItemAtIndexPath:(NSIndexPath *)indexPath\n{\n    /**取数据*/\n    NSInteger groupIndex = collectionView.tag - 100;\n    TBCollectionDataListModel *listModel = _listData[groupIndex];\n    id itemModel = listModel.itemList[indexPath.row];\n\n    /**创建cell&amp;&amp;赋值*/\n    NSString *identifier = [NSString stringWithFormat:@&quot;ItemLandscapeCollectionCellIdentifier_%ld&quot;,collectionView.tag];\n    UICollectionViewCell&lt;TBCollectionViewCellProtocol&gt; *cell = [collectionView dequeueReusableCellWithReuseIdentifier:identifier forIndexPath:indexPath];\n    if ([cell respondsToSelector:@selector(setModel:)])\n    {\n        [cell setModel:itemModel];\n    }\n\n    return cell;\n}\n</code></pre>"},{"_content":"# 蓝盾打包问题梳理\n\n## Ld /Users/bkdevops/workspace/p-a62516f9cdb041218e847a13e0879228/src/ios/deriveddata/Build/Intermediates.noindex/Pods.build/Release-iphoneos/TransferModule.build/Objects-normal/armv7/Binary/TransferModule normal armv7(1 failure)\n\n* 原因：\n    TransferModule中缺少32位架构（armv7），此模块为log模块，其中使用的是微信提供的xlog组件，由于xlog不再支持32位架构，所以TransferModule中也没法支持。\n\n* 解决：\n    app中最低支持ios11，不支持32位架构无所谓的，直接在xcode中删掉armv7。\n\n## flutter pub get 失败 \n\nBecause flutter_caige depends on flutter_localizations any from sdk which depends on intl 0.16.1, intl 0.16.1 is required.\nSo, because flutter_caige depends on intl 0.16.0, version solving failed.\n    \n* 原因：\n    flutter版本冲突\n\n* 解决：\n    如果是两个依赖的依赖冲突，不清楚当前到底应该使用依赖的哪一个版本时，我们可以使用any来解决版本依赖版本冲突的问题。由于不推荐使用any依赖，我们需要在pubspec.lock中找到正确的版本替换。\n如果还是提示冲突，我们可以在 pubspec.yaml 添加","source":"_posts/蓝盾打包问题梳理.md","raw":"# 蓝盾打包问题梳理\n\n## Ld /Users/bkdevops/workspace/p-a62516f9cdb041218e847a13e0879228/src/ios/deriveddata/Build/Intermediates.noindex/Pods.build/Release-iphoneos/TransferModule.build/Objects-normal/armv7/Binary/TransferModule normal armv7(1 failure)\n\n* 原因：\n    TransferModule中缺少32位架构（armv7），此模块为log模块，其中使用的是微信提供的xlog组件，由于xlog不再支持32位架构，所以TransferModule中也没法支持。\n\n* 解决：\n    app中最低支持ios11，不支持32位架构无所谓的，直接在xcode中删掉armv7。\n\n## flutter pub get 失败 \n\nBecause flutter_caige depends on flutter_localizations any from sdk which depends on intl 0.16.1, intl 0.16.1 is required.\nSo, because flutter_caige depends on intl 0.16.0, version solving failed.\n    \n* 原因：\n    flutter版本冲突\n\n* 解决：\n    如果是两个依赖的依赖冲突，不清楚当前到底应该使用依赖的哪一个版本时，我们可以使用any来解决版本依赖版本冲突的问题。由于不推荐使用any依赖，我们需要在pubspec.lock中找到正确的版本替换。\n如果还是提示冲突，我们可以在 pubspec.yaml 添加","slug":"蓝盾打包问题梳理","published":1,"date":"2020-06-09T07:12:51.000Z","updated":"2020-06-21T14:37:42.000Z","title":"蓝盾打包问题梳理","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgyxlit9000s0iu6d9hygr5j","content":"<h1 id=\"蓝盾打包问题梳理\"><a href=\"#蓝盾打包问题梳理\" class=\"headerlink\" title=\"蓝盾打包问题梳理\"></a>蓝盾打包问题梳理</h1><h2 id=\"Ld-Users-bkdevops-workspace-p-a62516f9cdb041218e847a13e0879228-src-ios-deriveddata-Build-Intermediates-noindex-Pods-build-Release-iphoneos-TransferModule-build-Objects-normal-armv7-Binary-TransferModule-normal-armv7-1-failure\"><a href=\"#Ld-Users-bkdevops-workspace-p-a62516f9cdb041218e847a13e0879228-src-ios-deriveddata-Build-Intermediates-noindex-Pods-build-Release-iphoneos-TransferModule-build-Objects-normal-armv7-Binary-TransferModule-normal-armv7-1-failure\" class=\"headerlink\" title=\"Ld /Users/bkdevops/workspace/p-a62516f9cdb041218e847a13e0879228/src/ios/deriveddata/Build/Intermediates.noindex/Pods.build/Release-iphoneos/TransferModule.build/Objects-normal/armv7/Binary/TransferModule normal armv7(1 failure)\"></a>Ld /Users/bkdevops/workspace/p-a62516f9cdb041218e847a13e0879228/src/ios/deriveddata/Build/Intermediates.noindex/Pods.build/Release-iphoneos/TransferModule.build/Objects-normal/armv7/Binary/TransferModule normal armv7(1 failure)</h2><ul>\n<li><p>原因：<br>  TransferModule中缺少32位架构（armv7），此模块为log模块，其中使用的是微信提供的xlog组件，由于xlog不再支持32位架构，所以TransferModule中也没法支持。</p>\n</li>\n<li><p>解决：<br>  app中最低支持ios11，不支持32位架构无所谓的，直接在xcode中删掉armv7。</p>\n</li>\n</ul>\n<h2 id=\"flutter-pub-get-失败\"><a href=\"#flutter-pub-get-失败\" class=\"headerlink\" title=\"flutter pub get 失败\"></a>flutter pub get 失败</h2><p>Because flutter_caige depends on flutter_localizations any from sdk which depends on intl 0.16.1, intl 0.16.1 is required.<br>So, because flutter_caige depends on intl 0.16.0, version solving failed.</p>\n<ul>\n<li><p>原因：<br>  flutter版本冲突</p>\n</li>\n<li><p>解决：<br>  如果是两个依赖的依赖冲突，不清楚当前到底应该使用依赖的哪一个版本时，我们可以使用any来解决版本依赖版本冲突的问题。由于不推荐使用any依赖，我们需要在pubspec.lock中找到正确的版本替换。<br>如果还是提示冲突，我们可以在 pubspec.yaml 添加</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"蓝盾打包问题梳理\"><a href=\"#蓝盾打包问题梳理\" class=\"headerlink\" title=\"蓝盾打包问题梳理\"></a>蓝盾打包问题梳理</h1><h2 id=\"Ld-Users-bkdevops-workspace-p-a62516f9cdb041218e847a13e0879228-src-ios-deriveddata-Build-Intermediates-noindex-Pods-build-Release-iphoneos-TransferModule-build-Objects-normal-armv7-Binary-TransferModule-normal-armv7-1-failure\"><a href=\"#Ld-Users-bkdevops-workspace-p-a62516f9cdb041218e847a13e0879228-src-ios-deriveddata-Build-Intermediates-noindex-Pods-build-Release-iphoneos-TransferModule-build-Objects-normal-armv7-Binary-TransferModule-normal-armv7-1-failure\" class=\"headerlink\" title=\"Ld /Users/bkdevops/workspace/p-a62516f9cdb041218e847a13e0879228/src/ios/deriveddata/Build/Intermediates.noindex/Pods.build/Release-iphoneos/TransferModule.build/Objects-normal/armv7/Binary/TransferModule normal armv7(1 failure)\"></a>Ld /Users/bkdevops/workspace/p-a62516f9cdb041218e847a13e0879228/src/ios/deriveddata/Build/Intermediates.noindex/Pods.build/Release-iphoneos/TransferModule.build/Objects-normal/armv7/Binary/TransferModule normal armv7(1 failure)</h2><ul>\n<li><p>原因：<br>  TransferModule中缺少32位架构（armv7），此模块为log模块，其中使用的是微信提供的xlog组件，由于xlog不再支持32位架构，所以TransferModule中也没法支持。</p>\n</li>\n<li><p>解决：<br>  app中最低支持ios11，不支持32位架构无所谓的，直接在xcode中删掉armv7。</p>\n</li>\n</ul>\n<h2 id=\"flutter-pub-get-失败\"><a href=\"#flutter-pub-get-失败\" class=\"headerlink\" title=\"flutter pub get 失败\"></a>flutter pub get 失败</h2><p>Because flutter_caige depends on flutter_localizations any from sdk which depends on intl 0.16.1, intl 0.16.1 is required.<br>So, because flutter_caige depends on intl 0.16.0, version solving failed.</p>\n<ul>\n<li><p>原因：<br>  flutter版本冲突</p>\n</li>\n<li><p>解决：<br>  如果是两个依赖的依赖冲突，不清楚当前到底应该使用依赖的哪一个版本时，我们可以使用any来解决版本依赖版本冲突的问题。由于不推荐使用any依赖，我们需要在pubspec.lock中找到正确的版本替换。<br>如果还是提示冲突，我们可以在 pubspec.yaml 添加</p>\n</li>\n</ul>\n"},{"title":"初次了解PCB绘制--EasyEDA","date":"2020-06-27T17:24:10.000Z","_content":"\n# 我的第一个工程\n\nhttps://lceda.cn/editor#id=bec11a44208e462994f74192811a24ab|!67c750aa59d74407b9d5c4ca6edaee0d|!8fa90b7551854cb98dad0053bd830eb5\n\n![](https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2020/06/29/15933667080055.jpg)\n\n![](https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2020/06/29/15933667235935.jpg)\n\n\n# EasyEDA文档\nhttps://docs.lceda.cn/cn/FAQ/Editor/index.html\n\n# EasyEDA在线编辑器\n\nhttps://lceda.cn/editor#mode=sim,id=c052c1fb39544d508f6000496171eeeb|be1ffcf396934f28b35307be5b446824|8352c415a15a4fd6a33946d85d8625d2\n\n\n# 视频资料\n\nhttps://www.youtube.com/watch?v=35YuILUlfGs\nhttps://www.youtube.com/watch?v=utBQqcuOt9U&t=539s\n\n# 打板网站\n\nhttps://jlcpcb.com/\n\n","source":"_posts/初次了解PCB绘制-EasyEDA.md","raw":"---\ntitle: 初次了解PCB绘制--EasyEDA\ndate: 2020-06-28 01:24:10\ntags:\n---\n\n# 我的第一个工程\n\nhttps://lceda.cn/editor#id=bec11a44208e462994f74192811a24ab|!67c750aa59d74407b9d5c4ca6edaee0d|!8fa90b7551854cb98dad0053bd830eb5\n\n![](https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2020/06/29/15933667080055.jpg)\n\n![](https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2020/06/29/15933667235935.jpg)\n\n\n# EasyEDA文档\nhttps://docs.lceda.cn/cn/FAQ/Editor/index.html\n\n# EasyEDA在线编辑器\n\nhttps://lceda.cn/editor#mode=sim,id=c052c1fb39544d508f6000496171eeeb|be1ffcf396934f28b35307be5b446824|8352c415a15a4fd6a33946d85d8625d2\n\n\n# 视频资料\n\nhttps://www.youtube.com/watch?v=35YuILUlfGs\nhttps://www.youtube.com/watch?v=utBQqcuOt9U&t=539s\n\n# 打板网站\n\nhttps://jlcpcb.com/\n\n","slug":"初次了解PCB绘制-EasyEDA","published":1,"updated":"2020-06-28T18:41:21.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgyxlita000t0iu6f56rfohu","content":"<h1 id=\"我的第一个工程\"><a href=\"#我的第一个工程\" class=\"headerlink\" title=\"我的第一个工程\"></a>我的第一个工程</h1><p><a href=\"https://lceda.cn/editor#id=bec11a44208e462994f74192811a24ab|!67c750aa59d74407b9d5c4ca6edaee0d|!8fa90b7551854cb98dad0053bd830eb5\" target=\"_blank\" rel=\"noopener\">https://lceda.cn/editor#id=bec11a44208e462994f74192811a24ab|!67c750aa59d74407b9d5c4ca6edaee0d|!8fa90b7551854cb98dad0053bd830eb5</a></p>\n<p><img src=\"https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2020/06/29/15933667080055.jpg\" alt=\"\"></p>\n<p><img src=\"https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2020/06/29/15933667235935.jpg\" alt=\"\"></p>\n<h1 id=\"EasyEDA文档\"><a href=\"#EasyEDA文档\" class=\"headerlink\" title=\"EasyEDA文档\"></a>EasyEDA文档</h1><p><a href=\"https://docs.lceda.cn/cn/FAQ/Editor/index.html\" target=\"_blank\" rel=\"noopener\">https://docs.lceda.cn/cn/FAQ/Editor/index.html</a></p>\n<h1 id=\"EasyEDA在线编辑器\"><a href=\"#EasyEDA在线编辑器\" class=\"headerlink\" title=\"EasyEDA在线编辑器\"></a>EasyEDA在线编辑器</h1><p><a href=\"https://lceda.cn/editor#mode=sim,id=c052c1fb39544d508f6000496171eeeb|be1ffcf396934f28b35307be5b446824|8352c415a15a4fd6a33946d85d8625d2\" target=\"_blank\" rel=\"noopener\">https://lceda.cn/editor#mode=sim,id=c052c1fb39544d508f6000496171eeeb|be1ffcf396934f28b35307be5b446824|8352c415a15a4fd6a33946d85d8625d2</a></p>\n<h1 id=\"视频资料\"><a href=\"#视频资料\" class=\"headerlink\" title=\"视频资料\"></a>视频资料</h1><p><a href=\"https://www.youtube.com/watch?v=35YuILUlfGs\" target=\"_blank\" rel=\"noopener\">https://www.youtube.com/watch?v=35YuILUlfGs</a><br><a href=\"https://www.youtube.com/watch?v=utBQqcuOt9U&amp;t=539s\" target=\"_blank\" rel=\"noopener\">https://www.youtube.com/watch?v=utBQqcuOt9U&amp;t=539s</a></p>\n<h1 id=\"打板网站\"><a href=\"#打板网站\" class=\"headerlink\" title=\"打板网站\"></a>打板网站</h1><p><a href=\"https://jlcpcb.com/\" target=\"_blank\" rel=\"noopener\">https://jlcpcb.com/</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"我的第一个工程\"><a href=\"#我的第一个工程\" class=\"headerlink\" title=\"我的第一个工程\"></a>我的第一个工程</h1><p><a href=\"https://lceda.cn/editor#id=bec11a44208e462994f74192811a24ab|!67c750aa59d74407b9d5c4ca6edaee0d|!8fa90b7551854cb98dad0053bd830eb5\" target=\"_blank\" rel=\"noopener\">https://lceda.cn/editor#id=bec11a44208e462994f74192811a24ab|!67c750aa59d74407b9d5c4ca6edaee0d|!8fa90b7551854cb98dad0053bd830eb5</a></p>\n<p><img src=\"https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2020/06/29/15933667080055.jpg\" alt=\"\"></p>\n<p><img src=\"https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2020/06/29/15933667235935.jpg\" alt=\"\"></p>\n<h1 id=\"EasyEDA文档\"><a href=\"#EasyEDA文档\" class=\"headerlink\" title=\"EasyEDA文档\"></a>EasyEDA文档</h1><p><a href=\"https://docs.lceda.cn/cn/FAQ/Editor/index.html\" target=\"_blank\" rel=\"noopener\">https://docs.lceda.cn/cn/FAQ/Editor/index.html</a></p>\n<h1 id=\"EasyEDA在线编辑器\"><a href=\"#EasyEDA在线编辑器\" class=\"headerlink\" title=\"EasyEDA在线编辑器\"></a>EasyEDA在线编辑器</h1><p><a href=\"https://lceda.cn/editor#mode=sim,id=c052c1fb39544d508f6000496171eeeb|be1ffcf396934f28b35307be5b446824|8352c415a15a4fd6a33946d85d8625d2\" target=\"_blank\" rel=\"noopener\">https://lceda.cn/editor#mode=sim,id=c052c1fb39544d508f6000496171eeeb|be1ffcf396934f28b35307be5b446824|8352c415a15a4fd6a33946d85d8625d2</a></p>\n<h1 id=\"视频资料\"><a href=\"#视频资料\" class=\"headerlink\" title=\"视频资料\"></a>视频资料</h1><p><a href=\"https://www.youtube.com/watch?v=35YuILUlfGs\" target=\"_blank\" rel=\"noopener\">https://www.youtube.com/watch?v=35YuILUlfGs</a><br><a href=\"https://www.youtube.com/watch?v=utBQqcuOt9U&amp;t=539s\" target=\"_blank\" rel=\"noopener\">https://www.youtube.com/watch?v=utBQqcuOt9U&amp;t=539s</a></p>\n<h1 id=\"打板网站\"><a href=\"#打板网站\" class=\"headerlink\" title=\"打板网站\"></a>打板网站</h1><p><a href=\"https://jlcpcb.com/\" target=\"_blank\" rel=\"noopener\">https://jlcpcb.com/</a></p>\n"},{"_content":"# 蓝盾流水 与 PUSH功能","source":"_posts/蓝盾流水 与 PUSH功能.md","raw":"# 蓝盾流水 与 PUSH功能","slug":"蓝盾流水 与 PUSH功能","published":1,"date":"2020-06-19T07:29:34.000Z","updated":"2020-06-19T07:29:34.000Z","title":"蓝盾流水 与 PUSH功能","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgyxlita000u0iu6acqc86cw","content":"<h1 id=\"蓝盾流水-与-PUSH功能\"><a href=\"#蓝盾流水-与-PUSH功能\" class=\"headerlink\" title=\"蓝盾流水 与 PUSH功能\"></a>蓝盾流水 与 PUSH功能</h1>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"蓝盾流水-与-PUSH功能\"><a href=\"#蓝盾流水-与-PUSH功能\" class=\"headerlink\" title=\"蓝盾流水 与 PUSH功能\"></a>蓝盾流水 与 PUSH功能</h1>"},{"_content":"# 蓝盾流水耗时优化\n\n随着项目成长，打包所用的时间越来越多，现在已经增加到了20-30分钟一个包，着实为体验和回归带来了负担，于是分析一下是哪里的问题。本文只讨论私有构建机，公共构建每次都要清空workspace，这里不做讨论。\n\n## 入手分析\n\n* 查看流水节点耗时\n* 增加耗时log\n\n\n## 优化\n\n* 重复拉代码\n    增量拉取，需求分支\n    \n* flutter packages get不稳定\n    检查网络配置\n    http://8000.oa.com/?s=search#/article?id=KB201901310001\n    \n* 编译时间长，配置低\n    加内存\n    干掉32位架构\n\n* 重签名时间长\n\n\n## 遇到的问题\n\n* epxr a - b结果为0时蓝盾报错\n* flutter packages get 时大概率报错 \"Proxy failed to establish tunnel (502 Server UnReachable)\"\n* 中途编译失败\n* pod 没更新\n* 不支持32位架构\n\n## 其他\n\n* 好多cocoapods的重复符号警告，真烦躁，干掉","source":"_posts/蓝盾流水耗时优化.md","raw":"# 蓝盾流水耗时优化\n\n随着项目成长，打包所用的时间越来越多，现在已经增加到了20-30分钟一个包，着实为体验和回归带来了负担，于是分析一下是哪里的问题。本文只讨论私有构建机，公共构建每次都要清空workspace，这里不做讨论。\n\n## 入手分析\n\n* 查看流水节点耗时\n* 增加耗时log\n\n\n## 优化\n\n* 重复拉代码\n    增量拉取，需求分支\n    \n* flutter packages get不稳定\n    检查网络配置\n    http://8000.oa.com/?s=search#/article?id=KB201901310001\n    \n* 编译时间长，配置低\n    加内存\n    干掉32位架构\n\n* 重签名时间长\n\n\n## 遇到的问题\n\n* epxr a - b结果为0时蓝盾报错\n* flutter packages get 时大概率报错 \"Proxy failed to establish tunnel (502 Server UnReachable)\"\n* 中途编译失败\n* pod 没更新\n* 不支持32位架构\n\n## 其他\n\n* 好多cocoapods的重复符号警告，真烦躁，干掉","slug":"蓝盾流水耗时优化","published":1,"date":"2020-06-12T08:45:25.000Z","updated":"2020-06-12T08:45:25.000Z","title":"蓝盾流水耗时优化","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgyxlitb000v0iu668ym13bz","content":"<h1 id=\"蓝盾流水耗时优化\"><a href=\"#蓝盾流水耗时优化\" class=\"headerlink\" title=\"蓝盾流水耗时优化\"></a>蓝盾流水耗时优化</h1><p>随着项目成长，打包所用的时间越来越多，现在已经增加到了20-30分钟一个包，着实为体验和回归带来了负担，于是分析一下是哪里的问题。本文只讨论私有构建机，公共构建每次都要清空workspace，这里不做讨论。</p>\n<h2 id=\"入手分析\"><a href=\"#入手分析\" class=\"headerlink\" title=\"入手分析\"></a>入手分析</h2><ul>\n<li>查看流水节点耗时</li>\n<li>增加耗时log</li>\n</ul>\n<h2 id=\"优化\"><a href=\"#优化\" class=\"headerlink\" title=\"优化\"></a>优化</h2><ul>\n<li><p>重复拉代码<br>  增量拉取，需求分支</p>\n</li>\n<li><p>flutter packages get不稳定<br>  检查网络配置<br>  <a href=\"http://8000.oa.com/?s=search#/article?id=KB201901310001\" target=\"_blank\" rel=\"noopener\">http://8000.oa.com/?s=search#/article?id=KB201901310001</a></p>\n</li>\n<li><p>编译时间长，配置低<br>  加内存<br>  干掉32位架构</p>\n</li>\n<li><p>重签名时间长</p>\n</li>\n</ul>\n<h2 id=\"遇到的问题\"><a href=\"#遇到的问题\" class=\"headerlink\" title=\"遇到的问题\"></a>遇到的问题</h2><ul>\n<li>epxr a - b结果为0时蓝盾报错</li>\n<li>flutter packages get 时大概率报错 “Proxy failed to establish tunnel (502 Server UnReachable)”</li>\n<li>中途编译失败</li>\n<li>pod 没更新</li>\n<li>不支持32位架构</li>\n</ul>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><ul>\n<li>好多cocoapods的重复符号警告，真烦躁，干掉</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"蓝盾流水耗时优化\"><a href=\"#蓝盾流水耗时优化\" class=\"headerlink\" title=\"蓝盾流水耗时优化\"></a>蓝盾流水耗时优化</h1><p>随着项目成长，打包所用的时间越来越多，现在已经增加到了20-30分钟一个包，着实为体验和回归带来了负担，于是分析一下是哪里的问题。本文只讨论私有构建机，公共构建每次都要清空workspace，这里不做讨论。</p>\n<h2 id=\"入手分析\"><a href=\"#入手分析\" class=\"headerlink\" title=\"入手分析\"></a>入手分析</h2><ul>\n<li>查看流水节点耗时</li>\n<li>增加耗时log</li>\n</ul>\n<h2 id=\"优化\"><a href=\"#优化\" class=\"headerlink\" title=\"优化\"></a>优化</h2><ul>\n<li><p>重复拉代码<br>  增量拉取，需求分支</p>\n</li>\n<li><p>flutter packages get不稳定<br>  检查网络配置<br>  <a href=\"http://8000.oa.com/?s=search#/article?id=KB201901310001\" target=\"_blank\" rel=\"noopener\">http://8000.oa.com/?s=search#/article?id=KB201901310001</a></p>\n</li>\n<li><p>编译时间长，配置低<br>  加内存<br>  干掉32位架构</p>\n</li>\n<li><p>重签名时间长</p>\n</li>\n</ul>\n<h2 id=\"遇到的问题\"><a href=\"#遇到的问题\" class=\"headerlink\" title=\"遇到的问题\"></a>遇到的问题</h2><ul>\n<li>epxr a - b结果为0时蓝盾报错</li>\n<li>flutter packages get 时大概率报错 “Proxy failed to establish tunnel (502 Server UnReachable)”</li>\n<li>中途编译失败</li>\n<li>pod 没更新</li>\n<li>不支持32位架构</li>\n</ul>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><ul>\n<li>好多cocoapods的重复符号警告，真烦躁，干掉</li>\n</ul>\n"},{"_content":"# 记一次bug，微信登录分享跳转多次\n\n> 前几周遇到的问题，记了个标题，到今天才有时间填坑，来，整！\n\n项目使用蓝盾平台打包，用通配符企业证书冲签名，微信SDK更新`1.8.6.2`之后，出现一个问题，微信登录和分享时，会在微信app和业务app之前，反复跳转两次，这个问题在本地调试是没有的。\n<img src=\"https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2020/06/21/15927539305083.jpg\" width=\"40%\">\n\n\n### 先看看微信SDK文档\n\n![](https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2020/06/21/15927524709966.jpg)\n\n让我们检查Universal Link，说明是UL没生效，用苹果的[验证官网](https://link.jianshu.com/?t=https://search.developer.apple.com/appsearch-validation-tool/)检查，UL是正常的，且本地调试没问题，排除代码问题。\n\n### 再看看打包平台\n\n看看蓝盾平台，和证书最相关的就是`iOS重签名插件`\n![](https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2020/06/21/15927530005449.jpg)\n\n嗯？插件有个UL字段，看起来问题出在这，看看蓝盾爸爸的[文档](https://iwiki.oa.tencent.com/pages/viewpage.action?pageId=17506192)，看看这字段具体描述。\n\n![](https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2020/06/21/15927531842392.jpg)\n\n![](https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2020/06/21/15927531962045.jpg)\n\n果然，蓝盾爸还要求在插件中重新设置一遍UL，不然项目中的UL字段会被通配符企业证书覆盖为空，导致UL功能失效，微信跳转的时候找不到我们注册的UL，所以有了上面的问题。\n\n但是，插件只支持单个target的场景，多target场景不支持，能打包成功，但手机装不上，然而我们项目就是多target的，咦，这眼泪是怎么回事。\n\n### 多target工程怎么办？\n\n蓝盾爸爸的文档中提供了两种解决办法：\n\n1. 别用UL了，放弃治疗\n![](https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2020/06/21/15927535655877.jpg)\n\n2. 使用公共构建机\n![](https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2020/06/21/15927537681684.jpg)\n\n接入公共构建机，打包出来ipa，验证微信分享，一切正常，解决！\n\n（完）","source":"_posts/记一次bug，微信登录分享跳转多次.md","raw":"# 记一次bug，微信登录分享跳转多次\n\n> 前几周遇到的问题，记了个标题，到今天才有时间填坑，来，整！\n\n项目使用蓝盾平台打包，用通配符企业证书冲签名，微信SDK更新`1.8.6.2`之后，出现一个问题，微信登录和分享时，会在微信app和业务app之前，反复跳转两次，这个问题在本地调试是没有的。\n<img src=\"https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2020/06/21/15927539305083.jpg\" width=\"40%\">\n\n\n### 先看看微信SDK文档\n\n![](https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2020/06/21/15927524709966.jpg)\n\n让我们检查Universal Link，说明是UL没生效，用苹果的[验证官网](https://link.jianshu.com/?t=https://search.developer.apple.com/appsearch-validation-tool/)检查，UL是正常的，且本地调试没问题，排除代码问题。\n\n### 再看看打包平台\n\n看看蓝盾平台，和证书最相关的就是`iOS重签名插件`\n![](https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2020/06/21/15927530005449.jpg)\n\n嗯？插件有个UL字段，看起来问题出在这，看看蓝盾爸爸的[文档](https://iwiki.oa.tencent.com/pages/viewpage.action?pageId=17506192)，看看这字段具体描述。\n\n![](https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2020/06/21/15927531842392.jpg)\n\n![](https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2020/06/21/15927531962045.jpg)\n\n果然，蓝盾爸还要求在插件中重新设置一遍UL，不然项目中的UL字段会被通配符企业证书覆盖为空，导致UL功能失效，微信跳转的时候找不到我们注册的UL，所以有了上面的问题。\n\n但是，插件只支持单个target的场景，多target场景不支持，能打包成功，但手机装不上，然而我们项目就是多target的，咦，这眼泪是怎么回事。\n\n### 多target工程怎么办？\n\n蓝盾爸爸的文档中提供了两种解决办法：\n\n1. 别用UL了，放弃治疗\n![](https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2020/06/21/15927535655877.jpg)\n\n2. 使用公共构建机\n![](https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2020/06/21/15927537681684.jpg)\n\n接入公共构建机，打包出来ipa，验证微信分享，一切正常，解决！\n\n（完）","slug":"记一次bug，微信登录分享跳转多次","published":1,"date":"2020-06-17T11:32:50.000Z","updated":"2020-06-21T15:49:04.000Z","title":"记一次bug，微信登录分享跳转多次","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgyxlitb000w0iu64c9dgvhi","content":"<h1 id=\"记一次bug，微信登录分享跳转多次\"><a href=\"#记一次bug，微信登录分享跳转多次\" class=\"headerlink\" title=\"记一次bug，微信登录分享跳转多次\"></a>记一次bug，微信登录分享跳转多次</h1><blockquote>\n<p>前几周遇到的问题，记了个标题，到今天才有时间填坑，来，整！</p>\n</blockquote>\n<p>项目使用蓝盾平台打包，用通配符企业证书冲签名，微信SDK更新<code>1.8.6.2</code>之后，出现一个问题，微信登录和分享时，会在微信app和业务app之前，反复跳转两次，这个问题在本地调试是没有的。<br><img src=\"https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2020/06/21/15927539305083.jpg\" width=\"40%\"></p>\n<h3 id=\"先看看微信SDK文档\"><a href=\"#先看看微信SDK文档\" class=\"headerlink\" title=\"先看看微信SDK文档\"></a>先看看微信SDK文档</h3><p><img src=\"https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2020/06/21/15927524709966.jpg\" alt=\"\"></p>\n<p>让我们检查Universal Link，说明是UL没生效，用苹果的<a href=\"https://link.jianshu.com/?t=https://search.developer.apple.com/appsearch-validation-tool/\" target=\"_blank\" rel=\"noopener\">验证官网</a>检查，UL是正常的，且本地调试没问题，排除代码问题。</p>\n<h3 id=\"再看看打包平台\"><a href=\"#再看看打包平台\" class=\"headerlink\" title=\"再看看打包平台\"></a>再看看打包平台</h3><p>看看蓝盾平台，和证书最相关的就是<code>iOS重签名插件</code><br><img src=\"https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2020/06/21/15927530005449.jpg\" alt=\"\"></p>\n<p>嗯？插件有个UL字段，看起来问题出在这，看看蓝盾爸爸的<a href=\"https://iwiki.oa.tencent.com/pages/viewpage.action?pageId=17506192\" target=\"_blank\" rel=\"noopener\">文档</a>，看看这字段具体描述。</p>\n<p><img src=\"https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2020/06/21/15927531842392.jpg\" alt=\"\"></p>\n<p><img src=\"https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2020/06/21/15927531962045.jpg\" alt=\"\"></p>\n<p>果然，蓝盾爸还要求在插件中重新设置一遍UL，不然项目中的UL字段会被通配符企业证书覆盖为空，导致UL功能失效，微信跳转的时候找不到我们注册的UL，所以有了上面的问题。</p>\n<p>但是，插件只支持单个target的场景，多target场景不支持，能打包成功，但手机装不上，然而我们项目就是多target的，咦，这眼泪是怎么回事。</p>\n<h3 id=\"多target工程怎么办？\"><a href=\"#多target工程怎么办？\" class=\"headerlink\" title=\"多target工程怎么办？\"></a>多target工程怎么办？</h3><p>蓝盾爸爸的文档中提供了两种解决办法：</p>\n<ol>\n<li><p>别用UL了，放弃治疗<br><img src=\"https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2020/06/21/15927535655877.jpg\" alt=\"\"></p>\n</li>\n<li><p>使用公共构建机<br><img src=\"https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2020/06/21/15927537681684.jpg\" alt=\"\"></p>\n</li>\n</ol>\n<p>接入公共构建机，打包出来ipa，验证微信分享，一切正常，解决！</p>\n<p>（完）</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"记一次bug，微信登录分享跳转多次\"><a href=\"#记一次bug，微信登录分享跳转多次\" class=\"headerlink\" title=\"记一次bug，微信登录分享跳转多次\"></a>记一次bug，微信登录分享跳转多次</h1><blockquote>\n<p>前几周遇到的问题，记了个标题，到今天才有时间填坑，来，整！</p>\n</blockquote>\n<p>项目使用蓝盾平台打包，用通配符企业证书冲签名，微信SDK更新<code>1.8.6.2</code>之后，出现一个问题，微信登录和分享时，会在微信app和业务app之前，反复跳转两次，这个问题在本地调试是没有的。<br><img src=\"https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2020/06/21/15927539305083.jpg\" width=\"40%\"></p>\n<h3 id=\"先看看微信SDK文档\"><a href=\"#先看看微信SDK文档\" class=\"headerlink\" title=\"先看看微信SDK文档\"></a>先看看微信SDK文档</h3><p><img src=\"https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2020/06/21/15927524709966.jpg\" alt=\"\"></p>\n<p>让我们检查Universal Link，说明是UL没生效，用苹果的<a href=\"https://link.jianshu.com/?t=https://search.developer.apple.com/appsearch-validation-tool/\" target=\"_blank\" rel=\"noopener\">验证官网</a>检查，UL是正常的，且本地调试没问题，排除代码问题。</p>\n<h3 id=\"再看看打包平台\"><a href=\"#再看看打包平台\" class=\"headerlink\" title=\"再看看打包平台\"></a>再看看打包平台</h3><p>看看蓝盾平台，和证书最相关的就是<code>iOS重签名插件</code><br><img src=\"https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2020/06/21/15927530005449.jpg\" alt=\"\"></p>\n<p>嗯？插件有个UL字段，看起来问题出在这，看看蓝盾爸爸的<a href=\"https://iwiki.oa.tencent.com/pages/viewpage.action?pageId=17506192\" target=\"_blank\" rel=\"noopener\">文档</a>，看看这字段具体描述。</p>\n<p><img src=\"https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2020/06/21/15927531842392.jpg\" alt=\"\"></p>\n<p><img src=\"https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2020/06/21/15927531962045.jpg\" alt=\"\"></p>\n<p>果然，蓝盾爸还要求在插件中重新设置一遍UL，不然项目中的UL字段会被通配符企业证书覆盖为空，导致UL功能失效，微信跳转的时候找不到我们注册的UL，所以有了上面的问题。</p>\n<p>但是，插件只支持单个target的场景，多target场景不支持，能打包成功，但手机装不上，然而我们项目就是多target的，咦，这眼泪是怎么回事。</p>\n<h3 id=\"多target工程怎么办？\"><a href=\"#多target工程怎么办？\" class=\"headerlink\" title=\"多target工程怎么办？\"></a>多target工程怎么办？</h3><p>蓝盾爸爸的文档中提供了两种解决办法：</p>\n<ol>\n<li><p>别用UL了，放弃治疗<br><img src=\"https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2020/06/21/15927535655877.jpg\" alt=\"\"></p>\n</li>\n<li><p>使用公共构建机<br><img src=\"https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2020/06/21/15927537681684.jpg\" alt=\"\"></p>\n</li>\n</ol>\n<p>接入公共构建机，打包出来ipa，验证微信分享，一切正常，解决！</p>\n<p>（完）</p>\n"},{"_content":"# ","source":"_posts/记一次发布失败 ITMS-90034: Missing or invalid signature.md","raw":"# ","slug":"记一次发布失败 ITMS-90034: Missing or invalid signature","published":1,"date":"2020-06-21T06:04:06.000Z","updated":"2020-06-21T06:04:06.000Z","title":"记一次发布失败 ITMS-90034: Missing or invalid signature","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgyxlitb000x0iu61303eh1b","content":"<h1 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h1>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h1>"},{"title":"记一次发布失败 ITMS-90034: Missing or invalid signature","date":"2020-09-20T16:35:04.000Z","_content":"\n## 起因\n今天项目提审，上传了ipa，叮咚，收到一封邮件，有不好的预感，果然，苹果爸爸又zuo妖了，提审失败\n\n**解决办法：最终重做证书之后解决**\n\n![enter image description here](http://km.oa.com/files/photos/pictures/202006/1591364435_57_w1528_h602.png)\n\n## 经过\n提示签名错误，查！\n怎么查？\n\n### 一. 从结果入手，查ipa里的签名\n\n1. 解压ipa\n2. 进入Payload/xxx.app/目录\n3. 输入命令 \n\n    ```\n    security cms -D -i embedded.mobileprovision\n    ```\n4. 分析签名文件\n![enter image description here](http://km.oa.com/files/photos/pictures/202006/1591364449_93_w1586_h1144.png)\n![enter image description here](http://km.oa.com/files/photos/pictures/202006/1591364455_44_w2710_h704.png)\n和keystore里的签名完全对应，而且没过期，未见异常\n\n### 二. 从苹果邮件入手，上网搜索错误号“ITMS-90034”\n\n网上解决方式有3种：\n* 重新制作证书\n* 删除过期证书\n* 更改证书默认信任\n\n\n## 结果\n\n与蓝盾同事交涉，我们的证书已经是默认信任的，那就剩下**更新证书**了，来吧！\n\n* 更新证书\n* 重新打包\n* 上传ipa\n* 审核通过\n\n一气呵成，回家吃饭！","source":"_posts/记一次发布失败-ITMS-90034-Missing-or-invalid-signature.md","raw":"---\ntitle: '记一次发布失败 ITMS-90034: Missing or invalid signature'\ndate: 2020-09-21 00:35:04\ntags:\n---\n\n## 起因\n今天项目提审，上传了ipa，叮咚，收到一封邮件，有不好的预感，果然，苹果爸爸又zuo妖了，提审失败\n\n**解决办法：最终重做证书之后解决**\n\n![enter image description here](http://km.oa.com/files/photos/pictures/202006/1591364435_57_w1528_h602.png)\n\n## 经过\n提示签名错误，查！\n怎么查？\n\n### 一. 从结果入手，查ipa里的签名\n\n1. 解压ipa\n2. 进入Payload/xxx.app/目录\n3. 输入命令 \n\n    ```\n    security cms -D -i embedded.mobileprovision\n    ```\n4. 分析签名文件\n![enter image description here](http://km.oa.com/files/photos/pictures/202006/1591364449_93_w1586_h1144.png)\n![enter image description here](http://km.oa.com/files/photos/pictures/202006/1591364455_44_w2710_h704.png)\n和keystore里的签名完全对应，而且没过期，未见异常\n\n### 二. 从苹果邮件入手，上网搜索错误号“ITMS-90034”\n\n网上解决方式有3种：\n* 重新制作证书\n* 删除过期证书\n* 更改证书默认信任\n\n\n## 结果\n\n与蓝盾同事交涉，我们的证书已经是默认信任的，那就剩下**更新证书**了，来吧！\n\n* 更新证书\n* 重新打包\n* 上传ipa\n* 审核通过\n\n一气呵成，回家吃饭！","slug":"记一次发布失败-ITMS-90034-Missing-or-invalid-signature","published":1,"updated":"2020-09-20T16:35:49.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgyxlitc000y0iu6av41amwx","content":"<h2 id=\"起因\"><a href=\"#起因\" class=\"headerlink\" title=\"起因\"></a>起因</h2><p>今天项目提审，上传了ipa，叮咚，收到一封邮件，有不好的预感，果然，苹果爸爸又zuo妖了，提审失败</p>\n<p><strong>解决办法：最终重做证书之后解决</strong></p>\n<p><img src=\"http://km.oa.com/files/photos/pictures/202006/1591364435_57_w1528_h602.png\" alt=\"enter image description here\"></p>\n<h2 id=\"经过\"><a href=\"#经过\" class=\"headerlink\" title=\"经过\"></a>经过</h2><p>提示签名错误，查！<br>怎么查？</p>\n<h3 id=\"一-从结果入手，查ipa里的签名\"><a href=\"#一-从结果入手，查ipa里的签名\" class=\"headerlink\" title=\"一. 从结果入手，查ipa里的签名\"></a>一. 从结果入手，查ipa里的签名</h3><ol>\n<li><p>解压ipa</p>\n</li>\n<li><p>进入Payload/xxx.app/目录</p>\n</li>\n<li><p>输入命令 </p>\n<pre><code> security cms -D -i embedded.mobileprovision</code></pre></li>\n<li><p>分析签名文件<br><img src=\"http://km.oa.com/files/photos/pictures/202006/1591364449_93_w1586_h1144.png\" alt=\"enter image description here\"><br><img src=\"http://km.oa.com/files/photos/pictures/202006/1591364455_44_w2710_h704.png\" alt=\"enter image description here\"><br>和keystore里的签名完全对应，而且没过期，未见异常</p>\n</li>\n</ol>\n<h3 id=\"二-从苹果邮件入手，上网搜索错误号“ITMS-90034”\"><a href=\"#二-从苹果邮件入手，上网搜索错误号“ITMS-90034”\" class=\"headerlink\" title=\"二. 从苹果邮件入手，上网搜索错误号“ITMS-90034”\"></a>二. 从苹果邮件入手，上网搜索错误号“ITMS-90034”</h3><p>网上解决方式有3种：</p>\n<ul>\n<li>重新制作证书</li>\n<li>删除过期证书</li>\n<li>更改证书默认信任</li>\n</ul>\n<h2 id=\"结果\"><a href=\"#结果\" class=\"headerlink\" title=\"结果\"></a>结果</h2><p>与蓝盾同事交涉，我们的证书已经是默认信任的，那就剩下<strong>更新证书</strong>了，来吧！</p>\n<ul>\n<li>更新证书</li>\n<li>重新打包</li>\n<li>上传ipa</li>\n<li>审核通过</li>\n</ul>\n<p>一气呵成，回家吃饭！</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"起因\"><a href=\"#起因\" class=\"headerlink\" title=\"起因\"></a>起因</h2><p>今天项目提审，上传了ipa，叮咚，收到一封邮件，有不好的预感，果然，苹果爸爸又zuo妖了，提审失败</p>\n<p><strong>解决办法：最终重做证书之后解决</strong></p>\n<p><img src=\"http://km.oa.com/files/photos/pictures/202006/1591364435_57_w1528_h602.png\" alt=\"enter image description here\"></p>\n<h2 id=\"经过\"><a href=\"#经过\" class=\"headerlink\" title=\"经过\"></a>经过</h2><p>提示签名错误，查！<br>怎么查？</p>\n<h3 id=\"一-从结果入手，查ipa里的签名\"><a href=\"#一-从结果入手，查ipa里的签名\" class=\"headerlink\" title=\"一. 从结果入手，查ipa里的签名\"></a>一. 从结果入手，查ipa里的签名</h3><ol>\n<li><p>解压ipa</p>\n</li>\n<li><p>进入Payload/xxx.app/目录</p>\n</li>\n<li><p>输入命令 </p>\n<pre><code> security cms -D -i embedded.mobileprovision</code></pre></li>\n<li><p>分析签名文件<br><img src=\"http://km.oa.com/files/photos/pictures/202006/1591364449_93_w1586_h1144.png\" alt=\"enter image description here\"><br><img src=\"http://km.oa.com/files/photos/pictures/202006/1591364455_44_w2710_h704.png\" alt=\"enter image description here\"><br>和keystore里的签名完全对应，而且没过期，未见异常</p>\n</li>\n</ol>\n<h3 id=\"二-从苹果邮件入手，上网搜索错误号“ITMS-90034”\"><a href=\"#二-从苹果邮件入手，上网搜索错误号“ITMS-90034”\" class=\"headerlink\" title=\"二. 从苹果邮件入手，上网搜索错误号“ITMS-90034”\"></a>二. 从苹果邮件入手，上网搜索错误号“ITMS-90034”</h3><p>网上解决方式有3种：</p>\n<ul>\n<li>重新制作证书</li>\n<li>删除过期证书</li>\n<li>更改证书默认信任</li>\n</ul>\n<h2 id=\"结果\"><a href=\"#结果\" class=\"headerlink\" title=\"结果\"></a>结果</h2><p>与蓝盾同事交涉，我们的证书已经是默认信任的，那就剩下<strong>更新证书</strong>了，来吧！</p>\n<ul>\n<li>更新证书</li>\n<li>重新打包</li>\n<li>上传ipa</li>\n<li>审核通过</li>\n</ul>\n<p>一气呵成，回家吃饭！</p>\n"},{"title":"MediaPipe iOS真机运行指引","date":"2020-11-08T14:44:51.000Z","_content":"\n### 使用Tulsi导出XCode工程\n\n这步比较简单，按照官网即可，https://google.github.io/mediapipe/getting_started/building_examples.html#ios\n\n### 如何设置证书在真机上运行\n\n* STEP 1\n\n    删除XCode编译产物，保证工程干净 XCode菜单 Product -> Clean\n \n* STEP 2\n\n    删除bazel编译产物，同样保证工程干净，在mediapipe文件夹中执行：\n```\nbazel clean --expunge\n```   \n\n* STEP 3\n    \n    使用控制台下载编译时需要下载的文件，测试网络是否通畅，随便找个临时文件夹就好，在控制台中打开文件夹，然后执行：\n```\nhttps://github.com/bazelbuild/rules_cc/archive/master.zip\n```\n\n    这个文件不需要翻墙就能下载，如果下载失败，请检查自己的网络设置，把代理该干掉的干掉。\n\n* STEP 4\n\n    在mediapipe项目文件夹中执行：\n```\npython3 mediapipe/examples/ios/link_local_profiles.py\n```\n这条命令有两个功能，先说第一个功能：\n\n    * 生成bundleID前缀\n    \n        生成的前缀会写到mediapipe/examples/ios/bundle_id.bzl中，长这个样子：\n![-w636](https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2020/11/08/16048448781636.jpg)\n嫌它丑，也可以改成自己习惯用的，比如我就改成了\"justinsong.Demo\",这个前缀只生成一次，后面不会重复生成。\n\n* STEP 5\n\n    上一步第一次执行link_local_profiles.py脚本之后，生成了bundleID前缀，这时我们需要打开工程，为我们想要运行的例子修改bundleID，修改成 bundleID前缀+例子名的格式，修改后回车。\n    \n    > 例如：比如前缀是09a8dab3-7aa0-419e-9e6f-2fa48b7495f8.mediapipe.examples，要运行的例子是FaceDetectionCpu，那么你target的bundleID就要写成\"09a8dab3-7aa0-419e-9e6f-2fa48b7495f8.mediapipe.examples.FaceDetectionCpu\"\n![](https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2020/11/08/16048485814866.jpg)\n\n    \n\n* STEP 6\n        \n    在mediapipe项目文件夹中再次执行：\n```\npython3 mediapipe/examples/ios/link_local_profiles.py\n```\n\n    用到这个脚本的第二个功能：\n    \n    * 创建mobileprovision替身\n    \n        这一步会根据bundle_id.bzl中的bundleID前缀匹配example文件夹中各个target的bundelID，如果前缀相同，脚本就在这个例子的文件夹中创建一个mobileprovision的替身。\n    \n        > 注意！ 这一步想生效有个前提，是你的profile要在mediapipe/provisioning_profile.mobileprovision这个位置，否则失败，如果你的这个路径下没有mobileprovision，解决办法如下：\n> 1. 如果你已经有mobileprovision，直接复制到mediapile/midiapile/路径下，你可能有的这个文件在~/Library/MobileDevice/Provisioning\\ Profiles/路径下面，拷一个没过期的过来，改个名字就行了\n>     \n> 2. 如果你没有这个东西，那就要按照苹果官方指引生成下载再拷贝改名了\n\n        执行成功后，你的文件夹中会多一个mobileprovision的替身文件，且能看到原身的信息（如果看不到替身或点击替身找不到原身，回到STEP4重新做。）这时距离成功就差一步了 ：）\n![-w761](https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2020/11/08/16048463886571.jpg)\n\n* STEP 7\n\n    回到XCode工程中，选择想要运行的target，运行！\n    \n（结束）","source":"_posts/MediaPipe-iOS真机运行指引.md","raw":"---\ntitle: MediaPipe iOS真机运行指引\ndate: 2020-11-08 22:44:51\ntags:\n---\n\n### 使用Tulsi导出XCode工程\n\n这步比较简单，按照官网即可，https://google.github.io/mediapipe/getting_started/building_examples.html#ios\n\n### 如何设置证书在真机上运行\n\n* STEP 1\n\n    删除XCode编译产物，保证工程干净 XCode菜单 Product -> Clean\n \n* STEP 2\n\n    删除bazel编译产物，同样保证工程干净，在mediapipe文件夹中执行：\n```\nbazel clean --expunge\n```   \n\n* STEP 3\n    \n    使用控制台下载编译时需要下载的文件，测试网络是否通畅，随便找个临时文件夹就好，在控制台中打开文件夹，然后执行：\n```\nhttps://github.com/bazelbuild/rules_cc/archive/master.zip\n```\n\n    这个文件不需要翻墙就能下载，如果下载失败，请检查自己的网络设置，把代理该干掉的干掉。\n\n* STEP 4\n\n    在mediapipe项目文件夹中执行：\n```\npython3 mediapipe/examples/ios/link_local_profiles.py\n```\n这条命令有两个功能，先说第一个功能：\n\n    * 生成bundleID前缀\n    \n        生成的前缀会写到mediapipe/examples/ios/bundle_id.bzl中，长这个样子：\n![-w636](https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2020/11/08/16048448781636.jpg)\n嫌它丑，也可以改成自己习惯用的，比如我就改成了\"justinsong.Demo\",这个前缀只生成一次，后面不会重复生成。\n\n* STEP 5\n\n    上一步第一次执行link_local_profiles.py脚本之后，生成了bundleID前缀，这时我们需要打开工程，为我们想要运行的例子修改bundleID，修改成 bundleID前缀+例子名的格式，修改后回车。\n    \n    > 例如：比如前缀是09a8dab3-7aa0-419e-9e6f-2fa48b7495f8.mediapipe.examples，要运行的例子是FaceDetectionCpu，那么你target的bundleID就要写成\"09a8dab3-7aa0-419e-9e6f-2fa48b7495f8.mediapipe.examples.FaceDetectionCpu\"\n![](https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2020/11/08/16048485814866.jpg)\n\n    \n\n* STEP 6\n        \n    在mediapipe项目文件夹中再次执行：\n```\npython3 mediapipe/examples/ios/link_local_profiles.py\n```\n\n    用到这个脚本的第二个功能：\n    \n    * 创建mobileprovision替身\n    \n        这一步会根据bundle_id.bzl中的bundleID前缀匹配example文件夹中各个target的bundelID，如果前缀相同，脚本就在这个例子的文件夹中创建一个mobileprovision的替身。\n    \n        > 注意！ 这一步想生效有个前提，是你的profile要在mediapipe/provisioning_profile.mobileprovision这个位置，否则失败，如果你的这个路径下没有mobileprovision，解决办法如下：\n> 1. 如果你已经有mobileprovision，直接复制到mediapile/midiapile/路径下，你可能有的这个文件在~/Library/MobileDevice/Provisioning\\ Profiles/路径下面，拷一个没过期的过来，改个名字就行了\n>     \n> 2. 如果你没有这个东西，那就要按照苹果官方指引生成下载再拷贝改名了\n\n        执行成功后，你的文件夹中会多一个mobileprovision的替身文件，且能看到原身的信息（如果看不到替身或点击替身找不到原身，回到STEP4重新做。）这时距离成功就差一步了 ：）\n![-w761](https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2020/11/08/16048463886571.jpg)\n\n* STEP 7\n\n    回到XCode工程中，选择想要运行的target，运行！\n    \n（结束）","slug":"MediaPipe-iOS真机运行指引","published":1,"updated":"2020-11-08T15:19:58.798Z","_id":"ckh98jtea00002kse7b3rfh77","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"使用Tulsi导出XCode工程\"><a href=\"#使用Tulsi导出XCode工程\" class=\"headerlink\" title=\"使用Tulsi导出XCode工程\"></a>使用Tulsi导出XCode工程</h3><p>这步比较简单，按照官网即可，<a href=\"https://google.github.io/mediapipe/getting_started/building_examples.html#ios\" target=\"_blank\" rel=\"noopener\">https://google.github.io/mediapipe/getting_started/building_examples.html#ios</a></p>\n<h3 id=\"如何设置证书在真机上运行\"><a href=\"#如何设置证书在真机上运行\" class=\"headerlink\" title=\"如何设置证书在真机上运行\"></a>如何设置证书在真机上运行</h3><ul>\n<li><p>STEP 1</p>\n<p>  删除XCode编译产物，保证工程干净 XCode菜单 Product -&gt; Clean</p>\n</li>\n<li><p>STEP 2</p>\n<p>  删除bazel编译产物，同样保证工程干净，在mediapipe文件夹中执行：</p>\n<pre><code>bazel clean --expunge</code></pre></li>\n<li><p>STEP 3</p>\n<p>  使用控制台下载编译时需要下载的文件，测试网络是否通畅，随便找个临时文件夹就好，在控制台中打开文件夹，然后执行：</p>\n<pre><code>https://github.com/bazelbuild/rules_cc/archive/master.zip</code></pre><p>  这个文件不需要翻墙就能下载，如果下载失败，请检查自己的网络设置，把代理该干掉的干掉。</p>\n</li>\n<li><p>STEP 4</p>\n<p>  在mediapipe项目文件夹中执行：</p>\n<pre><code>python3 mediapipe/examples/ios/link_local_profiles.py</code></pre><p>这条命令有两个功能，先说第一个功能：</p>\n<ul>\n<li><p>生成bundleID前缀</p>\n<p>  生成的前缀会写到mediapipe/examples/ios/bundle_id.bzl中，长这个样子：<br><img src=\"https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2020/11/08/16048448781636.jpg\" alt=\"-w636\"><br>嫌它丑，也可以改成自己习惯用的，比如我就改成了”justinsong.Demo”,这个前缀只生成一次，后面不会重复生成。</p>\n</li>\n</ul>\n</li>\n<li><p>STEP 5</p>\n<p>  上一步第一次执行link_local_profiles.py脚本之后，生成了bundleID前缀，这时我们需要打开工程，为我们想要运行的例子修改bundleID，修改成 bundleID前缀+例子名的格式，修改后回车。</p>\n<blockquote>\n<p>例如：比如前缀是09a8dab3-7aa0-419e-9e6f-2fa48b7495f8.mediapipe.examples，要运行的例子是FaceDetectionCpu，那么你target的bundleID就要写成”09a8dab3-7aa0-419e-9e6f-2fa48b7495f8.mediapipe.examples.FaceDetectionCpu”<br><img src=\"https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2020/11/08/16048485814866.jpg\" alt=\"\"></p>\n</blockquote>\n</li>\n</ul>\n<ul>\n<li><p>STEP 6</p>\n<p>  在mediapipe项目文件夹中再次执行：</p>\n<pre><code>python3 mediapipe/examples/ios/link_local_profiles.py</code></pre><p>  用到这个脚本的第二个功能：</p>\n<ul>\n<li><p>创建mobileprovision替身</p>\n<p>  这一步会根据bundle_id.bzl中的bundleID前缀匹配example文件夹中各个target的bundelID，如果前缀相同，脚本就在这个例子的文件夹中创建一个mobileprovision的替身。</p>\n<blockquote>\n<p>注意！ 这一步想生效有个前提，是你的profile要在mediapipe/provisioning_profile.mobileprovision这个位置，否则失败，如果你的这个路径下没有mobileprovision，解决办法如下：</p>\n<ol>\n<li><p>如果你已经有mobileprovision，直接复制到mediapile/midiapile/路径下，你可能有的这个文件在~/Library/MobileDevice/Provisioning\\ Profiles/路径下面，拷一个没过期的过来，改个名字就行了</p>\n</li>\n<li><p>如果你没有这个东西，那就要按照苹果官方指引生成下载再拷贝改名了</p>\n</li>\n</ol>\n</blockquote>\n<p>  执行成功后，你的文件夹中会多一个mobileprovision的替身文件，且能看到原身的信息（如果看不到替身或点击替身找不到原身，回到STEP4重新做。）这时距离成功就差一步了 ：）<br><img src=\"https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2020/11/08/16048463886571.jpg\" alt=\"-w761\"></p>\n</li>\n</ul>\n</li>\n<li><p>STEP 7</p>\n<p>  回到XCode工程中，选择想要运行的target，运行！</p>\n</li>\n</ul>\n<p>（结束）</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"使用Tulsi导出XCode工程\"><a href=\"#使用Tulsi导出XCode工程\" class=\"headerlink\" title=\"使用Tulsi导出XCode工程\"></a>使用Tulsi导出XCode工程</h3><p>这步比较简单，按照官网即可，<a href=\"https://google.github.io/mediapipe/getting_started/building_examples.html#ios\" target=\"_blank\" rel=\"noopener\">https://google.github.io/mediapipe/getting_started/building_examples.html#ios</a></p>\n<h3 id=\"如何设置证书在真机上运行\"><a href=\"#如何设置证书在真机上运行\" class=\"headerlink\" title=\"如何设置证书在真机上运行\"></a>如何设置证书在真机上运行</h3><ul>\n<li><p>STEP 1</p>\n<p>  删除XCode编译产物，保证工程干净 XCode菜单 Product -&gt; Clean</p>\n</li>\n<li><p>STEP 2</p>\n<p>  删除bazel编译产物，同样保证工程干净，在mediapipe文件夹中执行：</p>\n<pre><code>bazel clean --expunge</code></pre></li>\n<li><p>STEP 3</p>\n<p>  使用控制台下载编译时需要下载的文件，测试网络是否通畅，随便找个临时文件夹就好，在控制台中打开文件夹，然后执行：</p>\n<pre><code>https://github.com/bazelbuild/rules_cc/archive/master.zip</code></pre><p>  这个文件不需要翻墙就能下载，如果下载失败，请检查自己的网络设置，把代理该干掉的干掉。</p>\n</li>\n<li><p>STEP 4</p>\n<p>  在mediapipe项目文件夹中执行：</p>\n<pre><code>python3 mediapipe/examples/ios/link_local_profiles.py</code></pre><p>这条命令有两个功能，先说第一个功能：</p>\n<ul>\n<li><p>生成bundleID前缀</p>\n<p>  生成的前缀会写到mediapipe/examples/ios/bundle_id.bzl中，长这个样子：<br><img src=\"https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2020/11/08/16048448781636.jpg\" alt=\"-w636\"><br>嫌它丑，也可以改成自己习惯用的，比如我就改成了”justinsong.Demo”,这个前缀只生成一次，后面不会重复生成。</p>\n</li>\n</ul>\n</li>\n<li><p>STEP 5</p>\n<p>  上一步第一次执行link_local_profiles.py脚本之后，生成了bundleID前缀，这时我们需要打开工程，为我们想要运行的例子修改bundleID，修改成 bundleID前缀+例子名的格式，修改后回车。</p>\n<blockquote>\n<p>例如：比如前缀是09a8dab3-7aa0-419e-9e6f-2fa48b7495f8.mediapipe.examples，要运行的例子是FaceDetectionCpu，那么你target的bundleID就要写成”09a8dab3-7aa0-419e-9e6f-2fa48b7495f8.mediapipe.examples.FaceDetectionCpu”<br><img src=\"https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2020/11/08/16048485814866.jpg\" alt=\"\"></p>\n</blockquote>\n</li>\n</ul>\n<ul>\n<li><p>STEP 6</p>\n<p>  在mediapipe项目文件夹中再次执行：</p>\n<pre><code>python3 mediapipe/examples/ios/link_local_profiles.py</code></pre><p>  用到这个脚本的第二个功能：</p>\n<ul>\n<li><p>创建mobileprovision替身</p>\n<p>  这一步会根据bundle_id.bzl中的bundleID前缀匹配example文件夹中各个target的bundelID，如果前缀相同，脚本就在这个例子的文件夹中创建一个mobileprovision的替身。</p>\n<blockquote>\n<p>注意！ 这一步想生效有个前提，是你的profile要在mediapipe/provisioning_profile.mobileprovision这个位置，否则失败，如果你的这个路径下没有mobileprovision，解决办法如下：</p>\n<ol>\n<li><p>如果你已经有mobileprovision，直接复制到mediapile/midiapile/路径下，你可能有的这个文件在~/Library/MobileDevice/Provisioning\\ Profiles/路径下面，拷一个没过期的过来，改个名字就行了</p>\n</li>\n<li><p>如果你没有这个东西，那就要按照苹果官方指引生成下载再拷贝改名了</p>\n</li>\n</ol>\n</blockquote>\n<p>  执行成功后，你的文件夹中会多一个mobileprovision的替身文件，且能看到原身的信息（如果看不到替身或点击替身找不到原身，回到STEP4重新做。）这时距离成功就差一步了 ：）<br><img src=\"https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2020/11/08/16048463886571.jpg\" alt=\"-w761\"></p>\n</li>\n</ul>\n</li>\n<li><p>STEP 7</p>\n<p>  回到XCode工程中，选择想要运行的target，运行！</p>\n</li>\n</ul>\n<p>（结束）</p>\n"},{"title":"MediaPipe学习顺序","date":"2020-11-09T06:45:06.000Z","_content":"\n> 刚刚接触MediaPipe，之前没有接触过机器学习相关的东西，上手MediaPipe发现周边知识缺了很多，趟过一遍之后，梳理了下比较合理的学习顺序\n\n### STEP 1 bazel使用流程\n\nhttps://docs.bazel.build/versions/master/tutorial/ios-app.html\n\n### STEP 2 MediaPipe Demo运行\n\nhttps://google.github.io/mediapipe/getting_started/building_examples.html\n\n### STEP 3 自制MediaPipe HelloWorld程序\n\nhttps://google.github.io/mediapipe/getting_started/hello_world_ios.html\n\n### STEP 4 MeidaPipe 工程化\n\n尝试将MediaPipe的编译成framework，方便引用，没有教程，自己探索\n\n### STEP 5 阅读MediaPipe 了解实现\n\n### STEP 6 自定义MediaPipe的图和算子\n\n","source":"_posts/MediaPipe学习顺序.md","raw":"---\ntitle: MediaPipe学习顺序\ndate: 2020-11-09 14:45:06\ntags:\n---\n\n> 刚刚接触MediaPipe，之前没有接触过机器学习相关的东西，上手MediaPipe发现周边知识缺了很多，趟过一遍之后，梳理了下比较合理的学习顺序\n\n### STEP 1 bazel使用流程\n\nhttps://docs.bazel.build/versions/master/tutorial/ios-app.html\n\n### STEP 2 MediaPipe Demo运行\n\nhttps://google.github.io/mediapipe/getting_started/building_examples.html\n\n### STEP 3 自制MediaPipe HelloWorld程序\n\nhttps://google.github.io/mediapipe/getting_started/hello_world_ios.html\n\n### STEP 4 MeidaPipe 工程化\n\n尝试将MediaPipe的编译成framework，方便引用，没有教程，自己探索\n\n### STEP 5 阅读MediaPipe 了解实现\n\n### STEP 6 自定义MediaPipe的图和算子\n\n","slug":"MediaPipe学习顺序","published":1,"updated":"2020-11-09T06:45:41.039Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckha6mh2m0000fxu70wth279v","content":"<blockquote>\n<p>刚刚接触MediaPipe，之前没有接触过机器学习相关的东西，上手MediaPipe发现周边知识缺了很多，趟过一遍之后，梳理了下比较合理的学习顺序</p>\n</blockquote>\n<h3 id=\"STEP-1-bazel使用流程\"><a href=\"#STEP-1-bazel使用流程\" class=\"headerlink\" title=\"STEP 1 bazel使用流程\"></a>STEP 1 bazel使用流程</h3><p><a href=\"https://docs.bazel.build/versions/master/tutorial/ios-app.html\" target=\"_blank\" rel=\"noopener\">https://docs.bazel.build/versions/master/tutorial/ios-app.html</a></p>\n<h3 id=\"STEP-2-MediaPipe-Demo运行\"><a href=\"#STEP-2-MediaPipe-Demo运行\" class=\"headerlink\" title=\"STEP 2 MediaPipe Demo运行\"></a>STEP 2 MediaPipe Demo运行</h3><p><a href=\"https://google.github.io/mediapipe/getting_started/building_examples.html\" target=\"_blank\" rel=\"noopener\">https://google.github.io/mediapipe/getting_started/building_examples.html</a></p>\n<h3 id=\"STEP-3-自制MediaPipe-HelloWorld程序\"><a href=\"#STEP-3-自制MediaPipe-HelloWorld程序\" class=\"headerlink\" title=\"STEP 3 自制MediaPipe HelloWorld程序\"></a>STEP 3 自制MediaPipe HelloWorld程序</h3><p><a href=\"https://google.github.io/mediapipe/getting_started/hello_world_ios.html\" target=\"_blank\" rel=\"noopener\">https://google.github.io/mediapipe/getting_started/hello_world_ios.html</a></p>\n<h3 id=\"STEP-4-MeidaPipe-工程化\"><a href=\"#STEP-4-MeidaPipe-工程化\" class=\"headerlink\" title=\"STEP 4 MeidaPipe 工程化\"></a>STEP 4 MeidaPipe 工程化</h3><p>尝试将MediaPipe的编译成framework，方便引用，没有教程，自己探索</p>\n<h3 id=\"STEP-5-阅读MediaPipe-了解实现\"><a href=\"#STEP-5-阅读MediaPipe-了解实现\" class=\"headerlink\" title=\"STEP 5 阅读MediaPipe 了解实现\"></a>STEP 5 阅读MediaPipe 了解实现</h3><h3 id=\"STEP-6-自定义MediaPipe的图和算子\"><a href=\"#STEP-6-自定义MediaPipe的图和算子\" class=\"headerlink\" title=\"STEP 6 自定义MediaPipe的图和算子\"></a>STEP 6 自定义MediaPipe的图和算子</h3>","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>刚刚接触MediaPipe，之前没有接触过机器学习相关的东西，上手MediaPipe发现周边知识缺了很多，趟过一遍之后，梳理了下比较合理的学习顺序</p>\n</blockquote>\n<h3 id=\"STEP-1-bazel使用流程\"><a href=\"#STEP-1-bazel使用流程\" class=\"headerlink\" title=\"STEP 1 bazel使用流程\"></a>STEP 1 bazel使用流程</h3><p><a href=\"https://docs.bazel.build/versions/master/tutorial/ios-app.html\" target=\"_blank\" rel=\"noopener\">https://docs.bazel.build/versions/master/tutorial/ios-app.html</a></p>\n<h3 id=\"STEP-2-MediaPipe-Demo运行\"><a href=\"#STEP-2-MediaPipe-Demo运行\" class=\"headerlink\" title=\"STEP 2 MediaPipe Demo运行\"></a>STEP 2 MediaPipe Demo运行</h3><p><a href=\"https://google.github.io/mediapipe/getting_started/building_examples.html\" target=\"_blank\" rel=\"noopener\">https://google.github.io/mediapipe/getting_started/building_examples.html</a></p>\n<h3 id=\"STEP-3-自制MediaPipe-HelloWorld程序\"><a href=\"#STEP-3-自制MediaPipe-HelloWorld程序\" class=\"headerlink\" title=\"STEP 3 自制MediaPipe HelloWorld程序\"></a>STEP 3 自制MediaPipe HelloWorld程序</h3><p><a href=\"https://google.github.io/mediapipe/getting_started/hello_world_ios.html\" target=\"_blank\" rel=\"noopener\">https://google.github.io/mediapipe/getting_started/hello_world_ios.html</a></p>\n<h3 id=\"STEP-4-MeidaPipe-工程化\"><a href=\"#STEP-4-MeidaPipe-工程化\" class=\"headerlink\" title=\"STEP 4 MeidaPipe 工程化\"></a>STEP 4 MeidaPipe 工程化</h3><p>尝试将MediaPipe的编译成framework，方便引用，没有教程，自己探索</p>\n<h3 id=\"STEP-5-阅读MediaPipe-了解实现\"><a href=\"#STEP-5-阅读MediaPipe-了解实现\" class=\"headerlink\" title=\"STEP 5 阅读MediaPipe 了解实现\"></a>STEP 5 阅读MediaPipe 了解实现</h3><h3 id=\"STEP-6-自定义MediaPipe的图和算子\"><a href=\"#STEP-6-自定义MediaPipe的图和算子\" class=\"headerlink\" title=\"STEP 6 自定义MediaPipe的图和算子\"></a>STEP 6 自定义MediaPipe的图和算子</h3>"},{"title":"NSString类文件夹路径的处理方法","date":"2020-12-31T02:53:24.000Z","_content":"\n## NSString类路径的处理方法:\n\n### 文件路径的处理:\n\nNSString *path = @\"/Uesrs/apple/testfile.txt\"\n\n常用方法如下:\n\n1. 获得组成此路径的各个组成部分，结果：（\"/\",\"User\",\"apple\",\"testfile.txt\"）\n\n    -(NSArray *)pathComponents;\n\n2. 提取路径的最后一个组成部分，结果：testfile.txt\n\n    - (NSString *)lastPathComponent;\n\n3. 删除路径的最后一个组成部分，结果：/Users/apple\n\n    - (NSString *)stringByDeletingLastPathCpmponent;\n\n4. 添加到路径的末尾，结果：/Users/apple/testfile.txt/app.txt\n\n    - (NSString *)stringByAppendingPathConmponent:(NSString *)str;\n\n5. 删除路径最后部分的扩展名，结果：/Users/apple/testfile\n\n    - (NSString *)stringByDeletingPathExtension;\n\n6. 路径最后部分追加扩展名，结果：/User/apple/testfile.txt.jpg\n\n    - (NSString *)stringByAppendingPathExtension:(NSString *)str;\n\n转自：https://www.jianshu.com/p/16e948b3d1d2","source":"_posts/NSString类文件夹路径的处理方法.md","raw":"---\ntitle: NSString类文件夹路径的处理方法\ndate: 2020-12-31 10:53:24\ntags:\n---\n\n## NSString类路径的处理方法:\n\n### 文件路径的处理:\n\nNSString *path = @\"/Uesrs/apple/testfile.txt\"\n\n常用方法如下:\n\n1. 获得组成此路径的各个组成部分，结果：（\"/\",\"User\",\"apple\",\"testfile.txt\"）\n\n    -(NSArray *)pathComponents;\n\n2. 提取路径的最后一个组成部分，结果：testfile.txt\n\n    - (NSString *)lastPathComponent;\n\n3. 删除路径的最后一个组成部分，结果：/Users/apple\n\n    - (NSString *)stringByDeletingLastPathCpmponent;\n\n4. 添加到路径的末尾，结果：/Users/apple/testfile.txt/app.txt\n\n    - (NSString *)stringByAppendingPathConmponent:(NSString *)str;\n\n5. 删除路径最后部分的扩展名，结果：/Users/apple/testfile\n\n    - (NSString *)stringByDeletingPathExtension;\n\n6. 路径最后部分追加扩展名，结果：/User/apple/testfile.txt.jpg\n\n    - (NSString *)stringByAppendingPathExtension:(NSString *)str;\n\n转自：https://www.jianshu.com/p/16e948b3d1d2","slug":"NSString类文件夹路径的处理方法","published":1,"updated":"2020-12-31T02:55:49.345Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckjc9b7wu0000g4u84lxo7gdh","content":"<h2 id=\"NSString类路径的处理方法\"><a href=\"#NSString类路径的处理方法\" class=\"headerlink\" title=\"NSString类路径的处理方法:\"></a>NSString类路径的处理方法:</h2><h3 id=\"文件路径的处理\"><a href=\"#文件路径的处理\" class=\"headerlink\" title=\"文件路径的处理:\"></a>文件路径的处理:</h3><p>NSString *path = @”/Uesrs/apple/testfile.txt”</p>\n<p>常用方法如下:</p>\n<ol>\n<li><p>获得组成此路径的各个组成部分，结果：（”/“,”User”,”apple”,”testfile.txt”）</p>\n<p> -(NSArray *)pathComponents;</p>\n</li>\n<li><p>提取路径的最后一个组成部分，结果：testfile.txt</p>\n<ul>\n<li>(NSString *)lastPathComponent;</li>\n</ul>\n</li>\n<li><p>删除路径的最后一个组成部分，结果：/Users/apple</p>\n<ul>\n<li>(NSString *)stringByDeletingLastPathCpmponent;</li>\n</ul>\n</li>\n<li><p>添加到路径的末尾，结果：/Users/apple/testfile.txt/app.txt</p>\n<ul>\n<li>(NSString *)stringByAppendingPathConmponent:(NSString *)str;</li>\n</ul>\n</li>\n<li><p>删除路径最后部分的扩展名，结果：/Users/apple/testfile</p>\n<ul>\n<li>(NSString *)stringByDeletingPathExtension;</li>\n</ul>\n</li>\n<li><p>路径最后部分追加扩展名，结果：/User/apple/testfile.txt.jpg</p>\n<ul>\n<li>(NSString *)stringByAppendingPathExtension:(NSString *)str;</li>\n</ul>\n</li>\n</ol>\n<p>转自：<a href=\"https://www.jianshu.com/p/16e948b3d1d2\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/16e948b3d1d2</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"NSString类路径的处理方法\"><a href=\"#NSString类路径的处理方法\" class=\"headerlink\" title=\"NSString类路径的处理方法:\"></a>NSString类路径的处理方法:</h2><h3 id=\"文件路径的处理\"><a href=\"#文件路径的处理\" class=\"headerlink\" title=\"文件路径的处理:\"></a>文件路径的处理:</h3><p>NSString *path = @”/Uesrs/apple/testfile.txt”</p>\n<p>常用方法如下:</p>\n<ol>\n<li><p>获得组成此路径的各个组成部分，结果：（”/“,”User”,”apple”,”testfile.txt”）</p>\n<p> -(NSArray *)pathComponents;</p>\n</li>\n<li><p>提取路径的最后一个组成部分，结果：testfile.txt</p>\n<ul>\n<li>(NSString *)lastPathComponent;</li>\n</ul>\n</li>\n<li><p>删除路径的最后一个组成部分，结果：/Users/apple</p>\n<ul>\n<li>(NSString *)stringByDeletingLastPathCpmponent;</li>\n</ul>\n</li>\n<li><p>添加到路径的末尾，结果：/Users/apple/testfile.txt/app.txt</p>\n<ul>\n<li>(NSString *)stringByAppendingPathConmponent:(NSString *)str;</li>\n</ul>\n</li>\n<li><p>删除路径最后部分的扩展名，结果：/Users/apple/testfile</p>\n<ul>\n<li>(NSString *)stringByDeletingPathExtension;</li>\n</ul>\n</li>\n<li><p>路径最后部分追加扩展名，结果：/User/apple/testfile.txt.jpg</p>\n<ul>\n<li>(NSString *)stringByAppendingPathExtension:(NSString *)str;</li>\n</ul>\n</li>\n</ol>\n<p>转自：<a href=\"https://www.jianshu.com/p/16e948b3d1d2\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/16e948b3d1d2</a></p>\n"},{"title":"iphone机型架构 & 对OpenGLES版本的支持情况","date":"2021-02-28T10:04:08.000Z","_content":"\n## 架构机型对照\n\n**armv7**：iPhone4｜iPhone4S｜iPad｜iPad2｜iPad3(The New iPad)｜iPad mini｜iPod Touch 3G｜iPod Touch4\n\n**armv7s**：iPhone5｜iPhone5C｜iPad4(iPad with Retina Display)\n\n**arm64**： iphone8 | iphone8 plus | iphoneX | iphone7 | iphone7 plus | iPhone6s | iphone6s plus｜iPhone6｜ iPhone6 plus｜iPhone5S\n\n**arm64e**：iPhone XS | iPhone XS Max | iPhone XR | iPhone 11 | iPhone 11 Pro | iphone 11 Pro Max\n\n**i386**是针对intel通用微处理器32位处理器\n\n**x86_64**是针对x86架构的64位处理器\n\n\n## OpenGLES支持情况\n\n1. **IOS从IOS7以上版本开始支持ES 3.0**\n\n2. **iphone 5及以下的机器只支持OpenGL2，不支持OpenGL3（包括iphone5c）**\n\n3. **iphone 5s及以上的机器开始支持OpenGL3.0**\n\n参考文档：https://www.cnblogs.com/singmelody/p/3774638.html\nhttps://zhidao.baidu.com/question/1833302402268128980.html\n","source":"_posts/iphone机型架构-对OpenGLES版本的支持情况.md","raw":"---\ntitle: iphone机型架构 & 对OpenGLES版本的支持情况\ndate: 2021-02-28 18:04:08\ntags:\n---\n\n## 架构机型对照\n\n**armv7**：iPhone4｜iPhone4S｜iPad｜iPad2｜iPad3(The New iPad)｜iPad mini｜iPod Touch 3G｜iPod Touch4\n\n**armv7s**：iPhone5｜iPhone5C｜iPad4(iPad with Retina Display)\n\n**arm64**： iphone8 | iphone8 plus | iphoneX | iphone7 | iphone7 plus | iPhone6s | iphone6s plus｜iPhone6｜ iPhone6 plus｜iPhone5S\n\n**arm64e**：iPhone XS | iPhone XS Max | iPhone XR | iPhone 11 | iPhone 11 Pro | iphone 11 Pro Max\n\n**i386**是针对intel通用微处理器32位处理器\n\n**x86_64**是针对x86架构的64位处理器\n\n\n## OpenGLES支持情况\n\n1. **IOS从IOS7以上版本开始支持ES 3.0**\n\n2. **iphone 5及以下的机器只支持OpenGL2，不支持OpenGL3（包括iphone5c）**\n\n3. **iphone 5s及以上的机器开始支持OpenGL3.0**\n\n参考文档：https://www.cnblogs.com/singmelody/p/3774638.html\nhttps://zhidao.baidu.com/question/1833302402268128980.html\n","slug":"iphone机型架构-对OpenGLES版本的支持情况","published":1,"updated":"2021-02-28T10:16:16.174Z","_id":"cklozlm2y000051ucgilcesjx","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"架构机型对照\"><a href=\"#架构机型对照\" class=\"headerlink\" title=\"架构机型对照\"></a>架构机型对照</h2><p><strong>armv7</strong>：iPhone4｜iPhone4S｜iPad｜iPad2｜iPad3(The New iPad)｜iPad mini｜iPod Touch 3G｜iPod Touch4</p>\n<p><strong>armv7s</strong>：iPhone5｜iPhone5C｜iPad4(iPad with Retina Display)</p>\n<p><strong>arm64</strong>： iphone8 | iphone8 plus | iphoneX | iphone7 | iphone7 plus | iPhone6s | iphone6s plus｜iPhone6｜ iPhone6 plus｜iPhone5S</p>\n<p><strong>arm64e</strong>：iPhone XS | iPhone XS Max | iPhone XR | iPhone 11 | iPhone 11 Pro | iphone 11 Pro Max</p>\n<p><strong>i386</strong>是针对intel通用微处理器32位处理器</p>\n<p><strong>x86_64</strong>是针对x86架构的64位处理器</p>\n<h2 id=\"OpenGLES支持情况\"><a href=\"#OpenGLES支持情况\" class=\"headerlink\" title=\"OpenGLES支持情况\"></a>OpenGLES支持情况</h2><ol>\n<li><p><strong>IOS从IOS7以上版本开始支持ES 3.0</strong></p>\n</li>\n<li><p><strong>iphone 5及以下的机器只支持OpenGL2，不支持OpenGL3（包括iphone5c）</strong></p>\n</li>\n<li><p><strong>iphone 5s及以上的机器开始支持OpenGL3.0</strong></p>\n</li>\n</ol>\n<p>参考文档：<a href=\"https://www.cnblogs.com/singmelody/p/3774638.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/singmelody/p/3774638.html</a><br><a href=\"https://zhidao.baidu.com/question/1833302402268128980.html\" target=\"_blank\" rel=\"noopener\">https://zhidao.baidu.com/question/1833302402268128980.html</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"架构机型对照\"><a href=\"#架构机型对照\" class=\"headerlink\" title=\"架构机型对照\"></a>架构机型对照</h2><p><strong>armv7</strong>：iPhone4｜iPhone4S｜iPad｜iPad2｜iPad3(The New iPad)｜iPad mini｜iPod Touch 3G｜iPod Touch4</p>\n<p><strong>armv7s</strong>：iPhone5｜iPhone5C｜iPad4(iPad with Retina Display)</p>\n<p><strong>arm64</strong>： iphone8 | iphone8 plus | iphoneX | iphone7 | iphone7 plus | iPhone6s | iphone6s plus｜iPhone6｜ iPhone6 plus｜iPhone5S</p>\n<p><strong>arm64e</strong>：iPhone XS | iPhone XS Max | iPhone XR | iPhone 11 | iPhone 11 Pro | iphone 11 Pro Max</p>\n<p><strong>i386</strong>是针对intel通用微处理器32位处理器</p>\n<p><strong>x86_64</strong>是针对x86架构的64位处理器</p>\n<h2 id=\"OpenGLES支持情况\"><a href=\"#OpenGLES支持情况\" class=\"headerlink\" title=\"OpenGLES支持情况\"></a>OpenGLES支持情况</h2><ol>\n<li><p><strong>IOS从IOS7以上版本开始支持ES 3.0</strong></p>\n</li>\n<li><p><strong>iphone 5及以下的机器只支持OpenGL2，不支持OpenGL3（包括iphone5c）</strong></p>\n</li>\n<li><p><strong>iphone 5s及以上的机器开始支持OpenGL3.0</strong></p>\n</li>\n</ol>\n<p>参考文档：<a href=\"https://www.cnblogs.com/singmelody/p/3774638.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/singmelody/p/3774638.html</a><br><a href=\"https://zhidao.baidu.com/question/1833302402268128980.html\" target=\"_blank\" rel=\"noopener\">https://zhidao.baidu.com/question/1833302402268128980.html</a></p>\n"},{"title":"正则表达式生成网站","date":"2021-03-15T06:22:30.000Z","_content":"\n* 语法\n    https://www.sojson.com/regex/generate\n    ![](https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2021/03/15/16157894397533.jpg)\n\n\n* 可视化正则表达式：\nhttps://regexper.com/#%2F.*%3Ffilter%3A%28.%2B%29%5C%5D%5Cs*time%20cost%3D%5Cs%5Cs*%28%5Cd%2B%5C.%5Cd%2B%29%5Cs*.*%2Fig\n![](https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2021/03/15/16157893743312.jpg)\n\n* 规则验证\nhttps://c.runoob.com/front-end/854\n![](https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2021/03/15/16157894692244.jpg)\n\n* 一个例子\n```\nconst regRenderTime = /.*?filter:(.+)\\]\\s*time cost=\\s\\s*(\\d+\\.\\d+)\\s*.*/ig;\nconst regInitTime = /.*?createFilter (.+)\\s*time cost=\\s*(\\d+\\.\\d+)/ig;\n```","source":"_posts/正则表达式生成网站.md","raw":"---\ntitle: 正则表达式生成网站\ndate: 2021-03-15 14:22:30\ntags:\n---\n\n* 语法\n    https://www.sojson.com/regex/generate\n    ![](https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2021/03/15/16157894397533.jpg)\n\n\n* 可视化正则表达式：\nhttps://regexper.com/#%2F.*%3Ffilter%3A%28.%2B%29%5C%5D%5Cs*time%20cost%3D%5Cs%5Cs*%28%5Cd%2B%5C.%5Cd%2B%29%5Cs*.*%2Fig\n![](https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2021/03/15/16157893743312.jpg)\n\n* 规则验证\nhttps://c.runoob.com/front-end/854\n![](https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2021/03/15/16157894692244.jpg)\n\n* 一个例子\n```\nconst regRenderTime = /.*?filter:(.+)\\]\\s*time cost=\\s\\s*(\\d+\\.\\d+)\\s*.*/ig;\nconst regInitTime = /.*?createFilter (.+)\\s*time cost=\\s*(\\d+\\.\\d+)/ig;\n```","slug":"正则表达式生成网站","published":1,"updated":"2021-03-15T06:25:02.155Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckma7cwze00004a0palf1b5n9","content":"<ul>\n<li>语法<br>  <a href=\"https://www.sojson.com/regex/generate\" target=\"_blank\" rel=\"noopener\">https://www.sojson.com/regex/generate</a><br>  <img src=\"https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2021/03/15/16157894397533.jpg\" alt=\"\"></li>\n</ul>\n<ul>\n<li><p>可视化正则表达式：<br><a href=\"https://regexper.com/#%2F.*%3Ffilter%3A%28.%2B%29%5C%5D%5Cs*time%20cost%3D%5Cs%5Cs*%28%5Cd%2B%5C.%5Cd%2B%29%5Cs*.*%2Fig\" target=\"_blank\" rel=\"noopener\">https://regexper.com/#%2F.*%3Ffilter%3A%28.%2B%29%5C%5D%5Cs*time%20cost%3D%5Cs%5Cs*%28%5Cd%2B%5C.%5Cd%2B%29%5Cs*.*%2Fig</a><br><img src=\"https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2021/03/15/16157893743312.jpg\" alt=\"\"></p>\n</li>\n<li><p>规则验证<br><a href=\"https://c.runoob.com/front-end/854\" target=\"_blank\" rel=\"noopener\">https://c.runoob.com/front-end/854</a><br><img src=\"https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2021/03/15/16157894692244.jpg\" alt=\"\"></p>\n</li>\n<li><p>一个例子</p>\n<pre><code>const regRenderTime = /.*?filter:(.+)\\]\\s*time cost=\\s\\s*(\\d+\\.\\d+)\\s*.*/ig;\nconst regInitTime = /.*?createFilter (.+)\\s*time cost=\\s*(\\d+\\.\\d+)/ig;</code></pre></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<ul>\n<li>语法<br>  <a href=\"https://www.sojson.com/regex/generate\" target=\"_blank\" rel=\"noopener\">https://www.sojson.com/regex/generate</a><br>  <img src=\"https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2021/03/15/16157894397533.jpg\" alt=\"\"></li>\n</ul>\n<ul>\n<li><p>可视化正则表达式：<br><a href=\"https://regexper.com/#%2F.*%3Ffilter%3A%28.%2B%29%5C%5D%5Cs*time%20cost%3D%5Cs%5Cs*%28%5Cd%2B%5C.%5Cd%2B%29%5Cs*.*%2Fig\" target=\"_blank\" rel=\"noopener\">https://regexper.com/#%2F.*%3Ffilter%3A%28.%2B%29%5C%5D%5Cs*time%20cost%3D%5Cs%5Cs*%28%5Cd%2B%5C.%5Cd%2B%29%5Cs*.*%2Fig</a><br><img src=\"https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2021/03/15/16157893743312.jpg\" alt=\"\"></p>\n</li>\n<li><p>规则验证<br><a href=\"https://c.runoob.com/front-end/854\" target=\"_blank\" rel=\"noopener\">https://c.runoob.com/front-end/854</a><br><img src=\"https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2021/03/15/16157894692244.jpg\" alt=\"\"></p>\n</li>\n<li><p>一个例子</p>\n<pre><code>const regRenderTime = /.*?filter:(.+)\\]\\s*time cost=\\s\\s*(\\d+\\.\\d+)\\s*.*/ig;\nconst regInitTime = /.*?createFilter (.+)\\s*time cost=\\s*(\\d+\\.\\d+)/ig;</code></pre></li>\n</ul>\n"},{"title":"CVPixelBufferRef 常用函数","date":"2021-03-16T07:07:49.000Z","_content":"# 常用函数\n\n## 加锁解锁\n\n```\nCVPixelBufferLockBaseAddress(pixelBuffer, 0);\nCVPixelBufferUnlockBaseAddress(pixelBuffer, 0);\n```\n\n## 引用释放\n\n```\nCFRetain(pixelBuffer);\nCFRelease(pixelBuffer);\n```\n\n## 获取通颜色道个数\n\n```\nint planeCount = CVPixelBufferGetPlaneCount(pixelBuffer);\n```\n\n## 获取颜色空间种类\n\n```\n/**基本只有kCVPixelFormatType_32BGRA和kCVPixelFormatType_32ABGR*/\nOSType type = CVPixelBufferGetPixelFormatType(pixelBuffer);\n```\n\n## 获取宽高\n\n```\nint width = (int)CVPixelBufferGetWidth(pixelBuffer);\nint height = (int)CVPixelBufferGetHeight(pixelBuffer);\n```\n\n## 获取buffer数据地址\n\n```\nunsigned char* srcBuffer = (unsigned char*)(CVPixelBufferGetBaseAddress(pixelBuffer));\n```\n\n## 获取数据长度\n\n```\n/** 这个接口获取的是完整的pixelbuffer数据长度，其中包含对齐像素的长度，有可能会比width * height * channel的结果大，多出来的就是对齐像素所占的字节数*/\nint srcLen = CVPixelBufferGetDataSize(pixelBuffer);\n```\n\n## 获取单行所占字节数\n\n```\n    CVPixelBufferLockBaseAddress(bgraPB, 0);\n\n    int bufferWidth = (int)CVPixelBufferGetWidth( bgraPB );\n    int bufferHeight = (int)CVPixelBufferGetHeight( bgraPB );\n    \n    /**单行所占字节数，其中包含对齐像素的大小*/\n    size_t srcRowBytes = CVPixelBufferGetBytesPerRow( bgraPB );\n    /**每个像素所占的字节数*/\n    long srcPixelBytes = srcRowBytes / bufferWidth;\n    /**整个buffer所占字节数，其中包含对齐像素的大小*/\n    long srcLen = CVPixelBufferGetDataSize(bgraPB);\n    \n    CVPixelBufferUnlockBaseAddress( bgraPB, 0 );\n```\n\n## 创建CVPixelBufferRef\n\n```\n/**Core Video并不支持RGBA格式，常用的支持有BGRA和ARGB，其他支持的格式查阅：https://developer.apple.com/library/archive/qa/qa1501/_index.html*/\n+ (CVPixelBufferRef)createPixelBuffer:(size_t)width height:(size_t)height formatType:(OSType)formatType\n{\n    CVPixelBufferRef pixel_buffer;\n    CFDictionaryRef empty; // empty value for attr value.\n    CFMutableDictionaryRef attrs;\n    \n    // our empty IOSurface properties dictionary\n    empty = CFDictionaryCreate(kCFAllocatorDefault\n                               , NULL\n                               , NULL\n                               , 0\n                               , &kCFTypeDictionaryKeyCallBacks\n                               , &kCFTypeDictionaryValueCallBacks);\n    attrs = CFDictionaryCreateMutable(kCFAllocatorDefault\n                                      , 1\n                                      , &kCFTypeDictionaryKeyCallBacks\n                                      , &kCFTypeDictionaryValueCallBacks);\n    CFDictionarySetValue(attrs, kCVPixelBufferIOSurfacePropertiesKey, empty);\n\n    CVReturn err = CVPixelBufferCreate(kCFAllocatorDefault, width, height, formatType, attrs, &pixel_buffer);\n    if (err) {\n        NSLog(@\"failed\");\n    }\n    CFRelease(attrs);\n    CFRelease(empty);\n    \n    return pixel_buffer;\n}\n```\n\n## CVPixelBufferRef转NSImage\n\n```\n/** pixelBuffer 转 NSImage*/\n+ (NSImage *)imageFromPixelBuffer:(CVPixelBufferRef)pixelBuffer {\n    CIImage *ciImage = [CIImage imageWithCVPixelBuffer:pixelBuffer];\n    CIContext *temporaryContext = [CIContext contextWithOptions:nil];\n    \n    CGRect frame = CGRectMake(0, 0, CVPixelBufferGetWidth(pixelBuffer), CVPixelBufferGetHeight(pixelBuffer));\n    CGImageRef videoImage = [temporaryContext createCGImage:ciImage fromRect:frame];\n\n    NSImage *image = [[NSImage alloc] initWithCGImage:videoImage size:NSZeroSize];\n    CGImageRelease(videoImage);\n\n    return image;\n}\n```\n\n# 坑点\n\n\n* 背景\n\n    MacOS下CVPixelBuffer直接转纹理转成的纹理target是GL_TEXTURE_RECTANGLE，需要再转换成通用的GL_TEXTURE_2D纹理。于是想到把buffer取出来自己上传。\n\n* 现象\n\n    CVPixelBufferRef取出buffer上传纹理之后，结果出现扭曲，逐行查找发现是`CVPixelBufferGetBytesPerRow`返回的数据多了4，这个API应该返回一行像素点所占用的字节数，比如一个4通道，宽高为240*450的图片，一行的字节数应该是4 * 240 = 960, 而实际情况是`CVPixelBufferGetBytesPerRow`返回了964，比宽度多了4个字节，也就是多了一个像素。\n\n* 原因\n    \n    一番搜索后，发现`CVPixelBufferGetBytesPerRow`返回的是屏幕真实显示的像素个数，有时会有对齐像素，导致获取的字节数不准确，可以知道这个api 与 width * channel是不等效的，不要用这个api来组装vImage_Buffer，mac和ios设备都会有这种对其像素。\n\n* 解决\n\n    我的解决办法是用计算出对齐像素的个数，逐行memcpy排除掉这些像素，然后在转NSImage或上传纹理。 如果有更好的方法请留言~\n\n一行代码胜千言，下面是我的CVPixelBuffer剔除对齐像素的代码：\n\n```\n\n+ (NSData *)rgbaBufferFromBGRAPixel:(CVPixelBufferRef)bgraPB {\n    \n    CVPixelBufferLockBaseAddress(bgraPB, 0);\n    \n    int bufferWidth = (int)CVPixelBufferGetWidth( bgraPB );\n    int bufferHeight = (int)CVPixelBufferGetHeight( bgraPB );\n    \n    /**源*/\n    size_t srcRowBytes = CVPixelBufferGetBytesPerRow( bgraPB );\n    long srcPixelBytes = srcRowBytes / bufferWidth;\n    long srcLen = CVPixelBufferGetDataSize(bgraPB);\n    uint8_t *srcBuffer = (uint8_t *)CVPixelBufferGetBaseAddress( bgraPB );\n    \n    /**目标*/\n    long destPixelBytes = 4;\n    size_t destRowBytes = bufferWidth * destPixelBytes;\n    long destLen = destRowBytes * bufferHeight;\n    uint8_t *destBuffer = (uint8_t *)malloc(destLen);\n    \n    /**逐行拷贝, 跳过无用的对齐像素，否则图像会扭曲*/\n    for ( int row = 0; row < bufferHeight; row++ )\n    {\n        uint8_t *srcAddress = srcBuffer + (row * srcRowBytes);\n        uint8_t *destAddress = destBuffer + (row * destRowBytes);\n        memcpy(destAddress, srcAddress, destRowBytes);\n    }\n    \n    CVPixelBufferUnlockBaseAddress( bgraPB, 0 );\n    \n    NSData *rgbaData = [[NSData alloc] initWithBytes:destBuffer length:destLen];\n    free(destBuffer);\n    \n    return rgbaData;\n}\n```\n记一篇Stack Overflow：\nhttps://stackoverflow.com/questions/44179891/avplayeritemvideooutput-copypixelbufferforitemtime-gives-incorrect-cvpixelbuffer/44211003#44211003","source":"_posts/CVPixelBufferRef-常用函数.md","raw":"---\ntitle: CVPixelBufferRef 常用函数\ndate: 2021-03-16 15:07:49\ntags:\n---\n# 常用函数\n\n## 加锁解锁\n\n```\nCVPixelBufferLockBaseAddress(pixelBuffer, 0);\nCVPixelBufferUnlockBaseAddress(pixelBuffer, 0);\n```\n\n## 引用释放\n\n```\nCFRetain(pixelBuffer);\nCFRelease(pixelBuffer);\n```\n\n## 获取通颜色道个数\n\n```\nint planeCount = CVPixelBufferGetPlaneCount(pixelBuffer);\n```\n\n## 获取颜色空间种类\n\n```\n/**基本只有kCVPixelFormatType_32BGRA和kCVPixelFormatType_32ABGR*/\nOSType type = CVPixelBufferGetPixelFormatType(pixelBuffer);\n```\n\n## 获取宽高\n\n```\nint width = (int)CVPixelBufferGetWidth(pixelBuffer);\nint height = (int)CVPixelBufferGetHeight(pixelBuffer);\n```\n\n## 获取buffer数据地址\n\n```\nunsigned char* srcBuffer = (unsigned char*)(CVPixelBufferGetBaseAddress(pixelBuffer));\n```\n\n## 获取数据长度\n\n```\n/** 这个接口获取的是完整的pixelbuffer数据长度，其中包含对齐像素的长度，有可能会比width * height * channel的结果大，多出来的就是对齐像素所占的字节数*/\nint srcLen = CVPixelBufferGetDataSize(pixelBuffer);\n```\n\n## 获取单行所占字节数\n\n```\n    CVPixelBufferLockBaseAddress(bgraPB, 0);\n\n    int bufferWidth = (int)CVPixelBufferGetWidth( bgraPB );\n    int bufferHeight = (int)CVPixelBufferGetHeight( bgraPB );\n    \n    /**单行所占字节数，其中包含对齐像素的大小*/\n    size_t srcRowBytes = CVPixelBufferGetBytesPerRow( bgraPB );\n    /**每个像素所占的字节数*/\n    long srcPixelBytes = srcRowBytes / bufferWidth;\n    /**整个buffer所占字节数，其中包含对齐像素的大小*/\n    long srcLen = CVPixelBufferGetDataSize(bgraPB);\n    \n    CVPixelBufferUnlockBaseAddress( bgraPB, 0 );\n```\n\n## 创建CVPixelBufferRef\n\n```\n/**Core Video并不支持RGBA格式，常用的支持有BGRA和ARGB，其他支持的格式查阅：https://developer.apple.com/library/archive/qa/qa1501/_index.html*/\n+ (CVPixelBufferRef)createPixelBuffer:(size_t)width height:(size_t)height formatType:(OSType)formatType\n{\n    CVPixelBufferRef pixel_buffer;\n    CFDictionaryRef empty; // empty value for attr value.\n    CFMutableDictionaryRef attrs;\n    \n    // our empty IOSurface properties dictionary\n    empty = CFDictionaryCreate(kCFAllocatorDefault\n                               , NULL\n                               , NULL\n                               , 0\n                               , &kCFTypeDictionaryKeyCallBacks\n                               , &kCFTypeDictionaryValueCallBacks);\n    attrs = CFDictionaryCreateMutable(kCFAllocatorDefault\n                                      , 1\n                                      , &kCFTypeDictionaryKeyCallBacks\n                                      , &kCFTypeDictionaryValueCallBacks);\n    CFDictionarySetValue(attrs, kCVPixelBufferIOSurfacePropertiesKey, empty);\n\n    CVReturn err = CVPixelBufferCreate(kCFAllocatorDefault, width, height, formatType, attrs, &pixel_buffer);\n    if (err) {\n        NSLog(@\"failed\");\n    }\n    CFRelease(attrs);\n    CFRelease(empty);\n    \n    return pixel_buffer;\n}\n```\n\n## CVPixelBufferRef转NSImage\n\n```\n/** pixelBuffer 转 NSImage*/\n+ (NSImage *)imageFromPixelBuffer:(CVPixelBufferRef)pixelBuffer {\n    CIImage *ciImage = [CIImage imageWithCVPixelBuffer:pixelBuffer];\n    CIContext *temporaryContext = [CIContext contextWithOptions:nil];\n    \n    CGRect frame = CGRectMake(0, 0, CVPixelBufferGetWidth(pixelBuffer), CVPixelBufferGetHeight(pixelBuffer));\n    CGImageRef videoImage = [temporaryContext createCGImage:ciImage fromRect:frame];\n\n    NSImage *image = [[NSImage alloc] initWithCGImage:videoImage size:NSZeroSize];\n    CGImageRelease(videoImage);\n\n    return image;\n}\n```\n\n# 坑点\n\n\n* 背景\n\n    MacOS下CVPixelBuffer直接转纹理转成的纹理target是GL_TEXTURE_RECTANGLE，需要再转换成通用的GL_TEXTURE_2D纹理。于是想到把buffer取出来自己上传。\n\n* 现象\n\n    CVPixelBufferRef取出buffer上传纹理之后，结果出现扭曲，逐行查找发现是`CVPixelBufferGetBytesPerRow`返回的数据多了4，这个API应该返回一行像素点所占用的字节数，比如一个4通道，宽高为240*450的图片，一行的字节数应该是4 * 240 = 960, 而实际情况是`CVPixelBufferGetBytesPerRow`返回了964，比宽度多了4个字节，也就是多了一个像素。\n\n* 原因\n    \n    一番搜索后，发现`CVPixelBufferGetBytesPerRow`返回的是屏幕真实显示的像素个数，有时会有对齐像素，导致获取的字节数不准确，可以知道这个api 与 width * channel是不等效的，不要用这个api来组装vImage_Buffer，mac和ios设备都会有这种对其像素。\n\n* 解决\n\n    我的解决办法是用计算出对齐像素的个数，逐行memcpy排除掉这些像素，然后在转NSImage或上传纹理。 如果有更好的方法请留言~\n\n一行代码胜千言，下面是我的CVPixelBuffer剔除对齐像素的代码：\n\n```\n\n+ (NSData *)rgbaBufferFromBGRAPixel:(CVPixelBufferRef)bgraPB {\n    \n    CVPixelBufferLockBaseAddress(bgraPB, 0);\n    \n    int bufferWidth = (int)CVPixelBufferGetWidth( bgraPB );\n    int bufferHeight = (int)CVPixelBufferGetHeight( bgraPB );\n    \n    /**源*/\n    size_t srcRowBytes = CVPixelBufferGetBytesPerRow( bgraPB );\n    long srcPixelBytes = srcRowBytes / bufferWidth;\n    long srcLen = CVPixelBufferGetDataSize(bgraPB);\n    uint8_t *srcBuffer = (uint8_t *)CVPixelBufferGetBaseAddress( bgraPB );\n    \n    /**目标*/\n    long destPixelBytes = 4;\n    size_t destRowBytes = bufferWidth * destPixelBytes;\n    long destLen = destRowBytes * bufferHeight;\n    uint8_t *destBuffer = (uint8_t *)malloc(destLen);\n    \n    /**逐行拷贝, 跳过无用的对齐像素，否则图像会扭曲*/\n    for ( int row = 0; row < bufferHeight; row++ )\n    {\n        uint8_t *srcAddress = srcBuffer + (row * srcRowBytes);\n        uint8_t *destAddress = destBuffer + (row * destRowBytes);\n        memcpy(destAddress, srcAddress, destRowBytes);\n    }\n    \n    CVPixelBufferUnlockBaseAddress( bgraPB, 0 );\n    \n    NSData *rgbaData = [[NSData alloc] initWithBytes:destBuffer length:destLen];\n    free(destBuffer);\n    \n    return rgbaData;\n}\n```\n记一篇Stack Overflow：\nhttps://stackoverflow.com/questions/44179891/avplayeritemvideooutput-copypixelbufferforitemtime-gives-incorrect-cvpixelbuffer/44211003#44211003","slug":"CVPixelBufferRef-常用函数","published":1,"updated":"2021-03-16T07:08:13.885Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmbocalh00006m0p8nbcfx27","content":"<h1 id=\"常用函数\"><a href=\"#常用函数\" class=\"headerlink\" title=\"常用函数\"></a>常用函数</h1><h2 id=\"加锁解锁\"><a href=\"#加锁解锁\" class=\"headerlink\" title=\"加锁解锁\"></a>加锁解锁</h2><pre><code>CVPixelBufferLockBaseAddress(pixelBuffer, 0);\nCVPixelBufferUnlockBaseAddress(pixelBuffer, 0);</code></pre><h2 id=\"引用释放\"><a href=\"#引用释放\" class=\"headerlink\" title=\"引用释放\"></a>引用释放</h2><pre><code>CFRetain(pixelBuffer);\nCFRelease(pixelBuffer);</code></pre><h2 id=\"获取通颜色道个数\"><a href=\"#获取通颜色道个数\" class=\"headerlink\" title=\"获取通颜色道个数\"></a>获取通颜色道个数</h2><pre><code>int planeCount = CVPixelBufferGetPlaneCount(pixelBuffer);</code></pre><h2 id=\"获取颜色空间种类\"><a href=\"#获取颜色空间种类\" class=\"headerlink\" title=\"获取颜色空间种类\"></a>获取颜色空间种类</h2><pre><code>/**基本只有kCVPixelFormatType_32BGRA和kCVPixelFormatType_32ABGR*/\nOSType type = CVPixelBufferGetPixelFormatType(pixelBuffer);</code></pre><h2 id=\"获取宽高\"><a href=\"#获取宽高\" class=\"headerlink\" title=\"获取宽高\"></a>获取宽高</h2><pre><code>int width = (int)CVPixelBufferGetWidth(pixelBuffer);\nint height = (int)CVPixelBufferGetHeight(pixelBuffer);</code></pre><h2 id=\"获取buffer数据地址\"><a href=\"#获取buffer数据地址\" class=\"headerlink\" title=\"获取buffer数据地址\"></a>获取buffer数据地址</h2><pre><code>unsigned char* srcBuffer = (unsigned char*)(CVPixelBufferGetBaseAddress(pixelBuffer));</code></pre><h2 id=\"获取数据长度\"><a href=\"#获取数据长度\" class=\"headerlink\" title=\"获取数据长度\"></a>获取数据长度</h2><pre><code>/** 这个接口获取的是完整的pixelbuffer数据长度，其中包含对齐像素的长度，有可能会比width * height * channel的结果大，多出来的就是对齐像素所占的字节数*/\nint srcLen = CVPixelBufferGetDataSize(pixelBuffer);</code></pre><h2 id=\"获取单行所占字节数\"><a href=\"#获取单行所占字节数\" class=\"headerlink\" title=\"获取单行所占字节数\"></a>获取单行所占字节数</h2><pre><code>    CVPixelBufferLockBaseAddress(bgraPB, 0);\n\n    int bufferWidth = (int)CVPixelBufferGetWidth( bgraPB );\n    int bufferHeight = (int)CVPixelBufferGetHeight( bgraPB );\n\n    /**单行所占字节数，其中包含对齐像素的大小*/\n    size_t srcRowBytes = CVPixelBufferGetBytesPerRow( bgraPB );\n    /**每个像素所占的字节数*/\n    long srcPixelBytes = srcRowBytes / bufferWidth;\n    /**整个buffer所占字节数，其中包含对齐像素的大小*/\n    long srcLen = CVPixelBufferGetDataSize(bgraPB);\n\n    CVPixelBufferUnlockBaseAddress( bgraPB, 0 );</code></pre><h2 id=\"创建CVPixelBufferRef\"><a href=\"#创建CVPixelBufferRef\" class=\"headerlink\" title=\"创建CVPixelBufferRef\"></a>创建CVPixelBufferRef</h2><pre><code>/**Core Video并不支持RGBA格式，常用的支持有BGRA和ARGB，其他支持的格式查阅：https://developer.apple.com/library/archive/qa/qa1501/_index.html*/\n+ (CVPixelBufferRef)createPixelBuffer:(size_t)width height:(size_t)height formatType:(OSType)formatType\n{\n    CVPixelBufferRef pixel_buffer;\n    CFDictionaryRef empty; // empty value for attr value.\n    CFMutableDictionaryRef attrs;\n\n    // our empty IOSurface properties dictionary\n    empty = CFDictionaryCreate(kCFAllocatorDefault\n                               , NULL\n                               , NULL\n                               , 0\n                               , &amp;kCFTypeDictionaryKeyCallBacks\n                               , &amp;kCFTypeDictionaryValueCallBacks);\n    attrs = CFDictionaryCreateMutable(kCFAllocatorDefault\n                                      , 1\n                                      , &amp;kCFTypeDictionaryKeyCallBacks\n                                      , &amp;kCFTypeDictionaryValueCallBacks);\n    CFDictionarySetValue(attrs, kCVPixelBufferIOSurfacePropertiesKey, empty);\n\n    CVReturn err = CVPixelBufferCreate(kCFAllocatorDefault, width, height, formatType, attrs, &amp;pixel_buffer);\n    if (err) {\n        NSLog(@&quot;failed&quot;);\n    }\n    CFRelease(attrs);\n    CFRelease(empty);\n\n    return pixel_buffer;\n}</code></pre><h2 id=\"CVPixelBufferRef转NSImage\"><a href=\"#CVPixelBufferRef转NSImage\" class=\"headerlink\" title=\"CVPixelBufferRef转NSImage\"></a>CVPixelBufferRef转NSImage</h2><pre><code>/** pixelBuffer 转 NSImage*/\n+ (NSImage *)imageFromPixelBuffer:(CVPixelBufferRef)pixelBuffer {\n    CIImage *ciImage = [CIImage imageWithCVPixelBuffer:pixelBuffer];\n    CIContext *temporaryContext = [CIContext contextWithOptions:nil];\n\n    CGRect frame = CGRectMake(0, 0, CVPixelBufferGetWidth(pixelBuffer), CVPixelBufferGetHeight(pixelBuffer));\n    CGImageRef videoImage = [temporaryContext createCGImage:ciImage fromRect:frame];\n\n    NSImage *image = [[NSImage alloc] initWithCGImage:videoImage size:NSZeroSize];\n    CGImageRelease(videoImage);\n\n    return image;\n}</code></pre><h1 id=\"坑点\"><a href=\"#坑点\" class=\"headerlink\" title=\"坑点\"></a>坑点</h1><ul>\n<li><p>背景</p>\n<p>  MacOS下CVPixelBuffer直接转纹理转成的纹理target是GL_TEXTURE_RECTANGLE，需要再转换成通用的GL_TEXTURE_2D纹理。于是想到把buffer取出来自己上传。</p>\n</li>\n<li><p>现象</p>\n<p>  CVPixelBufferRef取出buffer上传纹理之后，结果出现扭曲，逐行查找发现是<code>CVPixelBufferGetBytesPerRow</code>返回的数据多了4，这个API应该返回一行像素点所占用的字节数，比如一个4通道，宽高为240*450的图片，一行的字节数应该是4 * 240 = 960, 而实际情况是<code>CVPixelBufferGetBytesPerRow</code>返回了964，比宽度多了4个字节，也就是多了一个像素。</p>\n</li>\n<li><p>原因</p>\n<p>  一番搜索后，发现<code>CVPixelBufferGetBytesPerRow</code>返回的是屏幕真实显示的像素个数，有时会有对齐像素，导致获取的字节数不准确，可以知道这个api 与 width * channel是不等效的，不要用这个api来组装vImage_Buffer，mac和ios设备都会有这种对其像素。</p>\n</li>\n<li><p>解决</p>\n<p>  我的解决办法是用计算出对齐像素的个数，逐行memcpy排除掉这些像素，然后在转NSImage或上传纹理。 如果有更好的方法请留言~</p>\n</li>\n</ul>\n<p>一行代码胜千言，下面是我的CVPixelBuffer剔除对齐像素的代码：</p>\n<pre><code>\n+ (NSData *)rgbaBufferFromBGRAPixel:(CVPixelBufferRef)bgraPB {\n\n    CVPixelBufferLockBaseAddress(bgraPB, 0);\n\n    int bufferWidth = (int)CVPixelBufferGetWidth( bgraPB );\n    int bufferHeight = (int)CVPixelBufferGetHeight( bgraPB );\n\n    /**源*/\n    size_t srcRowBytes = CVPixelBufferGetBytesPerRow( bgraPB );\n    long srcPixelBytes = srcRowBytes / bufferWidth;\n    long srcLen = CVPixelBufferGetDataSize(bgraPB);\n    uint8_t *srcBuffer = (uint8_t *)CVPixelBufferGetBaseAddress( bgraPB );\n\n    /**目标*/\n    long destPixelBytes = 4;\n    size_t destRowBytes = bufferWidth * destPixelBytes;\n    long destLen = destRowBytes * bufferHeight;\n    uint8_t *destBuffer = (uint8_t *)malloc(destLen);\n\n    /**逐行拷贝, 跳过无用的对齐像素，否则图像会扭曲*/\n    for ( int row = 0; row &lt; bufferHeight; row++ )\n    {\n        uint8_t *srcAddress = srcBuffer + (row * srcRowBytes);\n        uint8_t *destAddress = destBuffer + (row * destRowBytes);\n        memcpy(destAddress, srcAddress, destRowBytes);\n    }\n\n    CVPixelBufferUnlockBaseAddress( bgraPB, 0 );\n\n    NSData *rgbaData = [[NSData alloc] initWithBytes:destBuffer length:destLen];\n    free(destBuffer);\n\n    return rgbaData;\n}</code></pre><p>记一篇Stack Overflow：<br><a href=\"https://stackoverflow.com/questions/44179891/avplayeritemvideooutput-copypixelbufferforitemtime-gives-incorrect-cvpixelbuffer/44211003#44211003\" target=\"_blank\" rel=\"noopener\">https://stackoverflow.com/questions/44179891/avplayeritemvideooutput-copypixelbufferforitemtime-gives-incorrect-cvpixelbuffer/44211003#44211003</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"常用函数\"><a href=\"#常用函数\" class=\"headerlink\" title=\"常用函数\"></a>常用函数</h1><h2 id=\"加锁解锁\"><a href=\"#加锁解锁\" class=\"headerlink\" title=\"加锁解锁\"></a>加锁解锁</h2><pre><code>CVPixelBufferLockBaseAddress(pixelBuffer, 0);\nCVPixelBufferUnlockBaseAddress(pixelBuffer, 0);</code></pre><h2 id=\"引用释放\"><a href=\"#引用释放\" class=\"headerlink\" title=\"引用释放\"></a>引用释放</h2><pre><code>CFRetain(pixelBuffer);\nCFRelease(pixelBuffer);</code></pre><h2 id=\"获取通颜色道个数\"><a href=\"#获取通颜色道个数\" class=\"headerlink\" title=\"获取通颜色道个数\"></a>获取通颜色道个数</h2><pre><code>int planeCount = CVPixelBufferGetPlaneCount(pixelBuffer);</code></pre><h2 id=\"获取颜色空间种类\"><a href=\"#获取颜色空间种类\" class=\"headerlink\" title=\"获取颜色空间种类\"></a>获取颜色空间种类</h2><pre><code>/**基本只有kCVPixelFormatType_32BGRA和kCVPixelFormatType_32ABGR*/\nOSType type = CVPixelBufferGetPixelFormatType(pixelBuffer);</code></pre><h2 id=\"获取宽高\"><a href=\"#获取宽高\" class=\"headerlink\" title=\"获取宽高\"></a>获取宽高</h2><pre><code>int width = (int)CVPixelBufferGetWidth(pixelBuffer);\nint height = (int)CVPixelBufferGetHeight(pixelBuffer);</code></pre><h2 id=\"获取buffer数据地址\"><a href=\"#获取buffer数据地址\" class=\"headerlink\" title=\"获取buffer数据地址\"></a>获取buffer数据地址</h2><pre><code>unsigned char* srcBuffer = (unsigned char*)(CVPixelBufferGetBaseAddress(pixelBuffer));</code></pre><h2 id=\"获取数据长度\"><a href=\"#获取数据长度\" class=\"headerlink\" title=\"获取数据长度\"></a>获取数据长度</h2><pre><code>/** 这个接口获取的是完整的pixelbuffer数据长度，其中包含对齐像素的长度，有可能会比width * height * channel的结果大，多出来的就是对齐像素所占的字节数*/\nint srcLen = CVPixelBufferGetDataSize(pixelBuffer);</code></pre><h2 id=\"获取单行所占字节数\"><a href=\"#获取单行所占字节数\" class=\"headerlink\" title=\"获取单行所占字节数\"></a>获取单行所占字节数</h2><pre><code>    CVPixelBufferLockBaseAddress(bgraPB, 0);\n\n    int bufferWidth = (int)CVPixelBufferGetWidth( bgraPB );\n    int bufferHeight = (int)CVPixelBufferGetHeight( bgraPB );\n\n    /**单行所占字节数，其中包含对齐像素的大小*/\n    size_t srcRowBytes = CVPixelBufferGetBytesPerRow( bgraPB );\n    /**每个像素所占的字节数*/\n    long srcPixelBytes = srcRowBytes / bufferWidth;\n    /**整个buffer所占字节数，其中包含对齐像素的大小*/\n    long srcLen = CVPixelBufferGetDataSize(bgraPB);\n\n    CVPixelBufferUnlockBaseAddress( bgraPB, 0 );</code></pre><h2 id=\"创建CVPixelBufferRef\"><a href=\"#创建CVPixelBufferRef\" class=\"headerlink\" title=\"创建CVPixelBufferRef\"></a>创建CVPixelBufferRef</h2><pre><code>/**Core Video并不支持RGBA格式，常用的支持有BGRA和ARGB，其他支持的格式查阅：https://developer.apple.com/library/archive/qa/qa1501/_index.html*/\n+ (CVPixelBufferRef)createPixelBuffer:(size_t)width height:(size_t)height formatType:(OSType)formatType\n{\n    CVPixelBufferRef pixel_buffer;\n    CFDictionaryRef empty; // empty value for attr value.\n    CFMutableDictionaryRef attrs;\n\n    // our empty IOSurface properties dictionary\n    empty = CFDictionaryCreate(kCFAllocatorDefault\n                               , NULL\n                               , NULL\n                               , 0\n                               , &amp;kCFTypeDictionaryKeyCallBacks\n                               , &amp;kCFTypeDictionaryValueCallBacks);\n    attrs = CFDictionaryCreateMutable(kCFAllocatorDefault\n                                      , 1\n                                      , &amp;kCFTypeDictionaryKeyCallBacks\n                                      , &amp;kCFTypeDictionaryValueCallBacks);\n    CFDictionarySetValue(attrs, kCVPixelBufferIOSurfacePropertiesKey, empty);\n\n    CVReturn err = CVPixelBufferCreate(kCFAllocatorDefault, width, height, formatType, attrs, &amp;pixel_buffer);\n    if (err) {\n        NSLog(@&quot;failed&quot;);\n    }\n    CFRelease(attrs);\n    CFRelease(empty);\n\n    return pixel_buffer;\n}</code></pre><h2 id=\"CVPixelBufferRef转NSImage\"><a href=\"#CVPixelBufferRef转NSImage\" class=\"headerlink\" title=\"CVPixelBufferRef转NSImage\"></a>CVPixelBufferRef转NSImage</h2><pre><code>/** pixelBuffer 转 NSImage*/\n+ (NSImage *)imageFromPixelBuffer:(CVPixelBufferRef)pixelBuffer {\n    CIImage *ciImage = [CIImage imageWithCVPixelBuffer:pixelBuffer];\n    CIContext *temporaryContext = [CIContext contextWithOptions:nil];\n\n    CGRect frame = CGRectMake(0, 0, CVPixelBufferGetWidth(pixelBuffer), CVPixelBufferGetHeight(pixelBuffer));\n    CGImageRef videoImage = [temporaryContext createCGImage:ciImage fromRect:frame];\n\n    NSImage *image = [[NSImage alloc] initWithCGImage:videoImage size:NSZeroSize];\n    CGImageRelease(videoImage);\n\n    return image;\n}</code></pre><h1 id=\"坑点\"><a href=\"#坑点\" class=\"headerlink\" title=\"坑点\"></a>坑点</h1><ul>\n<li><p>背景</p>\n<p>  MacOS下CVPixelBuffer直接转纹理转成的纹理target是GL_TEXTURE_RECTANGLE，需要再转换成通用的GL_TEXTURE_2D纹理。于是想到把buffer取出来自己上传。</p>\n</li>\n<li><p>现象</p>\n<p>  CVPixelBufferRef取出buffer上传纹理之后，结果出现扭曲，逐行查找发现是<code>CVPixelBufferGetBytesPerRow</code>返回的数据多了4，这个API应该返回一行像素点所占用的字节数，比如一个4通道，宽高为240*450的图片，一行的字节数应该是4 * 240 = 960, 而实际情况是<code>CVPixelBufferGetBytesPerRow</code>返回了964，比宽度多了4个字节，也就是多了一个像素。</p>\n</li>\n<li><p>原因</p>\n<p>  一番搜索后，发现<code>CVPixelBufferGetBytesPerRow</code>返回的是屏幕真实显示的像素个数，有时会有对齐像素，导致获取的字节数不准确，可以知道这个api 与 width * channel是不等效的，不要用这个api来组装vImage_Buffer，mac和ios设备都会有这种对其像素。</p>\n</li>\n<li><p>解决</p>\n<p>  我的解决办法是用计算出对齐像素的个数，逐行memcpy排除掉这些像素，然后在转NSImage或上传纹理。 如果有更好的方法请留言~</p>\n</li>\n</ul>\n<p>一行代码胜千言，下面是我的CVPixelBuffer剔除对齐像素的代码：</p>\n<pre><code>\n+ (NSData *)rgbaBufferFromBGRAPixel:(CVPixelBufferRef)bgraPB {\n\n    CVPixelBufferLockBaseAddress(bgraPB, 0);\n\n    int bufferWidth = (int)CVPixelBufferGetWidth( bgraPB );\n    int bufferHeight = (int)CVPixelBufferGetHeight( bgraPB );\n\n    /**源*/\n    size_t srcRowBytes = CVPixelBufferGetBytesPerRow( bgraPB );\n    long srcPixelBytes = srcRowBytes / bufferWidth;\n    long srcLen = CVPixelBufferGetDataSize(bgraPB);\n    uint8_t *srcBuffer = (uint8_t *)CVPixelBufferGetBaseAddress( bgraPB );\n\n    /**目标*/\n    long destPixelBytes = 4;\n    size_t destRowBytes = bufferWidth * destPixelBytes;\n    long destLen = destRowBytes * bufferHeight;\n    uint8_t *destBuffer = (uint8_t *)malloc(destLen);\n\n    /**逐行拷贝, 跳过无用的对齐像素，否则图像会扭曲*/\n    for ( int row = 0; row &lt; bufferHeight; row++ )\n    {\n        uint8_t *srcAddress = srcBuffer + (row * srcRowBytes);\n        uint8_t *destAddress = destBuffer + (row * destRowBytes);\n        memcpy(destAddress, srcAddress, destRowBytes);\n    }\n\n    CVPixelBufferUnlockBaseAddress( bgraPB, 0 );\n\n    NSData *rgbaData = [[NSData alloc] initWithBytes:destBuffer length:destLen];\n    free(destBuffer);\n\n    return rgbaData;\n}</code></pre><p>记一篇Stack Overflow：<br><a href=\"https://stackoverflow.com/questions/44179891/avplayeritemvideooutput-copypixelbufferforitemtime-gives-incorrect-cvpixelbuffer/44211003#44211003\" target=\"_blank\" rel=\"noopener\">https://stackoverflow.com/questions/44179891/avplayeritemvideooutput-copypixelbufferforitemtime-gives-incorrect-cvpixelbuffer/44211003#44211003</a></p>\n"},{"title":"设置ios摄像头分辨率","date":"2021-03-16T14:10:13.000Z","_content":"\n资料：\nhttps://www.jianshu.com/p/b176621f2d79","source":"_posts/设置ios摄像头分辨率.md","raw":"---\ntitle: 设置ios摄像头分辨率\ndate: 2021-03-16 22:10:13\ntags:\n---\n\n资料：\nhttps://www.jianshu.com/p/b176621f2d79","slug":"设置ios摄像头分辨率","published":1,"updated":"2021-03-16T14:10:47.688Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmc3fuck00000y0pda1o5ek6","content":"<p>资料：<br><a href=\"https://www.jianshu.com/p/b176621f2d79\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/b176621f2d79</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>资料：<br><a href=\"https://www.jianshu.com/p/b176621f2d79\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/b176621f2d79</a></p>\n"},{"title":"Xcode自动管理证书文件模式下更新provisioning profile文件","date":"2021-03-18T07:22:50.000Z","_content":"\n原文地址：https://www.jianshu.com/p/f127c51a0603\n","source":"_posts/Xcode自动管理证书文件模式下更新provisioning-profile文件.md","raw":"---\ntitle: Xcode自动管理证书文件模式下更新provisioning profile文件\ndate: 2021-03-18 15:22:50\ntags:\n---\n\n原文地址：https://www.jianshu.com/p/f127c51a0603\n","slug":"Xcode自动管理证书文件模式下更新provisioning-profile文件","published":1,"updated":"2021-03-18T07:23:57.302Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmejsb7u0000dx0p478x4wfx","content":"<p>原文地址：<a href=\"https://www.jianshu.com/p/f127c51a0603\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/f127c51a0603</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>原文地址：<a href=\"https://www.jianshu.com/p/f127c51a0603\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/f127c51a0603</a></p>\n"},{"title":"iOS库中bitcode、架构、静态动态的判断","date":"2021-05-11T07:00:11.000Z","_content":"\n### 判断是否支持bitcode\n执行命令：\n```\notool -arch arm64 -l xxxxx.a(二进制文件) | grep __bitcode | wc -l\n```\n\n* 结果非0： 支持bitcode\n* 结果0：不支持bitcode\n\n### 判断库中的架构\n\n执行命令：\n```\nlipo -i xxx.a(二进制文件)\n```\n支持的架构会打印出来\n\n### 判断静态库还是动态库\n\n执行命令：\n\n```\nfile xxx.a(二进制文件)\n```\n* 静态库包含`current ar archive random library`字样。\n* 动态库包含`dynamically linked shared library`字样\n\n","source":"_posts/iOS库中bitcode、架构、静态动态的判断.md","raw":"---\ntitle: iOS库中bitcode、架构、静态动态的判断\ndate: 2021-05-11 15:00:11\ntags:\n---\n\n### 判断是否支持bitcode\n执行命令：\n```\notool -arch arm64 -l xxxxx.a(二进制文件) | grep __bitcode | wc -l\n```\n\n* 结果非0： 支持bitcode\n* 结果0：不支持bitcode\n\n### 判断库中的架构\n\n执行命令：\n```\nlipo -i xxx.a(二进制文件)\n```\n支持的架构会打印出来\n\n### 判断静态库还是动态库\n\n执行命令：\n\n```\nfile xxx.a(二进制文件)\n```\n* 静态库包含`current ar archive random library`字样。\n* 动态库包含`dynamically linked shared library`字样\n\n","slug":"iOS库中bitcode、架构、静态动态的判断","published":1,"updated":"2021-05-11T07:00:44.776Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckojospsp0000890p0c7786jo","content":"<h3 id=\"判断是否支持bitcode\"><a href=\"#判断是否支持bitcode\" class=\"headerlink\" title=\"判断是否支持bitcode\"></a>判断是否支持bitcode</h3><p>执行命令：</p>\n<pre><code>otool -arch arm64 -l xxxxx.a(二进制文件) | grep __bitcode | wc -l</code></pre><ul>\n<li>结果非0： 支持bitcode</li>\n<li>结果0：不支持bitcode</li>\n</ul>\n<h3 id=\"判断库中的架构\"><a href=\"#判断库中的架构\" class=\"headerlink\" title=\"判断库中的架构\"></a>判断库中的架构</h3><p>执行命令：</p>\n<pre><code>lipo -i xxx.a(二进制文件)</code></pre><p>支持的架构会打印出来</p>\n<h3 id=\"判断静态库还是动态库\"><a href=\"#判断静态库还是动态库\" class=\"headerlink\" title=\"判断静态库还是动态库\"></a>判断静态库还是动态库</h3><p>执行命令：</p>\n<pre><code>file xxx.a(二进制文件)</code></pre><ul>\n<li>静态库包含<code>current ar archive random library</code>字样。</li>\n<li>动态库包含<code>dynamically linked shared library</code>字样</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"判断是否支持bitcode\"><a href=\"#判断是否支持bitcode\" class=\"headerlink\" title=\"判断是否支持bitcode\"></a>判断是否支持bitcode</h3><p>执行命令：</p>\n<pre><code>otool -arch arm64 -l xxxxx.a(二进制文件) | grep __bitcode | wc -l</code></pre><ul>\n<li>结果非0： 支持bitcode</li>\n<li>结果0：不支持bitcode</li>\n</ul>\n<h3 id=\"判断库中的架构\"><a href=\"#判断库中的架构\" class=\"headerlink\" title=\"判断库中的架构\"></a>判断库中的架构</h3><p>执行命令：</p>\n<pre><code>lipo -i xxx.a(二进制文件)</code></pre><p>支持的架构会打印出来</p>\n<h3 id=\"判断静态库还是动态库\"><a href=\"#判断静态库还是动态库\" class=\"headerlink\" title=\"判断静态库还是动态库\"></a>判断静态库还是动态库</h3><p>执行命令：</p>\n<pre><code>file xxx.a(二进制文件)</code></pre><ul>\n<li>静态库包含<code>current ar archive random library</code>字样。</li>\n<li>动态库包含<code>dynamically linked shared library</code>字样</li>\n</ul>\n"},{"title":"xcodebuild 踩坑和疑惑","date":"2021-05-12T06:43:24.000Z","_content":"\n# 不同打包选项的产物目录\n\n##### xcodebuild -target\n\n```\nxcodebuild archive -project ../ios/kiwi/kiwi.xcodeproj -target kiwi -configuration Release -arch \"x86_64\" -sdk $XCODE_SIMULATOR_SDK\n```\n打包时如果用**-target**选项，那么产物会打包到当前工程目录的“build/UninstalledProducts/iphoneos/”下面。\n\n##### xcodebuild -scheme\n\n\n```\nxcodebuild archive -project ../ios/kiwi/kiwi.xcodeproj -scheme kiwi -configuration Release -arch \"x86_64\" -sdk $XCODE_SIMULATOR_SDK\n```\n打包时如果用**-scheme**选项，那么产物会打包到DerivedData文件夹下面，例如:\n```\n/Users/jenkins/Library/Developer/Xcode/DerivedData/kiwi-haukwgjiorhjwxbmduttecrfbfml/Build/Intermediates.noindex/ArchiveIntermediates/kiwi/IntermediateBuildFilesPath/UninstalledProducts/iphoneos/\n```\n\n##### 修改产物目录的疑问\n\n修改DerivedData目录后，无论是在project  setting还是xcode setting中修改，用beyondcompare对比修改前后的工程文件，均没有变化。\n\n这就导致无法提交变更，不能同步给别人，目前还不知道这个修改到底改的哪个文件，很疑惑。\n\n# 采坑\n\n工程结构如下：\n![](https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2021/05/12/16208027369646.jpg)\n\n##### 背景\n\nkiwi和kiwi-cocos是两个静态库，kiwi会依赖的kiwi-cocos。\n\n##### 问题\n\n使用xcodebuild -target打包kiwi静态库时，总是提示找不到kiwi-cocos的库，但实际libkiwi-cocos的产物已经打包出来了。\n\n##### 尝试\n\n过程中尝试了改用**xcodebuild -scheme**打包，可以成功打包，但产物目录在DerivedData路径下：\n```\n/Users/jenkins/Library/Developer/Xcode/DerivedData/kiwi-haukwgjiorhjwxbmduttecrfbfml/Build/Intermediates.noindex/ArchiveIntermediates/kiwi/IntermediateBuildFilesPath/UninstalledProducts/iphoneos/\n```\n其中“kiwi-haukwgjiorhjwxbmduttecrfbfml”路径是乱码，没有找到获取这个路径的办法，产物虽然打出来了，但脚本中拼不出产物路径，搜索后发现，网上的静态库打包脚本都是使用**xcodebuild -target**的方式，然指定工程的相对路径，找到产物，于是再次改回**-target**。\n\n##### 最终解决\n\nmacos的工程依赖和ios的结构相同，mac使用的也是**xcodebuild -target**，却可以打包成功，这让我有点晕。\n\n最后抱着试一试的心态删除重新添加了ios工程中对kiwi-cocos的依赖，妈的解决了！一脸懵逼！\n![](https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2021/05/12/16208034012530.jpg)\n\n\n虽然解决了，但并不清楚原因，推测是依赖的kiwi-cocos产物md5有变化。这个问题暴露了我对工程配置的理解不足，后续要补齐对xcode工程设置和打包过程的短板。\n\n","source":"_posts/xcodebuild-踩坑和疑惑.md","raw":"---\ntitle: xcodebuild 踩坑和疑惑\ndate: 2021-05-12 14:43:24\ntags:\n---\n\n# 不同打包选项的产物目录\n\n##### xcodebuild -target\n\n```\nxcodebuild archive -project ../ios/kiwi/kiwi.xcodeproj -target kiwi -configuration Release -arch \"x86_64\" -sdk $XCODE_SIMULATOR_SDK\n```\n打包时如果用**-target**选项，那么产物会打包到当前工程目录的“build/UninstalledProducts/iphoneos/”下面。\n\n##### xcodebuild -scheme\n\n\n```\nxcodebuild archive -project ../ios/kiwi/kiwi.xcodeproj -scheme kiwi -configuration Release -arch \"x86_64\" -sdk $XCODE_SIMULATOR_SDK\n```\n打包时如果用**-scheme**选项，那么产物会打包到DerivedData文件夹下面，例如:\n```\n/Users/jenkins/Library/Developer/Xcode/DerivedData/kiwi-haukwgjiorhjwxbmduttecrfbfml/Build/Intermediates.noindex/ArchiveIntermediates/kiwi/IntermediateBuildFilesPath/UninstalledProducts/iphoneos/\n```\n\n##### 修改产物目录的疑问\n\n修改DerivedData目录后，无论是在project  setting还是xcode setting中修改，用beyondcompare对比修改前后的工程文件，均没有变化。\n\n这就导致无法提交变更，不能同步给别人，目前还不知道这个修改到底改的哪个文件，很疑惑。\n\n# 采坑\n\n工程结构如下：\n![](https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2021/05/12/16208027369646.jpg)\n\n##### 背景\n\nkiwi和kiwi-cocos是两个静态库，kiwi会依赖的kiwi-cocos。\n\n##### 问题\n\n使用xcodebuild -target打包kiwi静态库时，总是提示找不到kiwi-cocos的库，但实际libkiwi-cocos的产物已经打包出来了。\n\n##### 尝试\n\n过程中尝试了改用**xcodebuild -scheme**打包，可以成功打包，但产物目录在DerivedData路径下：\n```\n/Users/jenkins/Library/Developer/Xcode/DerivedData/kiwi-haukwgjiorhjwxbmduttecrfbfml/Build/Intermediates.noindex/ArchiveIntermediates/kiwi/IntermediateBuildFilesPath/UninstalledProducts/iphoneos/\n```\n其中“kiwi-haukwgjiorhjwxbmduttecrfbfml”路径是乱码，没有找到获取这个路径的办法，产物虽然打出来了，但脚本中拼不出产物路径，搜索后发现，网上的静态库打包脚本都是使用**xcodebuild -target**的方式，然指定工程的相对路径，找到产物，于是再次改回**-target**。\n\n##### 最终解决\n\nmacos的工程依赖和ios的结构相同，mac使用的也是**xcodebuild -target**，却可以打包成功，这让我有点晕。\n\n最后抱着试一试的心态删除重新添加了ios工程中对kiwi-cocos的依赖，妈的解决了！一脸懵逼！\n![](https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2021/05/12/16208034012530.jpg)\n\n\n虽然解决了，但并不清楚原因，推测是依赖的kiwi-cocos产物md5有变化。这个问题暴露了我对工程配置的理解不足，后续要补齐对xcode工程设置和打包过程的短板。\n\n","slug":"xcodebuild-踩坑和疑惑","published":1,"updated":"2021-05-14T07:09:51.162Z","_id":"ckol4kd3j0000i50p0kcj34wu","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"不同打包选项的产物目录\"><a href=\"#不同打包选项的产物目录\" class=\"headerlink\" title=\"不同打包选项的产物目录\"></a>不同打包选项的产物目录</h1><h5 id=\"xcodebuild-target\"><a href=\"#xcodebuild-target\" class=\"headerlink\" title=\"xcodebuild -target\"></a>xcodebuild -target</h5><pre><code>xcodebuild archive -project ../ios/kiwi/kiwi.xcodeproj -target kiwi -configuration Release -arch &quot;x86_64&quot; -sdk $XCODE_SIMULATOR_SDK</code></pre><p>打包时如果用<strong>-target</strong>选项，那么产物会打包到当前工程目录的“build/UninstalledProducts/iphoneos/”下面。</p>\n<h5 id=\"xcodebuild-scheme\"><a href=\"#xcodebuild-scheme\" class=\"headerlink\" title=\"xcodebuild -scheme\"></a>xcodebuild -scheme</h5><pre><code>xcodebuild archive -project ../ios/kiwi/kiwi.xcodeproj -scheme kiwi -configuration Release -arch &quot;x86_64&quot; -sdk $XCODE_SIMULATOR_SDK</code></pre><p>打包时如果用<strong>-scheme</strong>选项，那么产物会打包到DerivedData文件夹下面，例如:</p>\n<pre><code>/Users/jenkins/Library/Developer/Xcode/DerivedData/kiwi-haukwgjiorhjwxbmduttecrfbfml/Build/Intermediates.noindex/ArchiveIntermediates/kiwi/IntermediateBuildFilesPath/UninstalledProducts/iphoneos/</code></pre><h5 id=\"修改产物目录的疑问\"><a href=\"#修改产物目录的疑问\" class=\"headerlink\" title=\"修改产物目录的疑问\"></a>修改产物目录的疑问</h5><p>修改DerivedData目录后，无论是在project  setting还是xcode setting中修改，用beyondcompare对比修改前后的工程文件，均没有变化。</p>\n<p>这就导致无法提交变更，不能同步给别人，目前还不知道这个修改到底改的哪个文件，很疑惑。</p>\n<h1 id=\"采坑\"><a href=\"#采坑\" class=\"headerlink\" title=\"采坑\"></a>采坑</h1><p>工程结构如下：<br><img src=\"https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2021/05/12/16208027369646.jpg\" alt=\"\"></p>\n<h5 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h5><p>kiwi和kiwi-cocos是两个静态库，kiwi会依赖的kiwi-cocos。</p>\n<h5 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h5><p>使用xcodebuild -target打包kiwi静态库时，总是提示找不到kiwi-cocos的库，但实际libkiwi-cocos的产物已经打包出来了。</p>\n<h5 id=\"尝试\"><a href=\"#尝试\" class=\"headerlink\" title=\"尝试\"></a>尝试</h5><p>过程中尝试了改用<strong>xcodebuild -scheme</strong>打包，可以成功打包，但产物目录在DerivedData路径下：</p>\n<pre><code>/Users/jenkins/Library/Developer/Xcode/DerivedData/kiwi-haukwgjiorhjwxbmduttecrfbfml/Build/Intermediates.noindex/ArchiveIntermediates/kiwi/IntermediateBuildFilesPath/UninstalledProducts/iphoneos/</code></pre><p>其中“kiwi-haukwgjiorhjwxbmduttecrfbfml”路径是乱码，没有找到获取这个路径的办法，产物虽然打出来了，但脚本中拼不出产物路径，搜索后发现，网上的静态库打包脚本都是使用<strong>xcodebuild -target</strong>的方式，然指定工程的相对路径，找到产物，于是再次改回<strong>-target</strong>。</p>\n<h5 id=\"最终解决\"><a href=\"#最终解决\" class=\"headerlink\" title=\"最终解决\"></a>最终解决</h5><p>macos的工程依赖和ios的结构相同，mac使用的也是<strong>xcodebuild -target</strong>，却可以打包成功，这让我有点晕。</p>\n<p>最后抱着试一试的心态删除重新添加了ios工程中对kiwi-cocos的依赖，妈的解决了！一脸懵逼！<br><img src=\"https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2021/05/12/16208034012530.jpg\" alt=\"\"></p>\n<p>虽然解决了，但并不清楚原因，推测是依赖的kiwi-cocos产物md5有变化。这个问题暴露了我对工程配置的理解不足，后续要补齐对xcode工程设置和打包过程的短板。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"不同打包选项的产物目录\"><a href=\"#不同打包选项的产物目录\" class=\"headerlink\" title=\"不同打包选项的产物目录\"></a>不同打包选项的产物目录</h1><h5 id=\"xcodebuild-target\"><a href=\"#xcodebuild-target\" class=\"headerlink\" title=\"xcodebuild -target\"></a>xcodebuild -target</h5><pre><code>xcodebuild archive -project ../ios/kiwi/kiwi.xcodeproj -target kiwi -configuration Release -arch &quot;x86_64&quot; -sdk $XCODE_SIMULATOR_SDK</code></pre><p>打包时如果用<strong>-target</strong>选项，那么产物会打包到当前工程目录的“build/UninstalledProducts/iphoneos/”下面。</p>\n<h5 id=\"xcodebuild-scheme\"><a href=\"#xcodebuild-scheme\" class=\"headerlink\" title=\"xcodebuild -scheme\"></a>xcodebuild -scheme</h5><pre><code>xcodebuild archive -project ../ios/kiwi/kiwi.xcodeproj -scheme kiwi -configuration Release -arch &quot;x86_64&quot; -sdk $XCODE_SIMULATOR_SDK</code></pre><p>打包时如果用<strong>-scheme</strong>选项，那么产物会打包到DerivedData文件夹下面，例如:</p>\n<pre><code>/Users/jenkins/Library/Developer/Xcode/DerivedData/kiwi-haukwgjiorhjwxbmduttecrfbfml/Build/Intermediates.noindex/ArchiveIntermediates/kiwi/IntermediateBuildFilesPath/UninstalledProducts/iphoneos/</code></pre><h5 id=\"修改产物目录的疑问\"><a href=\"#修改产物目录的疑问\" class=\"headerlink\" title=\"修改产物目录的疑问\"></a>修改产物目录的疑问</h5><p>修改DerivedData目录后，无论是在project  setting还是xcode setting中修改，用beyondcompare对比修改前后的工程文件，均没有变化。</p>\n<p>这就导致无法提交变更，不能同步给别人，目前还不知道这个修改到底改的哪个文件，很疑惑。</p>\n<h1 id=\"采坑\"><a href=\"#采坑\" class=\"headerlink\" title=\"采坑\"></a>采坑</h1><p>工程结构如下：<br><img src=\"https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2021/05/12/16208027369646.jpg\" alt=\"\"></p>\n<h5 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h5><p>kiwi和kiwi-cocos是两个静态库，kiwi会依赖的kiwi-cocos。</p>\n<h5 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h5><p>使用xcodebuild -target打包kiwi静态库时，总是提示找不到kiwi-cocos的库，但实际libkiwi-cocos的产物已经打包出来了。</p>\n<h5 id=\"尝试\"><a href=\"#尝试\" class=\"headerlink\" title=\"尝试\"></a>尝试</h5><p>过程中尝试了改用<strong>xcodebuild -scheme</strong>打包，可以成功打包，但产物目录在DerivedData路径下：</p>\n<pre><code>/Users/jenkins/Library/Developer/Xcode/DerivedData/kiwi-haukwgjiorhjwxbmduttecrfbfml/Build/Intermediates.noindex/ArchiveIntermediates/kiwi/IntermediateBuildFilesPath/UninstalledProducts/iphoneos/</code></pre><p>其中“kiwi-haukwgjiorhjwxbmduttecrfbfml”路径是乱码，没有找到获取这个路径的办法，产物虽然打出来了，但脚本中拼不出产物路径，搜索后发现，网上的静态库打包脚本都是使用<strong>xcodebuild -target</strong>的方式，然指定工程的相对路径，找到产物，于是再次改回<strong>-target</strong>。</p>\n<h5 id=\"最终解决\"><a href=\"#最终解决\" class=\"headerlink\" title=\"最终解决\"></a>最终解决</h5><p>macos的工程依赖和ios的结构相同，mac使用的也是<strong>xcodebuild -target</strong>，却可以打包成功，这让我有点晕。</p>\n<p>最后抱着试一试的心态删除重新添加了ios工程中对kiwi-cocos的依赖，妈的解决了！一脸懵逼！<br><img src=\"https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2021/05/12/16208034012530.jpg\" alt=\"\"></p>\n<p>虽然解决了，但并不清楚原因，推测是依赖的kiwi-cocos产物md5有变化。这个问题暴露了我对工程配置的理解不足，后续要补齐对xcode工程设置和打包过程的短板。</p>\n"},{"title":"luajit iOS打包笔记","date":"2021-05-13T07:56:12.000Z","_content":"# luajit iOS打包笔记\n\n### 查看文档\n在doc/intall.html中提示，有关于iOS打包的指引：\n![](https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2021/05/13/16208916328164.jpg)\n\n使用这个作为打包命令，打包出产物后，产物**不支持bitcode**。\n\n### 添加bitcode支持\n\n转而在工程中搜索bitcode关键字，企图找到bitcode的开关，结果没有。又在转而想要自己添加bitcode的编译选项，[参考文档](https://www.geek-share.com/detail/2789992000.html).文档中提示想要支持bitcode，需要在CFlags中添加**-fembed-bitcode**和**-fembed-bitcode-maker**。\n\n知道了要添加的选项，接下来就是找到要添加的地方，打开src/MakeFile，在MakeFile中搜索CFLAGS，并没有使用，CFLAGS是系统变量他没用到我直接添加也是生效的,于是增加bitcode选项：\n![](https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2021/05/13/16208924923660.jpg)\n\n重新打包，解决！","source":"_posts/luajit-iOS打包笔记.md","raw":"---\ntitle: luajit iOS打包笔记\ndate: 2021-05-13 15:56:12\ntags:\n---\n# luajit iOS打包笔记\n\n### 查看文档\n在doc/intall.html中提示，有关于iOS打包的指引：\n![](https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2021/05/13/16208916328164.jpg)\n\n使用这个作为打包命令，打包出产物后，产物**不支持bitcode**。\n\n### 添加bitcode支持\n\n转而在工程中搜索bitcode关键字，企图找到bitcode的开关，结果没有。又在转而想要自己添加bitcode的编译选项，[参考文档](https://www.geek-share.com/detail/2789992000.html).文档中提示想要支持bitcode，需要在CFlags中添加**-fembed-bitcode**和**-fembed-bitcode-maker**。\n\n知道了要添加的选项，接下来就是找到要添加的地方，打开src/MakeFile，在MakeFile中搜索CFLAGS，并没有使用，CFLAGS是系统变量他没用到我直接添加也是生效的,于是增加bitcode选项：\n![](https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2021/05/13/16208924923660.jpg)\n\n重新打包，解决！","slug":"luajit-iOS打包笔记","published":1,"updated":"2021-05-13T07:56:42.613Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckomlm5i20000rx0pgcn37ybn","content":"<h1 id=\"luajit-iOS打包笔记\"><a href=\"#luajit-iOS打包笔记\" class=\"headerlink\" title=\"luajit iOS打包笔记\"></a>luajit iOS打包笔记</h1><h3 id=\"查看文档\"><a href=\"#查看文档\" class=\"headerlink\" title=\"查看文档\"></a>查看文档</h3><p>在doc/intall.html中提示，有关于iOS打包的指引：<br><img src=\"https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2021/05/13/16208916328164.jpg\" alt=\"\"></p>\n<p>使用这个作为打包命令，打包出产物后，产物<strong>不支持bitcode</strong>。</p>\n<h3 id=\"添加bitcode支持\"><a href=\"#添加bitcode支持\" class=\"headerlink\" title=\"添加bitcode支持\"></a>添加bitcode支持</h3><p>转而在工程中搜索bitcode关键字，企图找到bitcode的开关，结果没有。又在转而想要自己添加bitcode的编译选项，<a href=\"https://www.geek-share.com/detail/2789992000.html\" target=\"_blank\" rel=\"noopener\">参考文档</a>.文档中提示想要支持bitcode，需要在CFlags中添加<strong>-fembed-bitcode</strong>和<strong>-fembed-bitcode-maker</strong>。</p>\n<p>知道了要添加的选项，接下来就是找到要添加的地方，打开src/MakeFile，在MakeFile中搜索CFLAGS，并没有使用，CFLAGS是系统变量他没用到我直接添加也是生效的,于是增加bitcode选项：<br><img src=\"https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2021/05/13/16208924923660.jpg\" alt=\"\"></p>\n<p>重新打包，解决！</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"luajit-iOS打包笔记\"><a href=\"#luajit-iOS打包笔记\" class=\"headerlink\" title=\"luajit iOS打包笔记\"></a>luajit iOS打包笔记</h1><h3 id=\"查看文档\"><a href=\"#查看文档\" class=\"headerlink\" title=\"查看文档\"></a>查看文档</h3><p>在doc/intall.html中提示，有关于iOS打包的指引：<br><img src=\"https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2021/05/13/16208916328164.jpg\" alt=\"\"></p>\n<p>使用这个作为打包命令，打包出产物后，产物<strong>不支持bitcode</strong>。</p>\n<h3 id=\"添加bitcode支持\"><a href=\"#添加bitcode支持\" class=\"headerlink\" title=\"添加bitcode支持\"></a>添加bitcode支持</h3><p>转而在工程中搜索bitcode关键字，企图找到bitcode的开关，结果没有。又在转而想要自己添加bitcode的编译选项，<a href=\"https://www.geek-share.com/detail/2789992000.html\" target=\"_blank\" rel=\"noopener\">参考文档</a>.文档中提示想要支持bitcode，需要在CFlags中添加<strong>-fembed-bitcode</strong>和<strong>-fembed-bitcode-maker</strong>。</p>\n<p>知道了要添加的选项，接下来就是找到要添加的地方，打开src/MakeFile，在MakeFile中搜索CFLAGS，并没有使用，CFLAGS是系统变量他没用到我直接添加也是生效的,于是增加bitcode选项：<br><img src=\"https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2021/05/13/16208924923660.jpg\" alt=\"\"></p>\n<p>重新打包，解决！</p>\n"},{"title":"webp iOS打包笔记","date":"2021-05-13T08:50:47.000Z","_content":"\n### 修改原有打包脚本\n\n原本的打包脚本中已经支持了bitcode，还需要修改的是把framework包装改成.a。\n\nwebp工程在根目录下自带了iosbuild.sh打包脚本，表扬！基于iosbuild.sh直接修改就好了，修改这么几处：\n\n##### framework改为.a包装\n![](https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2021/05/13/16208961142445.jpg)\n\n##### 干掉不用的架构\n![](https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2021/05/13/16208961375689.jpg)\n\n##### 修改产物后缀\n![](https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2021/05/13/16208961590645.jpg)\n\n然后执行脚本，拿产物，收工。","source":"_posts/webp-iOS打包笔记.md","raw":"---\ntitle: webp iOS打包笔记\ndate: 2021-05-13 16:50:47\ntags:\n---\n\n### 修改原有打包脚本\n\n原本的打包脚本中已经支持了bitcode，还需要修改的是把framework包装改成.a。\n\nwebp工程在根目录下自带了iosbuild.sh打包脚本，表扬！基于iosbuild.sh直接修改就好了，修改这么几处：\n\n##### framework改为.a包装\n![](https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2021/05/13/16208961142445.jpg)\n\n##### 干掉不用的架构\n![](https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2021/05/13/16208961375689.jpg)\n\n##### 修改产物后缀\n![](https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2021/05/13/16208961590645.jpg)\n\n然后执行脚本，拿产物，收工。","slug":"webp-iOS打包笔记","published":1,"updated":"2021-05-13T08:57:16.500Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckomo5jzt0000ci0pcu0dhxsu","content":"<h3 id=\"修改原有打包脚本\"><a href=\"#修改原有打包脚本\" class=\"headerlink\" title=\"修改原有打包脚本\"></a>修改原有打包脚本</h3><p>原本的打包脚本中已经支持了bitcode，还需要修改的是把framework包装改成.a。</p>\n<p>webp工程在根目录下自带了iosbuild.sh打包脚本，表扬！基于iosbuild.sh直接修改就好了，修改这么几处：</p>\n<h5 id=\"framework改为-a包装\"><a href=\"#framework改为-a包装\" class=\"headerlink\" title=\"framework改为.a包装\"></a>framework改为.a包装</h5><p><img src=\"https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2021/05/13/16208961142445.jpg\" alt=\"\"></p>\n<h5 id=\"干掉不用的架构\"><a href=\"#干掉不用的架构\" class=\"headerlink\" title=\"干掉不用的架构\"></a>干掉不用的架构</h5><p><img src=\"https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2021/05/13/16208961375689.jpg\" alt=\"\"></p>\n<h5 id=\"修改产物后缀\"><a href=\"#修改产物后缀\" class=\"headerlink\" title=\"修改产物后缀\"></a>修改产物后缀</h5><p><img src=\"https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2021/05/13/16208961590645.jpg\" alt=\"\"></p>\n<p>然后执行脚本，拿产物，收工。</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"修改原有打包脚本\"><a href=\"#修改原有打包脚本\" class=\"headerlink\" title=\"修改原有打包脚本\"></a>修改原有打包脚本</h3><p>原本的打包脚本中已经支持了bitcode，还需要修改的是把framework包装改成.a。</p>\n<p>webp工程在根目录下自带了iosbuild.sh打包脚本，表扬！基于iosbuild.sh直接修改就好了，修改这么几处：</p>\n<h5 id=\"framework改为-a包装\"><a href=\"#framework改为-a包装\" class=\"headerlink\" title=\"framework改为.a包装\"></a>framework改为.a包装</h5><p><img src=\"https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2021/05/13/16208961142445.jpg\" alt=\"\"></p>\n<h5 id=\"干掉不用的架构\"><a href=\"#干掉不用的架构\" class=\"headerlink\" title=\"干掉不用的架构\"></a>干掉不用的架构</h5><p><img src=\"https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2021/05/13/16208961375689.jpg\" alt=\"\"></p>\n<h5 id=\"修改产物后缀\"><a href=\"#修改产物后缀\" class=\"headerlink\" title=\"修改产物后缀\"></a>修改产物后缀</h5><p><img src=\"https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2021/05/13/16208961590645.jpg\" alt=\"\"></p>\n<p>然后执行脚本，拿产物，收工。</p>\n"},{"title":"Chipmunk2D iOS打包笔记","date":"2021-05-13T07:58:08.000Z","_content":"\n### 走的弯路\n\n开始打开Chipmunk文件夹后，看到有CMakeList.txt，惯性的开始写脚本使用cmake打包，结果找不到opengl，绕了一大圈才发现根目录下有生成好的XCode工程😂。\n![](https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2021/05/13/16208929982115.jpg)\n\n### 打包\n\n打开根目录下的xcode/Chipmunk7.xcodeproj\n\n* 选择scheme为Chipmunk-iOS\n* 修改config为Release\n* 在build setting中修改bitcode为YES\n* 架构支持改为arm64真机和x86_64模拟器\n* 打包、拿产物、合并多架构、完成。\n","source":"_posts/Chipmunk2D-iOS打包笔记.md","raw":"---\ntitle: Chipmunk2D iOS打包笔记\ndate: 2021-05-13 15:58:08\ntags:\n---\n\n### 走的弯路\n\n开始打开Chipmunk文件夹后，看到有CMakeList.txt，惯性的开始写脚本使用cmake打包，结果找不到opengl，绕了一大圈才发现根目录下有生成好的XCode工程😂。\n![](https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2021/05/13/16208929982115.jpg)\n\n### 打包\n\n打开根目录下的xcode/Chipmunk7.xcodeproj\n\n* 选择scheme为Chipmunk-iOS\n* 修改config为Release\n* 在build setting中修改bitcode为YES\n* 架构支持改为arm64真机和x86_64模拟器\n* 打包、拿产物、合并多架构、完成。\n","slug":"Chipmunk2D-iOS打包笔记","published":1,"updated":"2021-05-13T08:11:53.876Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckomo5jzy0001ci0p41i4cqkh","content":"<h3 id=\"走的弯路\"><a href=\"#走的弯路\" class=\"headerlink\" title=\"走的弯路\"></a>走的弯路</h3><p>开始打开Chipmunk文件夹后，看到有CMakeList.txt，惯性的开始写脚本使用cmake打包，结果找不到opengl，绕了一大圈才发现根目录下有生成好的XCode工程😂。<br><img src=\"https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2021/05/13/16208929982115.jpg\" alt=\"\"></p>\n<h3 id=\"打包\"><a href=\"#打包\" class=\"headerlink\" title=\"打包\"></a>打包</h3><p>打开根目录下的xcode/Chipmunk7.xcodeproj</p>\n<ul>\n<li>选择scheme为Chipmunk-iOS</li>\n<li>修改config为Release</li>\n<li>在build setting中修改bitcode为YES</li>\n<li>架构支持改为arm64真机和x86_64模拟器</li>\n<li>打包、拿产物、合并多架构、完成。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"走的弯路\"><a href=\"#走的弯路\" class=\"headerlink\" title=\"走的弯路\"></a>走的弯路</h3><p>开始打开Chipmunk文件夹后，看到有CMakeList.txt，惯性的开始写脚本使用cmake打包，结果找不到opengl，绕了一大圈才发现根目录下有生成好的XCode工程😂。<br><img src=\"https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2021/05/13/16208929982115.jpg\" alt=\"\"></p>\n<h3 id=\"打包\"><a href=\"#打包\" class=\"headerlink\" title=\"打包\"></a>打包</h3><p>打开根目录下的xcode/Chipmunk7.xcodeproj</p>\n<ul>\n<li>选择scheme为Chipmunk-iOS</li>\n<li>修改config为Release</li>\n<li>在build setting中修改bitcode为YES</li>\n<li>架构支持改为arm64真机和x86_64模拟器</li>\n<li>打包、拿产物、合并多架构、完成。</li>\n</ul>\n"},{"title":"解决SourceTree反复要求输入密码","date":"2021-06-14T08:15:13.000Z","_content":"\n# 病情\nsourcetree提交的时候不停地弹出窗口，要求输入密码，输入之后并没有卵用，逼死强迫症了！！！\n\n![](https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2021/06/14/16236585439228.jpg)\n\n\n# 治疗\n\n控制台输入命令:\n\n```\ngit config --global credential.helper osxkeychain\n```\n\n打开sourcetree，这时会要求输入一遍开机密码，记得点击始终允许，完事！出院！","source":"_posts/解决SourceTree反复要求输入密码.md","raw":"---\ntitle: 解决SourceTree反复要求输入密码\ndate: 2021-06-14 16:15:13\ntags:\n---\n\n# 病情\nsourcetree提交的时候不停地弹出窗口，要求输入密码，输入之后并没有卵用，逼死强迫症了！！！\n\n![](https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2021/06/14/16236585439228.jpg)\n\n\n# 治疗\n\n控制台输入命令:\n\n```\ngit config --global credential.helper osxkeychain\n```\n\n打开sourcetree，这时会要求输入一遍开机密码，记得点击始终允许，完事！出院！","slug":"解决SourceTree反复要求输入密码","published":1,"updated":"2021-06-14T08:19:02.373Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckpwci1140000ki0pepuk8xm1","content":"<h1 id=\"病情\"><a href=\"#病情\" class=\"headerlink\" title=\"病情\"></a>病情</h1><p>sourcetree提交的时候不停地弹出窗口，要求输入密码，输入之后并没有卵用，逼死强迫症了！！！</p>\n<p><img src=\"https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2021/06/14/16236585439228.jpg\" alt=\"\"></p>\n<h1 id=\"治疗\"><a href=\"#治疗\" class=\"headerlink\" title=\"治疗\"></a>治疗</h1><p>控制台输入命令:</p>\n<pre><code>git config --global credential.helper osxkeychain</code></pre><p>打开sourcetree，这时会要求输入一遍开机密码，记得点击始终允许，完事！出院！</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"病情\"><a href=\"#病情\" class=\"headerlink\" title=\"病情\"></a>病情</h1><p>sourcetree提交的时候不停地弹出窗口，要求输入密码，输入之后并没有卵用，逼死强迫症了！！！</p>\n<p><img src=\"https://mweb-image-1259394369.cos.ap-guangzhou.myqcloud.com/2021/06/14/16236585439228.jpg\" alt=\"\"></p>\n<h1 id=\"治疗\"><a href=\"#治疗\" class=\"headerlink\" title=\"治疗\"></a>治疗</h1><p>控制台输入命令:</p>\n<pre><code>git config --global credential.helper osxkeychain</code></pre><p>打开sourcetree，这时会要求输入一遍开机密码，记得点击始终允许，完事！出院！</p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"ckgyxlisw000d0iu66vtje3vd","tag_id":"ckgyxfglv000ax7u69h4gc4gn","_id":"ckgyxlisx000f0iu67jav469t"}],"Tag":[{"name":"arduino","_id":"ckgyxfglv000ax7u69h4gc4gn"}]}}